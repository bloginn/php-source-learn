/*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2016 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   |          Dmitry Stogov <dmitry@zend.com>                             |
   +----------------------------------------------------------------------+
*/

#ifdef ZEND_WIN32
# pragma warning(once : 4101)
# pragma warning(once : 6235)
# pragma warning(once : 6237)
# pragma warning(once : 6239)
# pragma warning(once : 6240)
# pragma warning(once : 6285)
# pragma warning(once : 6286)
# pragma warning(once : 6326)
#endif
static user_opcode_handler_t zend_user_opcode_handlers[256] = {
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL
};

static zend_uchar zend_user_opcodes[256] = {0,
	1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
	17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,
	33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
	49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,
	65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,
	81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,
	97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
	113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,
	129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,
	145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,
	161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,
	177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,
	193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,
	209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,
	225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,
	241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
};

static opcode_handler_t zend_vm_get_opcode_handler(zend_uchar opcode, zend_op* op);


#undef OPLINE
#undef DCL_OPLINE
#undef USE_OPLINE
#undef LOAD_OPLINE
#undef SAVE_OPLINE
#define OPLINE EX(opline)
#define DCL_OPLINE
#define USE_OPLINE zend_op *opline = EX(opline);
#define LOAD_OPLINE()
#define SAVE_OPLINE()
#undef CHECK_EXCEPTION
#undef HANDLE_EXCEPTION
#undef HANDLE_EXCEPTION_LEAVE
#define CHECK_EXCEPTION() LOAD_OPLINE()
#define HANDLE_EXCEPTION() LOAD_OPLINE(); ZEND_VM_CONTINUE()
#define HANDLE_EXCEPTION_LEAVE() LOAD_OPLINE(); ZEND_VM_LEAVE()
#define LOAD_REGS()
#define ZEND_VM_CONTINUE()         return 0
#define ZEND_VM_RETURN()           return 1
#define ZEND_VM_ENTER()            return 2
#define ZEND_VM_LEAVE()            return 3
#define ZEND_VM_DISPATCH(opcode, opline) return zend_vm_get_opcode_handler(opcode, opline)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);

#define ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_INTERNAL execute_data TSRMLS_CC

ZEND_API void execute_ex(zend_execute_data *execute_data TSRMLS_DC)
{
	DCL_OPLINE
	zend_bool original_in_execution;



	original_in_execution = EG(in_execution);
	EG(in_execution) = 1;

	if (0) {
zend_vm_enter:
		execute_data = i_create_execute_data_from_op_array(EG(active_op_array), 1 TSRMLS_CC);
	}

	LOAD_REGS();
	LOAD_OPLINE();

	while (1) {
    	int ret;
#ifdef ZEND_WIN32
		if (EG(timed_out)) {
			zend_timeout(0);
		}
#endif

		if ((ret = OPLINE->handler(execute_data TSRMLS_CC)) > 0) {
			switch (ret) {
				case 1:
					EG(in_execution) = original_in_execution;
					return;
				case 2:
					goto zend_vm_enter;
					break;
				case 3:
					execute_data = EG(current_execute_data);
					break;
				default:
					break;
			}
		}

	}
	zend_error_noreturn(E_ERROR, "Arrived at end of main loop which shouldn't happen");
}

ZEND_API void zend_execute(zend_op_array *op_array TSRMLS_DC)
{
	if (EG(exception)) {
		return;
	} 
	zend_execute_ex(i_create_execute_data_from_op_array(op_array, 0 TSRMLS_CC) TSRMLS_CC);
}

static int ZEND_FASTCALL zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_bool nested = EX(nested);
	zend_op_array *op_array = EX(op_array);

	EG(current_execute_data) = EX(prev_execute_data);
	EG(opline_ptr) = NULL;
	if (!EG(active_symbol_table)) {
		i_free_compiled_variables(execute_data TSRMLS_CC);
	}

	zend_vm_stack_free((char*)execute_data - (ZEND_MM_ALIGNED_SIZE(sizeof(temp_variable)) * op_array->T) TSRMLS_CC);

	if ((op_array->fn_flags & ZEND_ACC_CLOSURE) && op_array->prototype) {
		zval_ptr_dtor((zval**)&op_array->prototype);
	}

	if (nested) {
		execute_data = EG(current_execute_data);
	}
	if (nested) {
		USE_OPLINE

		LOAD_REGS();
		LOAD_OPLINE();
		if (UNEXPECTED(opline->opcode == ZEND_INCLUDE_OR_EVAL)) {

			EX(function_state).function = (zend_function *) EX(op_array);
			EX(function_state).arguments = NULL;

			EG(opline_ptr) = &EX(opline);
			EG(active_op_array) = EX(op_array);
			EG(return_value_ptr_ptr) = EX(original_return_value);
			destroy_op_array(op_array TSRMLS_CC);
			efree(op_array);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zend_throw_exception_internal(NULL TSRMLS_CC);
				HANDLE_EXCEPTION_LEAVE();
			}

			ZEND_VM_INC_OPCODE();
			ZEND_VM_LEAVE();
		} else {
			EG(opline_ptr) = &EX(opline);
			EG(active_op_array) = EX(op_array);
			EG(return_value_ptr_ptr) = EX(original_return_value);
			if (EG(active_symbol_table)) {
				zend_clean_and_cache_symbol_table(EG(active_symbol_table) TSRMLS_CC);
			}
			EG(active_symbol_table) = EX(symbol_table);

			EX(function_state).function = (zend_function *) EX(op_array);
			EX(function_state).arguments = NULL;

			if (EG(This)) {
				if (UNEXPECTED(EG(exception) != NULL) && EX(call)->is_ctor_call) {
					if (EX(call)->is_ctor_result_used) {
						Z_DELREF_P(EG(This));
					}
					if (Z_REFCOUNT_P(EG(This)) == 1) {
						zend_object_store_ctor_failed(EG(This) TSRMLS_CC);
					}
				}
				zval_ptr_dtor(&EG(This));
			}
			EG(This) = EX(current_this);
			EG(scope) = EX(current_scope);
			EG(called_scope) = EX(current_called_scope);

			EX(call)--;

			zend_vm_stack_clear_multiple(0 TSRMLS_CC);

			if (UNEXPECTED(EG(exception) != NULL)) {
				zend_throw_exception_internal(NULL TSRMLS_CC);
				if (RETURN_VALUE_USED(opline) && EX_T(opline->result.var).var.ptr) {
					zval_ptr_dtor(&EX_T(opline->result.var).var.ptr);
				}
				HANDLE_EXCEPTION_LEAVE();
			}

			ZEND_VM_INC_OPCODE();
			ZEND_VM_LEAVE();
		}
	}
	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL zend_do_fcall_common_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_bool should_change_scope = 0;
	zend_function *fbc = EX(function_state).function;
	zend_uint num_args;

	SAVE_OPLINE();
	EX(object) = EX(call)->object;
	if (UNEXPECTED((fbc->common.fn_flags & (ZEND_ACC_ABSTRACT|ZEND_ACC_DEPRECATED)) != 0)) {
		if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_ABSTRACT) != 0)) {
			zend_error_noreturn(E_ERROR, "Cannot call abstract method %s::%s()", fbc->common.scope->name, fbc->common.function_name);
		}
		if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_DEPRECATED) != 0)) {
			zend_error(E_DEPRECATED, "Function %s%s%s() is deprecated",
				fbc->common.scope ? fbc->common.scope->name : "",
				fbc->common.scope ? "::" : "",
				fbc->common.function_name);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
	}
	if (fbc->common.scope &&
		!(fbc->common.fn_flags & ZEND_ACC_STATIC) &&
		!EX(object)) {

		if (fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
			/* FIXME: output identifiers properly */
			zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically", fbc->common.scope->name, fbc->common.function_name);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		} else {
			/* FIXME: output identifiers properly */
			/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
			zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically", fbc->common.scope->name, fbc->common.function_name);
		}
	}

	if (fbc->type == ZEND_USER_FUNCTION || fbc->common.scope) {
		should_change_scope = 1;
		EX(current_this) = EG(This);
		EX(current_scope) = EG(scope);
		EX(current_called_scope) = EG(called_scope);
		EG(This) = EX(object);
		EG(scope) = (fbc->type == ZEND_USER_FUNCTION || !EX(object)) ? fbc->common.scope : NULL;
		EG(called_scope) = EX(call)->called_scope;
	}

	num_args = opline->extended_value + EX(call)->num_additional_args;
	if (EX(call)->num_additional_args) {
		EX(function_state).arguments = zend_vm_stack_push_args(num_args TSRMLS_CC);
	} else {
		EX(function_state).arguments = zend_vm_stack_top(TSRMLS_C);
		zend_vm_stack_push((void*)(zend_uintptr_t) num_args TSRMLS_CC);
	}
	LOAD_OPLINE();

	if (fbc->type == ZEND_INTERNAL_FUNCTION) {
		if (fbc->common.fn_flags & ZEND_ACC_HAS_TYPE_HINTS) {
			zend_uint i;
			void **p = EX(function_state).arguments - num_args;

			for (i = 0; i < num_args; ++i, ++p) {
				zend_verify_arg_type(fbc, i + 1, (zval *) *p, 0, NULL TSRMLS_CC);
			}
		}

		if (EXPECTED(EG(exception) == NULL)) {
			temp_variable *ret = &EX_T(opline->result.var);

			MAKE_STD_ZVAL(ret->var.ptr);
			ZVAL_NULL(ret->var.ptr);
			ret->var.ptr_ptr = &ret->var.ptr;
			ret->var.fcall_returned_reference = (fbc->common.fn_flags & ZEND_ACC_RETURN_REFERENCE) != 0;

			if (!zend_execute_internal) {
				/* saves one function call if zend_execute_internal is not used */
				fbc->internal_function.handler(num_args, ret->var.ptr, &ret->var.ptr, EX(object), RETURN_VALUE_USED(opline) TSRMLS_CC);
			} else {
				zend_execute_internal(execute_data, NULL, RETURN_VALUE_USED(opline) TSRMLS_CC);
			}

			if (!RETURN_VALUE_USED(opline)) {
				zval_ptr_dtor(&ret->var.ptr);
			}
		} else if (RETURN_VALUE_USED(opline)) {
			EX_T(opline->result.var).var.ptr = NULL;
		}
	} else if (fbc->type == ZEND_USER_FUNCTION) {
		temp_variable *ret = &EX_T(opline->result.var);
		EX(original_return_value) = EG(return_value_ptr_ptr);
		EG(active_symbol_table) = NULL;
		EG(active_op_array) = &fbc->op_array;
		EG(return_value_ptr_ptr) = NULL;
		if (RETURN_VALUE_USED(opline)) {
			ret->var.ptr = NULL;
			EG(return_value_ptr_ptr) = &ret->var.ptr;
			ret->var.ptr_ptr = &ret->var.ptr;
			ret->var.fcall_returned_reference = (fbc->common.fn_flags & ZEND_ACC_RETURN_REFERENCE) != 0;
		}

		if (UNEXPECTED((EG(active_op_array)->fn_flags & ZEND_ACC_GENERATOR) != 0)) {
			if (RETURN_VALUE_USED(opline)) {
				ret->var.ptr = zend_generator_create_zval(EG(active_op_array) TSRMLS_CC);
				ret->var.fcall_returned_reference = 0;
			}
		} else if (EXPECTED(zend_execute_ex == execute_ex)) {
			if (EXPECTED(EG(exception) == NULL)) {
				ZEND_VM_ENTER();
			}
		} else {
			zend_execute(EG(active_op_array) TSRMLS_CC);
		}

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		EG(return_value_ptr_ptr) = EX(original_return_value);
		if (EG(active_symbol_table)) {
			zend_clean_and_cache_symbol_table(EG(active_symbol_table) TSRMLS_CC);
		}
		EG(active_symbol_table) = EX(symbol_table);
	} else { /* ZEND_OVERLOADED_FUNCTION */
		MAKE_STD_ZVAL(EX_T(opline->result.var).var.ptr);
		ZVAL_NULL(EX_T(opline->result.var).var.ptr);

		/* Not sure what should be done here if it's a static method */
		if (EXPECTED(EX(object) != NULL)) {
			Z_OBJ_HT_P(EX(object))->call_method(fbc->common.function_name, num_args, EX_T(opline->result.var).var.ptr, &EX_T(opline->result.var).var.ptr, EX(object), RETURN_VALUE_USED(opline) TSRMLS_CC);
		} else {
			zend_error_noreturn(E_ERROR, "Cannot call overloaded function for non-object");
		}

		if (fbc->type == ZEND_OVERLOADED_FUNCTION_TEMPORARY) {
			efree((char*)fbc->common.function_name);
		}
		efree(fbc);

		if (!RETURN_VALUE_USED(opline)) {
			zval_ptr_dtor(&EX_T(opline->result.var).var.ptr);
		} else {
			Z_UNSET_ISREF_P(EX_T(opline->result.var).var.ptr);
			Z_SET_REFCOUNT_P(EX_T(opline->result.var).var.ptr, 1);
			EX_T(opline->result.var).var.fcall_returned_reference = 0;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		}
	}

	EX(function_state).function = (zend_function *) EX(op_array);
	EX(function_state).arguments = NULL;

	if (should_change_scope) {
		if (EG(This)) {
			if (UNEXPECTED(EG(exception) != NULL) && EX(call)->is_ctor_call) {
				if (EX(call)->is_ctor_result_used) {
					Z_DELREF_P(EG(This));
				}
				if (Z_REFCOUNT_P(EG(This)) == 1) {
					zend_object_store_ctor_failed(EG(This) TSRMLS_CC);
				}
			}
			zval_ptr_dtor(&EG(This));
		}
		EG(This) = EX(current_this);
		EG(scope) = EX(current_scope);
		EG(called_scope) = EX(current_called_scope);
	}

	EX(call)--;

	zend_vm_stack_clear_multiple(0 TSRMLS_CC);

	if (UNEXPECTED(EG(exception) != NULL)) {
		zend_throw_exception_internal(NULL TSRMLS_CC);
		if (RETURN_VALUE_USED(opline) && EX_T(opline->result.var).var.ptr) {
			zval_ptr_dtor(&EX_T(opline->result.var).var.ptr);
		}
		HANDLE_EXCEPTION();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

#if DEBUG_ZEND>=2
	printf("Jumping to %d\n", opline->op1.opline_num);
#endif
	ZEND_VM_SET_OPCODE(opline->op1.jmp_addr);
	ZEND_VM_CONTINUE();
}

static int ZEND_FASTCALL  ZEND_INIT_STRING_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *tmp = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	tmp->value.str.val = emalloc(1);
	tmp->value.str.val[0] = 0;
	tmp->value.str.len = 0;
	Z_SET_REFCOUNT_P(tmp, 1);
	tmp->type = IS_STRING;
	Z_UNSET_ISREF_P(tmp);
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	EX(function_state).function = EX(call)->fbc;
	return zend_do_fcall_common_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_GENERATOR_RETURN_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	/* Close the generator to free up resources */
	zend_generator_close(generator, 1 TSRMLS_CC);

	/* Pass execution back to handling code */
	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_SEND_UNPACK_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *args;
	int arg_num;
	SAVE_OPLINE();

	args = get_zval_ptr(opline->op1_type, &opline->op1, execute_data, &free_op1, BP_VAR_R);
	arg_num = opline->op2.num + EX(call)->num_additional_args + 1;

	switch (Z_TYPE_P(args)) {
		case IS_ARRAY: {
			HashTable *ht = Z_ARRVAL_P(args);
			HashPosition pos;
			zval **arg_ptr, *arg;

			ZEND_VM_STACK_GROW_IF_NEEDED(zend_hash_num_elements(ht));

			for (zend_hash_internal_pointer_reset_ex(ht, &pos);
			     zend_hash_get_current_data_ex(ht, (void **) &arg_ptr, &pos) == SUCCESS;
			     zend_hash_move_forward_ex(ht, &pos), ++arg_num
			) {
				char *name;
				zend_uint name_len;
				zend_ulong index;

				if (zend_hash_get_current_key_ex(ht, &name, &name_len, &index, 0, &pos) == HASH_KEY_IS_STRING) {
					zend_error(E_RECOVERABLE_ERROR, "Cannot unpack array with string keys");
					FREE_OP(free_op1);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}

				if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, arg_num)) {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(arg_ptr);
					arg = *arg_ptr;
					Z_ADDREF_P(arg);
				} else if (Z_ISREF_PP(arg_ptr)) {
					ALLOC_ZVAL(arg);
					MAKE_COPY_ZVAL(arg_ptr, arg);
				} else {
					arg = *arg_ptr;
					Z_ADDREF_P(arg);
				}

				zend_vm_stack_push(arg TSRMLS_CC);
				EX(call)->num_additional_args++;
			}
			break;
		}
		case IS_OBJECT: {
			zend_class_entry *ce = Z_OBJCE_P(args);
			zend_object_iterator *iter;

			if (!ce || !ce->get_iterator) {
				zend_error(E_WARNING, "Only arrays and Traversables can be unpacked");
				break;
			}

			iter = ce->get_iterator(ce, args, 0 TSRMLS_CC);
			if (UNEXPECTED(!iter)) {
				FREE_OP(free_op1);
				if (!EG(exception)) {
					zend_throw_exception_ex(
						NULL, 0 TSRMLS_CC, "Object of type %s did not create an Iterator", ce->name
					);
				}
				HANDLE_EXCEPTION();
			}

			if (iter->funcs->rewind) {
				iter->funcs->rewind(iter TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					goto unpack_iter_dtor;
				}
			}

			for (; iter->funcs->valid(iter TSRMLS_CC) == SUCCESS; ++arg_num) {
				zval **arg_ptr, *arg;

				if (UNEXPECTED(EG(exception) != NULL)) {
					goto unpack_iter_dtor;
				}

				iter->funcs->get_current_data(iter, &arg_ptr TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					goto unpack_iter_dtor;
				}

				if (iter->funcs->get_current_key) {
					zval key;
					iter->funcs->get_current_key(iter, &key TSRMLS_CC);
					if (UNEXPECTED(EG(exception) != NULL)) {
						goto unpack_iter_dtor;
					}

					if (Z_TYPE(key) == IS_STRING) {
						zend_error(E_RECOVERABLE_ERROR,
							"Cannot unpack Traversable with string keys");
						zval_dtor(&key);
						goto unpack_iter_dtor;
					}

					zval_dtor(&key);
				}

				if (ARG_MUST_BE_SENT_BY_REF(EX(call)->fbc, arg_num)) {
					zend_error(
						E_WARNING, "Cannot pass by-reference argument %d of %s%s%s()"
						" by unpacking a Traversable, passing by-value instead", arg_num,
						EX(call)->fbc->common.scope ? EX(call)->fbc->common.scope->name : "",
						EX(call)->fbc->common.scope ? "::" : "",
						EX(call)->fbc->common.function_name
					);
				}

				if (Z_ISREF_PP(arg_ptr)) {
					ALLOC_ZVAL(arg);
					MAKE_COPY_ZVAL(arg_ptr, arg);
				} else {
					arg = *arg_ptr;
					Z_ADDREF_P(arg);
				}

				ZEND_VM_STACK_GROW_IF_NEEDED(1);
				zend_vm_stack_push(arg TSRMLS_CC);
				EX(call)->num_additional_args++;

				iter->funcs->move_forward(iter TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					goto unpack_iter_dtor;
				}
			}

unpack_iter_dtor:
			iter->funcs->dtor(iter TSRMLS_CC);
			break;
		}
		default:
			zend_error(E_WARNING, "Only arrays and Traversables can be unpacked");
	}

	FREE_OP(free_op1);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_RECV_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_uint arg_num = opline->op1.num;
	zval **param = zend_vm_stack_get_arg(arg_num TSRMLS_CC);

	SAVE_OPLINE();
	if (UNEXPECTED(param == NULL)) {
		if (zend_verify_arg_type((zend_function *) EG(active_op_array), arg_num, NULL, opline->extended_value, NULL TSRMLS_CC)) {
			const char *space;
			const char *class_name;
			zend_execute_data *ptr;

			if (EG(active_op_array)->scope) {
				class_name = EG(active_op_array)->scope->name;
				space = "::";
			} else {
				class_name = space = "";
			}
			ptr = EX(prev_execute_data);

			if(ptr && ptr->op_array) {
				zend_error(E_WARNING, "Missing argument %u for %s%s%s(), called in %s on line %d and defined", opline->op1.num, class_name, space, get_active_function_name(TSRMLS_C), ptr->op_array->filename, ptr->opline->lineno);
			} else {
				zend_error(E_WARNING, "Missing argument %u for %s%s%s()", opline->op1.num, class_name, space, get_active_function_name(TSRMLS_C));
			}
		}
	} else {
		zval **var_ptr;

		zend_verify_arg_type((zend_function *) EG(active_op_array), arg_num, *param, opline->extended_value, NULL TSRMLS_CC);
		var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->result.var TSRMLS_CC);
		Z_DELREF_PP(var_ptr);
		*var_ptr = *param;
		Z_ADDREF_PP(var_ptr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_RECV_VARIADIC_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_uint arg_num = opline->op1.num;
	zend_uint arg_count = zend_vm_stack_get_args_count(TSRMLS_C);
	zval **var_ptr, *params;

	SAVE_OPLINE();

	var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->result.var TSRMLS_CC);
	Z_DELREF_PP(var_ptr);
	MAKE_STD_ZVAL(params);
	*var_ptr = params;

	if (arg_num <= arg_count) {
		array_init_size(params, arg_count - arg_num + 1);
	} else {
		array_init(params);
	}

	for (; arg_num <= arg_count; ++arg_num) {
		zval **param = zend_vm_stack_get_arg(arg_num TSRMLS_CC);
		zend_verify_arg_type((zend_function *) EG(active_op_array), arg_num, *param, opline->extended_value, NULL TSRMLS_CC);
		zend_hash_next_index_insert(Z_ARRVAL_P(params), param, sizeof(zval *), NULL);
		Z_ADDREF_PP(param);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_NEW_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_zval;
	zend_function *constructor;

	SAVE_OPLINE();
	if (UNEXPECTED((EX_T(opline->op1.var).class_entry->ce_flags & (ZEND_ACC_INTERFACE|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) != 0)) {
		if (EX_T(opline->op1.var).class_entry->ce_flags & ZEND_ACC_INTERFACE) {
			zend_error_noreturn(E_ERROR, "Cannot instantiate interface %s", EX_T(opline->op1.var).class_entry->name);
		} else if ((EX_T(opline->op1.var).class_entry->ce_flags & ZEND_ACC_TRAIT) == ZEND_ACC_TRAIT) {
			zend_error_noreturn(E_ERROR, "Cannot instantiate trait %s", EX_T(opline->op1.var).class_entry->name);
		} else {
			zend_error_noreturn(E_ERROR, "Cannot instantiate abstract class %s", EX_T(opline->op1.var).class_entry->name);
		}
	}
	ALLOC_ZVAL(object_zval);
	object_init_ex(object_zval, EX_T(opline->op1.var).class_entry);
	INIT_PZVAL(object_zval);

	constructor = Z_OBJ_HT_P(object_zval)->get_constructor(object_zval TSRMLS_CC);

	if (constructor == NULL) {
		if (RETURN_VALUE_USED(opline)) {
			AI_SET_PTR(&EX_T(opline->result.var), object_zval);
		} else {
			zval_ptr_dtor(&object_zval);
		}
		ZEND_VM_JMP(EX(op_array)->opcodes + opline->op2.opline_num);
	} else {
		call_slot *call = EX(call_slots) + opline->extended_value;

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(object_zval);
			AI_SET_PTR(&EX_T(opline->result.var), object_zval);
		}

		/* We are not handling overloaded classes right now */
		call->fbc = constructor;
		call->object = object_zval;
		call->called_scope = EX_T(opline->op1.var).class_entry;
		call->num_additional_args = 0;
		call->is_ctor_call = 1;
		call->is_ctor_result_used = RETURN_VALUE_USED(opline);
		EX(call) = call;

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_BEGIN_SILENCE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	Z_LVAL(EX_T(opline->result.var).tmp_var) = EG(error_reporting);
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_LONG;  /* shouldn't be necessary */
	if (EX(old_error_reporting) == NULL) {
		EX(old_error_reporting) = &EX_T(opline->result.var).tmp_var;
	}

	if (EG(error_reporting)) {
		do {
			EG(error_reporting) = 0;
			if (!EG(error_reporting_ini_entry)) {
				if (UNEXPECTED(zend_hash_find(EG(ini_directives), "error_reporting", sizeof("error_reporting"), (void **) &EG(error_reporting_ini_entry)) == FAILURE)) {
					break;
				}
			}
			if (!EG(error_reporting_ini_entry)->modified) {
				if (!EG(modified_ini_directives)) {
					ALLOC_HASHTABLE(EG(modified_ini_directives));
					zend_hash_init(EG(modified_ini_directives), 8, NULL, NULL, 0);
				}
				if (EXPECTED(zend_hash_add(EG(modified_ini_directives), "error_reporting", sizeof("error_reporting"), &EG(error_reporting_ini_entry), sizeof(zend_ini_entry*), NULL) == SUCCESS)) {
					EG(error_reporting_ini_entry)->orig_value = EG(error_reporting_ini_entry)->value;
					EG(error_reporting_ini_entry)->orig_value_length = EG(error_reporting_ini_entry)->value_length;
					EG(error_reporting_ini_entry)->orig_modifiable = EG(error_reporting_ini_entry)->modifiable;
					EG(error_reporting_ini_entry)->modified = 1;
				}
			} else if (EG(error_reporting_ini_entry)->value != EG(error_reporting_ini_entry)->orig_value) {
				efree(EG(error_reporting_ini_entry)->value);
			}
			EG(error_reporting_ini_entry)->value = estrndup("0", sizeof("0")-1);
			EG(error_reporting_ini_entry)->value_length = sizeof("0")-1;
		} while (0);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	SAVE_OPLINE();
	zend_error_noreturn(E_ERROR, "Cannot call abstract method %s::%s()", EG(scope)->name, EX(op_array)->function_name);
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

static int ZEND_FASTCALL  ZEND_EXT_STMT_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	SAVE_OPLINE();
	if (!EG(no_extensions)) {
		zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_statement_handler, EX(op_array) TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	SAVE_OPLINE();
	if (!EG(no_extensions)) {
		zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_fcall_begin_handler, EX(op_array) TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_EXT_FCALL_END_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	SAVE_OPLINE();
	if (!EG(no_extensions)) {
		zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_fcall_end_handler, EX(op_array) TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DECLARE_CLASS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	EX_T(opline->result.var).class_entry = do_bind_class(EX(op_array), opline, EG(class_table), 0 TSRMLS_CC);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	EX_T(opline->result.var).class_entry = do_bind_inherited_class(EX(op_array), opline, EG(class_table), EX_T(opline->extended_value).class_entry, 0 TSRMLS_CC);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_class_entry **pce, **pce_orig;

	SAVE_OPLINE();
	if (zend_hash_quick_find(EG(class_table), Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv)+1, Z_HASH_P(opline->op2.zv), (void**)&pce) == FAILURE ||
	    (zend_hash_quick_find(EG(class_table), Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), Z_HASH_P(opline->op1.zv), (void**)&pce_orig) == SUCCESS &&
	     *pce != *pce_orig)) {
		do_bind_inherited_class(EX(op_array), opline, EG(class_table), EX_T(opline->extended_value).class_entry, 0 TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DECLARE_FUNCTION_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	do_bind_function(EX(op_array), opline, EG(function_table), 0);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_TICKS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (++EG(ticks_count)>=opline->extended_value) {
		EG(ticks_count)=0;
		if (zend_ticks_function) {
			zend_ticks_function(opline->extended_value);
		}
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_EXT_NOP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_NOP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_TRAIT_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_class_entry *ce = EX_T(opline->op1.var).class_entry;
	zend_class_entry *trait;

	SAVE_OPLINE();
	if (CACHED_PTR(opline->op2.literal->cache_slot)) {
		trait = CACHED_PTR(opline->op2.literal->cache_slot);
	} else {
		trait = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv),
		                                 Z_STRLEN_P(opline->op2.zv),
		                                 opline->op2.literal + 1,
		                                 opline->extended_value TSRMLS_CC);
		if (UNEXPECTED(trait == NULL)) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
		if (!((trait->ce_flags & ZEND_ACC_TRAIT) == ZEND_ACC_TRAIT)) {
			zend_error_noreturn(E_ERROR, "%s cannot use %s - it is not a trait", ce->name, trait->name);
		}
		CACHE_PTR(opline->op2.literal->cache_slot, trait);
	}

	zend_do_implement_trait(ce, trait TSRMLS_CC);

 	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BIND_TRAITS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_class_entry *ce = EX_T(opline->op1.var).class_entry;

	SAVE_OPLINE();
	zend_do_bind_traits(ce TSRMLS_CC);
 	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_HANDLE_EXCEPTION_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_uint op_num = EG(opline_before_exception)-EG(active_op_array)->opcodes;
	int i;
	zend_uint catch_op_num = 0, finally_op_num = 0, finally_op_end = 0;
	void **stack_frame;

	/* Figure out where the next stack frame (which maybe contains pushed
	 * arguments that have to be dtor'ed) starts */
	stack_frame = zend_vm_stack_frame_base(execute_data);

	/* If the exception was thrown during a function call there might be
	 * arguments pushed to the stack that have to be dtor'ed. */
	while (zend_vm_stack_top(TSRMLS_C) != stack_frame) {
		zval *stack_zval_p = zend_vm_stack_pop(TSRMLS_C);
		zval_ptr_dtor(&stack_zval_p);
	}

	for (i=0; i<EG(active_op_array)->last_try_catch; i++) {
		if (EG(active_op_array)->try_catch_array[i].try_op > op_num) {
			/* further blocks will not be relevant... */
			break;
		}
		if (op_num < EG(active_op_array)->try_catch_array[i].catch_op) {
			catch_op_num = EX(op_array)->try_catch_array[i].catch_op;
		}
		if (op_num < EG(active_op_array)->try_catch_array[i].finally_op) {
			finally_op_num = EX(op_array)->try_catch_array[i].finally_op;
		}
		if (op_num >= EG(active_op_array)->try_catch_array[i].finally_op &&
				op_num < EG(active_op_array)->try_catch_array[i].finally_end) {
			finally_op_end = EG(active_op_array)->try_catch_array[i].finally_end;
		}
	}

	if (EX(call) >= EX(call_slots)) {
		call_slot *call = EX(call);
		do {
			if (call->object) {
				if (call->is_ctor_call) {
					if (call->is_ctor_result_used) {
						Z_DELREF_P(call->object);
					}
					if (Z_REFCOUNT_P(call->object) == 1) {
						zend_object_store_ctor_failed(call->object TSRMLS_CC);
					}
				}
				zval_ptr_dtor(&call->object);
			}
			if (call->fbc->common.fn_flags & ZEND_ACC_CALL_VIA_HANDLER) {
				efree((char *) call->fbc->common.function_name);
				efree(call->fbc);
			}
			call--;
		} while (call >= EX(call_slots));
		EX(call) = NULL;
	}

	for (i=0; i<EX(op_array)->last_brk_cont; i++) {
		if (EX(op_array)->brk_cont_array[i].start < 0) {
			continue;
		} else if (EX(op_array)->brk_cont_array[i].start > op_num) {
			/* further blocks will not be relevant... */
			break;
		} else if (op_num < EX(op_array)->brk_cont_array[i].brk) {
			if (!catch_op_num ||
			    catch_op_num >= EX(op_array)->brk_cont_array[i].brk) {
				zend_op *brk_opline = &EX(op_array)->opcodes[EX(op_array)->brk_cont_array[i].brk];

				switch (brk_opline->opcode) {
					case ZEND_SWITCH_FREE:
						if (!(brk_opline->extended_value & EXT_TYPE_FREE_ON_RETURN)) {
							zval_ptr_dtor(&EX_T(brk_opline->op1.var).var.ptr);
						}
						break;
					case ZEND_FREE:
						if (!(brk_opline->extended_value & EXT_TYPE_FREE_ON_RETURN)) {
							zendi_zval_dtor(EX_T(brk_opline->op1.var).tmp_var);
						}
						break;
				}
			}
		}
	}

	/* restore previous error_reporting value */
	if (!EG(error_reporting) && EX(old_error_reporting) != NULL && Z_LVAL_P(EX(old_error_reporting)) != 0) {
		zval restored_error_reporting;

		Z_TYPE(restored_error_reporting) = IS_LONG;
		Z_LVAL(restored_error_reporting) = Z_LVAL_P(EX(old_error_reporting));
		convert_to_string(&restored_error_reporting);
		zend_alter_ini_entry_ex("error_reporting", sizeof("error_reporting"), Z_STRVAL(restored_error_reporting), Z_STRLEN(restored_error_reporting), ZEND_INI_USER, ZEND_INI_STAGE_RUNTIME, 1 TSRMLS_CC);
		zendi_zval_dtor(restored_error_reporting);
	}
	EX(old_error_reporting) = NULL;

	if (finally_op_num && (!catch_op_num || catch_op_num >= finally_op_num)) {
		if (EX(delayed_exception)) {
			zend_exception_set_previous(EG(exception), EX(delayed_exception) TSRMLS_CC);
		}
		EX(delayed_exception) = EG(exception);
		EG(exception) = NULL;
		EX(fast_ret) = NULL;
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[finally_op_num]);
		ZEND_VM_CONTINUE();
	} else if (catch_op_num) {
		if (finally_op_end && catch_op_num > finally_op_end) {
			/* we are going out of current finally scope */
			if (EX(delayed_exception)) {
				zend_exception_set_previous(EG(exception), EX(delayed_exception) TSRMLS_CC);
				EX(delayed_exception) = NULL;
			}
		}
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[catch_op_num]);
		ZEND_VM_CONTINUE();
	} else {
		if (EX(delayed_exception)) {
			zend_exception_set_previous(EG(exception), EX(delayed_exception) TSRMLS_CC);
			EX(delayed_exception) = NULL;
		}
		if (UNEXPECTED((EX(op_array)->fn_flags & ZEND_ACC_GENERATOR) != 0)) {
			return ZEND_GENERATOR_RETURN_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		} else {
			return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	}
}

static int ZEND_FASTCALL  ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	zend_verify_abstract_class(EX_T(opline->op1.var).class_entry TSRMLS_CC);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_USER_OPCODE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	int ret;

	SAVE_OPLINE();
	ret = zend_user_opcode_handlers[opline->opcode](ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_INTERNAL);
	LOAD_OPLINE();

	switch (ret) {
		case ZEND_USER_OPCODE_CONTINUE:
			ZEND_VM_CONTINUE();
		case ZEND_USER_OPCODE_RETURN:
			if (UNEXPECTED((EX(op_array)->fn_flags & ZEND_ACC_GENERATOR) != 0)) {
				return ZEND_GENERATOR_RETURN_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			} else {
				return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			}
		case ZEND_USER_OPCODE_ENTER:
			ZEND_VM_ENTER();
		case ZEND_USER_OPCODE_LEAVE:
			ZEND_VM_LEAVE();
		case ZEND_USER_OPCODE_DISPATCH:
			ZEND_VM_DISPATCH(opline->opcode, opline);
		default:
			ZEND_VM_DISPATCH((zend_uchar)(ret & 0xff), opline);
	}
}

static int ZEND_FASTCALL  ZEND_DISCARD_EXCEPTION_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	if (EX(delayed_exception) != NULL) {
		/* discard the previously thrown exception */
		zval_ptr_dtor(&EX(delayed_exception));
		EX(delayed_exception) = NULL;
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FAST_CALL_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if ((opline->extended_value & ZEND_FAST_CALL_FROM_CATCH) &&
	    UNEXPECTED(EG(prev_exception) != NULL)) {
	    /* in case of unhandled exception jump to catch block instead of finally */
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE();
	}
	if (UNEXPECTED(EX(delayed_exception) != NULL)) {
		EX(fast_ret) = NULL;
	} else {
		EX(fast_ret) = opline;
	}
	ZEND_VM_SET_OPCODE(opline->op1.jmp_addr);
	ZEND_VM_CONTINUE();
}

static int ZEND_FASTCALL  ZEND_FAST_RET_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	if (EX(fast_ret)) {
		ZEND_VM_SET_OPCODE(EX(fast_ret) + 1);
		if ((EX(fast_ret)->extended_value & ZEND_FAST_CALL_FROM_FINALLY)) {
			EX(fast_ret) = &EX(op_array)->opcodes[EX(fast_ret)->op2.opline_num];
		}
		ZEND_VM_CONTINUE();
	} else {
		/* special case for unhandled exceptions */
		USE_OPLINE

		if (opline->extended_value == ZEND_FAST_RET_TO_FINALLY) {
			ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
			ZEND_VM_CONTINUE();
		} else {
			EG(exception) = EX(delayed_exception);
			EX(delayed_exception) = NULL;
			if (opline->extended_value == ZEND_FAST_RET_TO_CATCH) {
				ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
				ZEND_VM_CONTINUE();
			} else if (UNEXPECTED((EX(op_array)->fn_flags & ZEND_ACC_GENERATOR) != 0)) {
				return ZEND_GENERATOR_RETURN_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			} else {
				return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			}
		}
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_CLASS_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_CONST == IS_UNUSED) {
		EX_T(opline->result.var).class_entry = zend_fetch_class(NULL, 0, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {

		zval *class_name = opline->op2.zv;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				EX_T(opline->result.var).class_entry = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				EX_T(opline->result.var).class_entry = zend_fetch_class_by_name(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->op2.literal + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(opline->op2.literal->cache_slot, EX_T(opline->result.var).class_entry);
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			EX_T(opline->result.var).class_entry = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			EX_T(opline->result.var).class_entry = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	call_slot *call = EX(call_slots) + opline->result.num;

	if (IS_CONST == IS_CONST) {
		function_name = (zval*)(opline->op2.literal+1);
		if (CACHED_PTR(opline->op2.literal->cache_slot)) {
			call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
		} else if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL_P(function_name), Z_STRLEN_P(function_name)+1, Z_HASH_P(function_name), (void **) &call->fbc) == FAILURE)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
		}

		call->object = NULL;
		call->called_scope = NULL;
		call->num_additional_args = 0;
		call->is_ctor_call = 0;
		EX(call) = call;

		/*CHECK_EXCEPTION();*/
		ZEND_VM_NEXT_OPCODE();
	} else {
		char *function_name_strval, *lcname;
		int function_name_strlen;


		SAVE_OPLINE();
		function_name = opline->op2.zv;

		if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
			function_name_strval = Z_STRVAL_P(function_name);
			function_name_strlen = Z_STRLEN_P(function_name);
			if (function_name_strval[0] == '\\') {
			    function_name_strlen -= 1;
				lcname = zend_str_tolower_dup(function_name_strval + 1, function_name_strlen);
			} else {
				lcname = zend_str_tolower_dup(function_name_strval, function_name_strlen);
			}
			if (UNEXPECTED(zend_hash_find(EG(function_table), lcname, function_name_strlen+1, (void **) &call->fbc) == FAILURE)) {
				zend_error_noreturn(E_ERROR, "Call to undefined function %s()", function_name_strval);
			}
			efree(lcname);

			call->object = NULL;
			call->called_scope = NULL;
			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_CONST != IS_CONST && IS_CONST != IS_TMP_VAR &&
		    EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT) &&
			Z_OBJ_HANDLER_P(function_name, get_closure) &&
			Z_OBJ_HANDLER_P(function_name, get_closure)(function_name, &call->called_scope, &call->fbc, &call->object TSRMLS_CC) == SUCCESS) {
			if (call->object) {
				Z_ADDREF_P(call->object);
			}
			if (IS_CONST == IS_VAR && 0 && Z_REFCOUNT_P(function_name) == 1 &&
			    call->fbc->common.fn_flags & ZEND_ACC_CLOSURE) {
				/* Delay closure destruction until its invocation */
				call->fbc->common.prototype = (zend_function*)function_name;
			} else {

			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_CONST != IS_CONST &&
				EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY) &&
				zend_hash_num_elements(Z_ARRVAL_P(function_name)) == 2) {
			zend_class_entry *ce;
			zval **method = NULL;
			zval **obj = NULL;

			zend_hash_index_find(Z_ARRVAL_P(function_name), 0, (void **) &obj);
			zend_hash_index_find(Z_ARRVAL_P(function_name), 1, (void **) &method);

			if (!obj || !method) {
				zend_error_noreturn(E_ERROR, "Array callback has to contain indices 0 and 1");
			}

			if (Z_TYPE_PP(obj) != IS_STRING && Z_TYPE_PP(obj) != IS_OBJECT) {
				zend_error_noreturn(E_ERROR, "First array member is not a valid class name or object");
			}

			if (Z_TYPE_PP(method) != IS_STRING) {
				zend_error_noreturn(E_ERROR, "Second array member is not a valid method");
			}

			if (Z_TYPE_PP(obj) == IS_STRING) {
				ce = zend_fetch_class_by_name(Z_STRVAL_PP(obj), Z_STRLEN_PP(obj), NULL, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				call->called_scope = ce;
				call->object = NULL;

				if (ce->get_static_method) {
					call->fbc = ce->get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method) TSRMLS_CC);
				} else {
					call->fbc = zend_std_get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				}
			} else {
				call->object = *obj;
				ce = call->called_scope = Z_OBJCE_PP(obj);

				call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_PP(method));
				}

				if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
					call->object = NULL;
				} else {
					if (!PZVAL_IS_REF(call->object)) {
						Z_ADDREF_P(call->object); /* For $this pointer */
					} else {
						zval *this_ptr;
						ALLOC_ZVAL(this_ptr);
						INIT_PZVAL_COPY(this_ptr, call->object);
						zval_copy_ctor(this_ptr);
						call->object = this_ptr;
					}
				}
			}

			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, Z_STRVAL_PP(method));
			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Function name must be a string");
			ZEND_VM_NEXT_OPCODE(); /* Never reached */
		}
	}
}


static int ZEND_FASTCALL  ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_literal *func_name;
	call_slot *call = EX(call_slots) + opline->result.num;

	func_name = opline->op2.literal + 1;
	if (CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (zend_hash_quick_find(EG(function_table), Z_STRVAL(func_name->constant), Z_STRLEN(func_name->constant)+1, func_name->hash_value, (void **) &call->fbc)==FAILURE) {
		func_name++;
		if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL(func_name->constant), Z_STRLEN(func_name->constant)+1, func_name->hash_value, (void **) &call->fbc)==FAILURE)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
		}
	} else {
		CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
	}

	call->object = NULL;
	call->called_scope = NULL;
	call->num_additional_args = 0;
	call->is_ctor_call = 0;

	EX(call) = call;
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_RECV_INIT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *assignment_value;
	zend_uint arg_num = opline->op1.num;
	zval **param = zend_vm_stack_get_arg(arg_num TSRMLS_CC);
	zval **var_ptr;

	SAVE_OPLINE();
	if (param == NULL) {
		ALLOC_ZVAL(assignment_value);
		*assignment_value = *opline->op2.zv;
		if (IS_CONSTANT_TYPE(Z_TYPE_P(assignment_value))) {
			Z_SET_REFCOUNT_P(assignment_value, 1);
			zval_update_constant(&assignment_value, 0 TSRMLS_CC);
		} else if (Z_TYPE_P(assignment_value) == IS_ARRAY) {
			HashTable *ht;

			ALLOC_HASHTABLE(ht);
			zend_hash_init(ht, zend_hash_num_elements(Z_ARRVAL_P(assignment_value)), NULL, ZVAL_PTR_DTOR, 0);
			zend_hash_copy(ht, Z_ARRVAL_P(assignment_value), (copy_ctor_func_t) zval_deep_copy, NULL, sizeof(zval *));
			Z_ARRVAL_P(assignment_value) = ht;
		} else {
			zval_copy_ctor(assignment_value);
		}
		INIT_PZVAL(assignment_value);
	} else {
		assignment_value = *param;
		Z_ADDREF_P(assignment_value);
	}

	zend_verify_arg_type((zend_function *) EG(active_op_array), arg_num, assignment_value, opline->extended_value, opline->op2.zv TSRMLS_CC);
	var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->result.var TSRMLS_CC);
	zval_ptr_dtor(var_ptr);
	*var_ptr = assignment_value;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BRK_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_brk_cont_element *el;

	SAVE_OPLINE();
	el = zend_brk_cont(Z_LVAL_P(opline->op2.zv), opline->op1.opline_num,
	                   EX(op_array), execute_data TSRMLS_CC);
	ZEND_VM_JMP(EX(op_array)->opcodes + el->brk);
}

static int ZEND_FASTCALL  ZEND_CONT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_brk_cont_element *el;

	SAVE_OPLINE();
	el = zend_brk_cont(Z_LVAL_P(opline->op2.zv), opline->op1.opline_num,
	                   EX(op_array), execute_data TSRMLS_CC);
	ZEND_VM_JMP(EX(op_array)->opcodes + el->cont);
}

static int ZEND_FASTCALL  ZEND_GOTO_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *brk_opline;
	USE_OPLINE
	zend_brk_cont_element *el;

	SAVE_OPLINE();
	el = zend_brk_cont(Z_LVAL_P(opline->op2.zv), opline->extended_value,
 	                   EX(op_array), execute_data TSRMLS_CC);

	brk_opline = EX(op_array)->opcodes + el->brk;

	switch (brk_opline->opcode) {
		case ZEND_SWITCH_FREE:
			if (!(brk_opline->extended_value & EXT_TYPE_FREE_ON_RETURN)) {
				zval_ptr_dtor(&EX_T(brk_opline->op1.var).var.ptr);
			}
			break;
		case ZEND_FREE:
			if (!(brk_opline->extended_value & EXT_TYPE_FREE_ON_RETURN)) {
				zendi_zval_dtor(EX_T(brk_opline->op1.var).tmp_var);
			}
			break;
	}
	ZEND_VM_JMP(opline->op1.jmp_addr);
}

static int ZEND_FASTCALL  ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_class_entry *ce = EX_T(opline->op1.var).class_entry;
	zend_class_entry *iface;

	SAVE_OPLINE();
	if (CACHED_PTR(opline->op2.literal->cache_slot)) {
		iface = CACHED_PTR(opline->op2.literal->cache_slot);
	} else {
		iface = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, opline->extended_value TSRMLS_CC);
		if (UNEXPECTED(iface == NULL)) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
		CACHE_PTR(opline->op2.literal->cache_slot, iface);
	}

	if (UNEXPECTED((iface->ce_flags & ZEND_ACC_INTERFACE) == 0)) {
		zend_error_noreturn(E_ERROR, "%s cannot implement %s - it is not an interface", ce->name, iface->name);
	}
	zend_do_implement_interface(ce, iface TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_CLASS_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_TMP_VAR == IS_UNUSED) {
		EX_T(opline->result.var).class_entry = zend_fetch_class(NULL, 0, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_op2;
		zval *class_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (IS_TMP_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				EX_T(opline->result.var).class_entry = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				EX_T(opline->result.var).class_entry = zend_fetch_class_by_name(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->op2.literal + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(opline->op2.literal->cache_slot, EX_T(opline->result.var).class_entry);
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			EX_T(opline->result.var).class_entry = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			EX_T(opline->result.var).class_entry = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		zval_dtor(free_op2.var);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	call_slot *call = EX(call_slots) + opline->result.num;

	if (IS_TMP_VAR == IS_CONST) {
		function_name = (zval*)(opline->op2.literal+1);
		if (CACHED_PTR(opline->op2.literal->cache_slot)) {
			call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
		} else if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL_P(function_name), Z_STRLEN_P(function_name)+1, Z_HASH_P(function_name), (void **) &call->fbc) == FAILURE)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
		}

		call->object = NULL;
		call->called_scope = NULL;
		call->num_additional_args = 0;
		call->is_ctor_call = 0;
		EX(call) = call;

		/*CHECK_EXCEPTION();*/
		ZEND_VM_NEXT_OPCODE();
	} else {
		char *function_name_strval, *lcname;
		int function_name_strlen;
		zend_free_op free_op2;

		SAVE_OPLINE();
		function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
			function_name_strval = Z_STRVAL_P(function_name);
			function_name_strlen = Z_STRLEN_P(function_name);
			if (function_name_strval[0] == '\\') {
			    function_name_strlen -= 1;
				lcname = zend_str_tolower_dup(function_name_strval + 1, function_name_strlen);
			} else {
				lcname = zend_str_tolower_dup(function_name_strval, function_name_strlen);
			}
			if (UNEXPECTED(zend_hash_find(EG(function_table), lcname, function_name_strlen+1, (void **) &call->fbc) == FAILURE)) {
				zend_error_noreturn(E_ERROR, "Call to undefined function %s()", function_name_strval);
			}
			efree(lcname);
			zval_dtor(free_op2.var);

			call->object = NULL;
			call->called_scope = NULL;
			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_TMP_VAR != IS_CONST && IS_TMP_VAR != IS_TMP_VAR &&
		    EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT) &&
			Z_OBJ_HANDLER_P(function_name, get_closure) &&
			Z_OBJ_HANDLER_P(function_name, get_closure)(function_name, &call->called_scope, &call->fbc, &call->object TSRMLS_CC) == SUCCESS) {
			if (call->object) {
				Z_ADDREF_P(call->object);
			}
			if (IS_TMP_VAR == IS_VAR && 1 && Z_REFCOUNT_P(function_name) == 1 &&
			    call->fbc->common.fn_flags & ZEND_ACC_CLOSURE) {
				/* Delay closure destruction until its invocation */
				call->fbc->common.prototype = (zend_function*)function_name;
			} else {
				zval_dtor(free_op2.var);
			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_TMP_VAR != IS_CONST &&
				EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY) &&
				zend_hash_num_elements(Z_ARRVAL_P(function_name)) == 2) {
			zend_class_entry *ce;
			zval **method = NULL;
			zval **obj = NULL;

			zend_hash_index_find(Z_ARRVAL_P(function_name), 0, (void **) &obj);
			zend_hash_index_find(Z_ARRVAL_P(function_name), 1, (void **) &method);

			if (!obj || !method) {
				zend_error_noreturn(E_ERROR, "Array callback has to contain indices 0 and 1");
			}

			if (Z_TYPE_PP(obj) != IS_STRING && Z_TYPE_PP(obj) != IS_OBJECT) {
				zend_error_noreturn(E_ERROR, "First array member is not a valid class name or object");
			}

			if (Z_TYPE_PP(method) != IS_STRING) {
				zend_error_noreturn(E_ERROR, "Second array member is not a valid method");
			}

			if (Z_TYPE_PP(obj) == IS_STRING) {
				ce = zend_fetch_class_by_name(Z_STRVAL_PP(obj), Z_STRLEN_PP(obj), NULL, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				call->called_scope = ce;
				call->object = NULL;

				if (ce->get_static_method) {
					call->fbc = ce->get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method) TSRMLS_CC);
				} else {
					call->fbc = zend_std_get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				}
			} else {
				call->object = *obj;
				ce = call->called_scope = Z_OBJCE_PP(obj);

				call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_PP(method));
				}

				if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
					call->object = NULL;
				} else {
					if (!PZVAL_IS_REF(call->object)) {
						Z_ADDREF_P(call->object); /* For $this pointer */
					} else {
						zval *this_ptr;
						ALLOC_ZVAL(this_ptr);
						INIT_PZVAL_COPY(this_ptr, call->object);
						zval_copy_ctor(this_ptr);
						call->object = this_ptr;
					}
				}
			}

			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, Z_STRVAL_PP(method));
			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			zval_dtor(free_op2.var);
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Function name must be a string");
			ZEND_VM_NEXT_OPCODE(); /* Never reached */
		}
	}
}


static int ZEND_FASTCALL  ZEND_FETCH_CLASS_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_VAR == IS_UNUSED) {
		EX_T(opline->result.var).class_entry = zend_fetch_class(NULL, 0, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_op2;
		zval *class_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				EX_T(opline->result.var).class_entry = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				EX_T(opline->result.var).class_entry = zend_fetch_class_by_name(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->op2.literal + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(opline->op2.literal->cache_slot, EX_T(opline->result.var).class_entry);
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			EX_T(opline->result.var).class_entry = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			EX_T(opline->result.var).class_entry = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		zval_ptr_dtor_nogc(&free_op2.var);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	call_slot *call = EX(call_slots) + opline->result.num;

	if (IS_VAR == IS_CONST) {
		function_name = (zval*)(opline->op2.literal+1);
		if (CACHED_PTR(opline->op2.literal->cache_slot)) {
			call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
		} else if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL_P(function_name), Z_STRLEN_P(function_name)+1, Z_HASH_P(function_name), (void **) &call->fbc) == FAILURE)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
		}

		call->object = NULL;
		call->called_scope = NULL;
		call->num_additional_args = 0;
		call->is_ctor_call = 0;
		EX(call) = call;

		/*CHECK_EXCEPTION();*/
		ZEND_VM_NEXT_OPCODE();
	} else {
		char *function_name_strval, *lcname;
		int function_name_strlen;
		zend_free_op free_op2;

		SAVE_OPLINE();
		function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
			function_name_strval = Z_STRVAL_P(function_name);
			function_name_strlen = Z_STRLEN_P(function_name);
			if (function_name_strval[0] == '\\') {
			    function_name_strlen -= 1;
				lcname = zend_str_tolower_dup(function_name_strval + 1, function_name_strlen);
			} else {
				lcname = zend_str_tolower_dup(function_name_strval, function_name_strlen);
			}
			if (UNEXPECTED(zend_hash_find(EG(function_table), lcname, function_name_strlen+1, (void **) &call->fbc) == FAILURE)) {
				zend_error_noreturn(E_ERROR, "Call to undefined function %s()", function_name_strval);
			}
			efree(lcname);
			zval_ptr_dtor_nogc(&free_op2.var);

			call->object = NULL;
			call->called_scope = NULL;
			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_VAR != IS_CONST && IS_VAR != IS_TMP_VAR &&
		    EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT) &&
			Z_OBJ_HANDLER_P(function_name, get_closure) &&
			Z_OBJ_HANDLER_P(function_name, get_closure)(function_name, &call->called_scope, &call->fbc, &call->object TSRMLS_CC) == SUCCESS) {
			if (call->object) {
				Z_ADDREF_P(call->object);
			}
			if (IS_VAR == IS_VAR && (free_op2.var != NULL) && Z_REFCOUNT_P(function_name) == 1 &&
			    call->fbc->common.fn_flags & ZEND_ACC_CLOSURE) {
				/* Delay closure destruction until its invocation */
				call->fbc->common.prototype = (zend_function*)function_name;
			} else {
				zval_ptr_dtor_nogc(&free_op2.var);
			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_VAR != IS_CONST &&
				EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY) &&
				zend_hash_num_elements(Z_ARRVAL_P(function_name)) == 2) {
			zend_class_entry *ce;
			zval **method = NULL;
			zval **obj = NULL;

			zend_hash_index_find(Z_ARRVAL_P(function_name), 0, (void **) &obj);
			zend_hash_index_find(Z_ARRVAL_P(function_name), 1, (void **) &method);

			if (!obj || !method) {
				zend_error_noreturn(E_ERROR, "Array callback has to contain indices 0 and 1");
			}

			if (Z_TYPE_PP(obj) != IS_STRING && Z_TYPE_PP(obj) != IS_OBJECT) {
				zend_error_noreturn(E_ERROR, "First array member is not a valid class name or object");
			}

			if (Z_TYPE_PP(method) != IS_STRING) {
				zend_error_noreturn(E_ERROR, "Second array member is not a valid method");
			}

			if (Z_TYPE_PP(obj) == IS_STRING) {
				ce = zend_fetch_class_by_name(Z_STRVAL_PP(obj), Z_STRLEN_PP(obj), NULL, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				call->called_scope = ce;
				call->object = NULL;

				if (ce->get_static_method) {
					call->fbc = ce->get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method) TSRMLS_CC);
				} else {
					call->fbc = zend_std_get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				}
			} else {
				call->object = *obj;
				ce = call->called_scope = Z_OBJCE_PP(obj);

				call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_PP(method));
				}

				if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
					call->object = NULL;
				} else {
					if (!PZVAL_IS_REF(call->object)) {
						Z_ADDREF_P(call->object); /* For $this pointer */
					} else {
						zval *this_ptr;
						ALLOC_ZVAL(this_ptr);
						INIT_PZVAL_COPY(this_ptr, call->object);
						zval_copy_ctor(this_ptr);
						call->object = this_ptr;
					}
				}
			}

			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, Z_STRVAL_PP(method));
			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			zval_ptr_dtor_nogc(&free_op2.var);
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Function name must be a string");
			ZEND_VM_NEXT_OPCODE(); /* Never reached */
		}
	}
}


static int ZEND_FASTCALL  ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_UNUSED == IS_UNUSED) {
		EX_T(opline->result.var).class_entry = zend_fetch_class(NULL, 0, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {

		zval *class_name = NULL;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				EX_T(opline->result.var).class_entry = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				EX_T(opline->result.var).class_entry = zend_fetch_class_by_name(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->op2.literal + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(opline->op2.literal->cache_slot, EX_T(opline->result.var).class_entry);
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			EX_T(opline->result.var).class_entry = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			EX_T(opline->result.var).class_entry = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_CLASS_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_CV == IS_UNUSED) {
		EX_T(opline->result.var).class_entry = zend_fetch_class(NULL, 0, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {

		zval *class_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		if (IS_CV == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				EX_T(opline->result.var).class_entry = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				EX_T(opline->result.var).class_entry = zend_fetch_class_by_name(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->op2.literal + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(opline->op2.literal->cache_slot, EX_T(opline->result.var).class_entry);
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			EX_T(opline->result.var).class_entry = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			EX_T(opline->result.var).class_entry = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	call_slot *call = EX(call_slots) + opline->result.num;

	if (IS_CV == IS_CONST) {
		function_name = (zval*)(opline->op2.literal+1);
		if (CACHED_PTR(opline->op2.literal->cache_slot)) {
			call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
		} else if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL_P(function_name), Z_STRLEN_P(function_name)+1, Z_HASH_P(function_name), (void **) &call->fbc) == FAILURE)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
		}

		call->object = NULL;
		call->called_scope = NULL;
		call->num_additional_args = 0;
		call->is_ctor_call = 0;
		EX(call) = call;

		/*CHECK_EXCEPTION();*/
		ZEND_VM_NEXT_OPCODE();
	} else {
		char *function_name_strval, *lcname;
		int function_name_strlen;


		SAVE_OPLINE();
		function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
			function_name_strval = Z_STRVAL_P(function_name);
			function_name_strlen = Z_STRLEN_P(function_name);
			if (function_name_strval[0] == '\\') {
			    function_name_strlen -= 1;
				lcname = zend_str_tolower_dup(function_name_strval + 1, function_name_strlen);
			} else {
				lcname = zend_str_tolower_dup(function_name_strval, function_name_strlen);
			}
			if (UNEXPECTED(zend_hash_find(EG(function_table), lcname, function_name_strlen+1, (void **) &call->fbc) == FAILURE)) {
				zend_error_noreturn(E_ERROR, "Call to undefined function %s()", function_name_strval);
			}
			efree(lcname);

			call->object = NULL;
			call->called_scope = NULL;
			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_CV != IS_CONST && IS_CV != IS_TMP_VAR &&
		    EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT) &&
			Z_OBJ_HANDLER_P(function_name, get_closure) &&
			Z_OBJ_HANDLER_P(function_name, get_closure)(function_name, &call->called_scope, &call->fbc, &call->object TSRMLS_CC) == SUCCESS) {
			if (call->object) {
				Z_ADDREF_P(call->object);
			}
			if (IS_CV == IS_VAR && 0 && Z_REFCOUNT_P(function_name) == 1 &&
			    call->fbc->common.fn_flags & ZEND_ACC_CLOSURE) {
				/* Delay closure destruction until its invocation */
				call->fbc->common.prototype = (zend_function*)function_name;
			} else {

			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_CV != IS_CONST &&
				EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY) &&
				zend_hash_num_elements(Z_ARRVAL_P(function_name)) == 2) {
			zend_class_entry *ce;
			zval **method = NULL;
			zval **obj = NULL;

			zend_hash_index_find(Z_ARRVAL_P(function_name), 0, (void **) &obj);
			zend_hash_index_find(Z_ARRVAL_P(function_name), 1, (void **) &method);

			if (!obj || !method) {
				zend_error_noreturn(E_ERROR, "Array callback has to contain indices 0 and 1");
			}

			if (Z_TYPE_PP(obj) != IS_STRING && Z_TYPE_PP(obj) != IS_OBJECT) {
				zend_error_noreturn(E_ERROR, "First array member is not a valid class name or object");
			}

			if (Z_TYPE_PP(method) != IS_STRING) {
				zend_error_noreturn(E_ERROR, "Second array member is not a valid method");
			}

			if (Z_TYPE_PP(obj) == IS_STRING) {
				ce = zend_fetch_class_by_name(Z_STRVAL_PP(obj), Z_STRLEN_PP(obj), NULL, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				call->called_scope = ce;
				call->object = NULL;

				if (ce->get_static_method) {
					call->fbc = ce->get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method) TSRMLS_CC);
				} else {
					call->fbc = zend_std_get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				}
			} else {
				call->object = *obj;
				ce = call->called_scope = Z_OBJCE_PP(obj);

				call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_PP(method));
				}

				if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
					call->object = NULL;
				} else {
					if (!PZVAL_IS_REF(call->object)) {
						Z_ADDREF_P(call->object); /* For $this pointer */
					} else {
						zval *this_ptr;
						ALLOC_ZVAL(this_ptr);
						INIT_PZVAL_COPY(this_ptr, call->object);
						zval_copy_ctor(this_ptr);
						call->object = this_ptr;
					}
				}
			}

			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, Z_STRVAL_PP(method));
			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Function name must be a string");
			ZEND_VM_NEXT_OPCODE(); /* Never reached */
		}
	}
}


static int ZEND_FASTCALL  ZEND_BW_NOT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_not_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_NOT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_not_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ECHO_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *z;

	SAVE_OPLINE();
	z = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && Z_TYPE_P(z) == IS_OBJECT) {
		INIT_PZVAL(z);
	}
	zend_print_variable(z);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRINT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZVAL_LONG(&EX_T(opline->result.var).tmp_var, 1);
	return ZEND_ECHO_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_JMPZ_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int ret;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (!ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int ret;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPZNZ_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (EXPECTED(retval != 0)) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on true to %d\n", opline->extended_value);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	} else {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on false to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
}

static int ZEND_FASTCALL  ZEND_JMPZ_EX_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (!retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_EX_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DO_FCALL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *fname = opline->op1.zv;
	call_slot *call = EX(call_slots) + opline->op2.num;

	if (CACHED_PTR(opline->op1.literal->cache_slot)) {
		EX(function_state).function = CACHED_PTR(opline->op1.literal->cache_slot);
	} else if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL_P(fname), Z_STRLEN_P(fname)+1, Z_HASH_P(fname), (void **) &EX(function_state).function)==FAILURE)) {
	    SAVE_OPLINE();
		zend_error_noreturn(E_ERROR, "Call to undefined function %s()", fname->value.str.val);
	} else {
		CACHE_PTR(opline->op1.literal->cache_slot, EX(function_state).function);
	}

	call->fbc = EX(function_state).function;
	call->object = NULL;
	call->called_scope = NULL;
	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	return zend_do_fcall_common_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_RETURN_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;


	SAVE_OPLINE();
	retval_ptr = opline->op1.zv;

	if (!EG(return_value_ptr_ptr)) {

	} else {
		if (IS_CONST == IS_CONST ||
		    IS_CONST == IS_TMP_VAR ||
		    PZVAL_IS_REF(retval_ptr)) {
			zval *ret;

			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, retval_ptr);
			if (IS_CONST != IS_TMP_VAR) {
				zval_copy_ctor(ret);
			}
			*EG(return_value_ptr_ptr) = ret;/* 函数的返回值在程序执行时存储在 *EG(return_value_ptr_ptr) */

		} else if ((IS_CONST == IS_CV || IS_CONST == IS_VAR) &&
		           retval_ptr == &EG(uninitialized_zval)) {
			zval *ret;

			if (IS_CONST == IS_VAR) {
				Z_DELREF_P(retval_ptr);
			}
			ALLOC_INIT_ZVAL(ret);
			*EG(return_value_ptr_ptr) = ret;/* 函数的返回值在程序执行时存储在 *EG(return_value_ptr_ptr) */
		} else {
			*EG(return_value_ptr_ptr) = retval_ptr;/* 函数的返回值在程序执行时存储在 *EG(return_value_ptr_ptr) */
			if (IS_CONST == IS_CV) {
				Z_ADDREF_P(retval_ptr);
			}
		}
	}
	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval **retval_ptr_ptr;


	SAVE_OPLINE();

	do {
		if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR ||
		    (IS_CONST == IS_VAR && opline->extended_value == ZEND_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = opline->op1.zv;
			if (!EG(return_value_ptr_ptr)) {
				if (IS_CONST == IS_TMP_VAR) {

				}
			} else if (!0) { /* Not a temp var */
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				zval_copy_ctor(ret);
				*EG(return_value_ptr_ptr) = ret;
			} else {
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				*EG(return_value_ptr_ptr) = ret;
			}
			break;
		}

		retval_ptr_ptr = NULL;

		if (IS_CONST == IS_VAR && UNEXPECTED(retval_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot return string offsets by reference");
		}

		if (IS_CONST == IS_VAR && !Z_ISREF_PP(retval_ptr_ptr)) {
			if (opline->extended_value == ZEND_RETURNS_FUNCTION &&
			    EX_T(opline->op1.var).var.fcall_returned_reference) {
			} else if (EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EG(return_value_ptr_ptr)) {
					zval *ret;

					ALLOC_ZVAL(ret);
					INIT_PZVAL_COPY(ret, *retval_ptr_ptr);
					zval_copy_ctor(ret);
					*EG(return_value_ptr_ptr) = ret;
				}
				break;
			}
		}

		if (EG(return_value_ptr_ptr)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr_ptr);
			Z_ADDREF_PP(retval_ptr_ptr);

			*EG(return_value_ptr_ptr) = *retval_ptr_ptr;
		}
	} while (0);

	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_THROW_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *exception;


	SAVE_OPLINE();
	value = opline->op1.zv;

	if (IS_CONST == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Can only throw objects");
	}

	zend_exception_save(TSRMLS_C);
	/* Not sure if a complete copy is what we want here */
	ALLOC_ZVAL(exception);
	INIT_PZVAL_COPY(exception, value);
	if (!0) {
		zval_copy_ctor(exception);
	}

	zend_throw_exception_object(exception TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);

	HANDLE_EXCEPTION();
}

static int ZEND_FASTCALL  ZEND_SEND_VAL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (opline->extended_value == ZEND_DO_FCALL_BY_NAME) {
		if (ARG_MUST_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.num)) {
			zend_error_noreturn(E_ERROR, "Cannot pass parameter %d by reference", opline->op2.num);
		}
	}

	{
		zval *valptr;
		zval *value;


		value = opline->op1.zv;

		ALLOC_ZVAL(valptr);
		INIT_PZVAL_COPY(valptr, value);
		if (!0) {
			zval_copy_ctor(valptr);
		}
		zend_vm_stack_push(valptr TSRMLS_CC);

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *retval = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	/* PHP 3.0 returned "" for false and 1 for true, here we use 0 and 1 for now */
	ZVAL_BOOL(retval, i_zend_is_true(opline->op1.zv));

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CLONE_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = opline->op1.zv;

	if (IS_CONST == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		Z_OBJVAL_P(retval) = clone_call(obj TSRMLS_CC);
		Z_TYPE_P(retval) = IS_OBJECT;
		Z_SET_REFCOUNT_P(retval, 1);
		Z_SET_ISREF_P(retval);
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&retval);
		} else {
			EX_T(opline->result.var).var.ptr = retval;
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CAST_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	expr = opline->op1.zv;

	if (opline->extended_value != IS_STRING) {
		ZVAL_COPY_VALUE(result, expr);
		if (!0) {
			zendi_zval_copy_ctor(*result);
		}
	}
	switch (opline->extended_value) {
		case IS_NULL:
			convert_to_null(result);
			break;
		case IS_BOOL:
			convert_to_boolean(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		case IS_DOUBLE:
			convert_to_double(result);
			break;
		case IS_STRING: {
			zval var_copy;
			int use_copy;

			zend_make_printable_zval(expr, &var_copy, &use_copy);
			if (use_copy) {
				ZVAL_COPY_VALUE(result, &var_copy);
				if (0) {

				}
			} else {
				ZVAL_COPY_VALUE(result, expr);
				if (!0) {
					zendi_zval_copy_ctor(*result);
				}
			}
			break;
		}
		case IS_ARRAY:
			convert_to_array(result);
			break;
		case IS_OBJECT:
			convert_to_object(result);
			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_op_array *new_op_array=NULL;

	zval *inc_filename;
	zval *tmp_inc_filename = NULL;
	zend_bool failure_retval=0;

	SAVE_OPLINE();
	inc_filename = opline->op1.zv;

	if (inc_filename->type!=IS_STRING) {
		MAKE_STD_ZVAL(tmp_inc_filename);
		ZVAL_COPY_VALUE(tmp_inc_filename, inc_filename);
		zval_copy_ctor(tmp_inc_filename);
		convert_to_string(tmp_inc_filename);
		inc_filename = tmp_inc_filename;
	}

	if (opline->extended_value != ZEND_EVAL && strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)) {
		if (opline->extended_value == ZEND_INCLUDE_ONCE || opline->extended_value == ZEND_INCLUDE) {
			zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		} else {
			zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		}
	} else {
		switch (opline->extended_value) {
			case ZEND_INCLUDE_ONCE:
			case ZEND_REQUIRE_ONCE: {
					zend_file_handle file_handle;
					char *resolved_path;

					resolved_path = zend_resolve_path(Z_STRVAL_P(inc_filename), Z_STRLEN_P(inc_filename) TSRMLS_CC);
					if (resolved_path) {
						failure_retval = zend_hash_exists(&EG(included_files), resolved_path, strlen(resolved_path)+1);
					} else {
						resolved_path = Z_STRVAL_P(inc_filename);
					}

					if (failure_retval) {
						/* do nothing, file already included */
					} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {

						if (!file_handle.opened_path) {
							file_handle.opened_path = estrdup(resolved_path);
						}

						if (zend_hash_add_empty_element(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path)+1)==SUCCESS) {
							new_op_array = zend_compile_file(&file_handle, (opline->extended_value==ZEND_INCLUDE_ONCE?ZEND_INCLUDE:ZEND_REQUIRE) TSRMLS_CC);
							zend_destroy_file_handle(&file_handle TSRMLS_CC);
						} else {
							zend_file_handle_dtor(&file_handle TSRMLS_CC);
							failure_retval=1;
						}
					} else {
						if (opline->extended_value == ZEND_INCLUDE_ONCE) {
							zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						} else {
							zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						}
					}
					if (resolved_path != Z_STRVAL_P(inc_filename)) {
						efree(resolved_path);
					}
				}
				break;
			case ZEND_INCLUDE:
			case ZEND_REQUIRE:
				new_op_array = compile_filename(opline->extended_value, inc_filename TSRMLS_CC);
				break;
			case ZEND_EVAL: {
					char *eval_desc = zend_make_compiled_string_description("eval()'d code" TSRMLS_CC);

					new_op_array = zend_compile_string(inc_filename, eval_desc TSRMLS_CC);
					efree(eval_desc);
				}
				break;
			EMPTY_SWITCH_DEFAULT_CASE()
		}
	}
	if (tmp_inc_filename) {
		zval_ptr_dtor(&tmp_inc_filename);
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		HANDLE_EXCEPTION();
	} else if (EXPECTED(new_op_array != NULL)) {
		EX(original_return_value) = EG(return_value_ptr_ptr);
		EG(active_op_array) = new_op_array;
		if (RETURN_VALUE_USED(opline)) {
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			EG(return_value_ptr_ptr) = EX_T(opline->result.var).var.ptr_ptr;
		} else {
			EG(return_value_ptr_ptr) = NULL;
		}

		EX(function_state).function = (zend_function *) new_op_array;
		EX(object) = NULL;

		if (!EG(active_symbol_table)) {
			zend_rebuild_symbol_table(TSRMLS_C);
		}

		if (EXPECTED(zend_execute_ex == execute_ex)) {
			ZEND_VM_ENTER();
		} else {
			zend_execute(new_op_array TSRMLS_CC);
		}

		EX(function_state).function = (zend_function *) EX(op_array);

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		EG(return_value_ptr_ptr) = EX(original_return_value);
		destroy_op_array(new_op_array TSRMLS_CC);
		efree(new_op_array);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}

	} else if (RETURN_VALUE_USED(opline)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		ZVAL_BOOL(retval, failure_retval);
		INIT_PZVAL(retval);
		EX_T(opline->result.var).var.ptr = retval;
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FE_RESET_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *array_ptr, **array_ptr_ptr;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;
	zend_class_entry *ce = NULL;
	zend_bool is_empty = 0;

	SAVE_OPLINE();

	if ((IS_CONST == IS_CV || IS_CONST == IS_VAR) &&
	    (opline->extended_value & ZEND_FE_RESET_VARIABLE)) {
		array_ptr_ptr = NULL;
		if (array_ptr_ptr == NULL || array_ptr_ptr == &EG(uninitialized_zval_ptr)) {
			MAKE_STD_ZVAL(array_ptr);
			ZVAL_NULL(array_ptr);
		} else if (Z_TYPE_PP(array_ptr_ptr) == IS_OBJECT) {
			if(Z_OBJ_HT_PP(array_ptr_ptr)->get_class_entry == NULL) {
				zend_error(E_WARNING, "foreach() cannot iterate over objects without PHP class");
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}

			ce = Z_OBJCE_PP(array_ptr_ptr);
			if (!ce || ce->get_iterator == NULL) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				Z_ADDREF_PP(array_ptr_ptr);
			}
			array_ptr = *array_ptr_ptr;
		} else {
			if (Z_TYPE_PP(array_ptr_ptr) == IS_ARRAY) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
					Z_SET_ISREF_PP(array_ptr_ptr);
				}
			}
			array_ptr = *array_ptr_ptr;
			Z_ADDREF_P(array_ptr);
		}
	} else {
		array_ptr = opline->op1.zv;
		if (0) { /* IS_TMP_VAR */
			zval *tmp;

			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			array_ptr = tmp;
			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
				ce = Z_OBJCE_P(array_ptr);
				if (ce && ce->get_iterator) {
					Z_DELREF_P(array_ptr);
				}
			}
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			ce = Z_OBJCE_P(array_ptr);
			if (!ce || !ce->get_iterator) {
				if (IS_CONST == IS_CV) {
					Z_ADDREF_P(array_ptr);
				}
			}
		} else if (IS_CONST == IS_CONST ||
		           (IS_CONST == IS_CV &&
		            !Z_ISREF_P(array_ptr) &&
		            Z_REFCOUNT_P(array_ptr) > 1) ||
		           (IS_CONST == IS_VAR &&
		            !Z_ISREF_P(array_ptr) &&
		            Z_REFCOUNT_P(array_ptr) > 2)) {
			zval *tmp;

			if (IS_CONST == IS_VAR) {
				Z_DELREF_P(array_ptr);
			}
			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			zval_copy_ctor(tmp);
			array_ptr = tmp;
		} else if (IS_CONST == IS_CV) {
			Z_ADDREF_P(array_ptr);
		}
	}

	if (ce && ce->get_iterator) {
		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);

		if (IS_CONST == IS_VAR && !(opline->extended_value & ZEND_FE_RESET_VARIABLE)) {

		}
		if (iter && EXPECTED(EG(exception) == NULL)) {
			array_ptr = zend_iterator_wrap(iter TSRMLS_CC);
		} else {
			if (IS_CONST == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

			}
			if (!EG(exception)) {
				zend_throw_exception_ex(NULL, 0 TSRMLS_CC, "Object of type %s did not create an Iterator", ce->name);
			}
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}
	}

	EX_T(opline->result.var).fe.ptr = array_ptr;

	if (iter) {
		iter->index = 0;
		if (iter->funcs->rewind) {
			iter->funcs->rewind(iter TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(&array_ptr);
				if (IS_CONST == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

				}
				HANDLE_EXCEPTION();
			}
		}
		is_empty = iter->funcs->valid(iter TSRMLS_CC) != SUCCESS;
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&array_ptr);
			if (IS_CONST == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

			}
			HANDLE_EXCEPTION();
		}
		iter->index = -1; /* will be set to 0 before using next handler */
	} else if ((fe_ht = HASH_OF(array_ptr)) != NULL) {
		zend_hash_internal_pointer_reset(fe_ht);
		if (ce) {
			zend_object *zobj = zend_objects_get_address(array_ptr TSRMLS_CC);
			while (zend_hash_has_more_elements(fe_ht) == SUCCESS) {
				char *str_key;
				uint str_key_len;
				ulong int_key;
				zend_uchar key_type;

				key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, NULL);
				if (key_type != HASH_KEY_NON_EXISTENT &&
					(key_type == HASH_KEY_IS_LONG ||
				     zend_check_property_access(zobj, str_key, str_key_len-1 TSRMLS_CC) == SUCCESS)) {
					break;
				}
				zend_hash_move_forward(fe_ht);
			}
		}
		is_empty = zend_hash_has_more_elements(fe_ht) != SUCCESS;
		zend_hash_get_pointer(fe_ht, &EX_T(opline->result.var).fe.fe_pos);
	} else {
		zend_error(E_WARNING, "Invalid argument supplied for foreach()");
		is_empty = 1;
	}

	if (IS_CONST == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

	}
	if (is_empty) {
		ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
	} else {
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_EXIT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0 || (IS_CONST != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_CONST != IS_UNUSED) {

		zval *ptr = opline->op1.zv;

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}

	}
#endif
	zend_bailout();
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

static int ZEND_FASTCALL  ZEND_JMP_SET_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = opline->op1.zv;

	if (i_zend_is_true(value)) {
		ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
		if (!0) {
			zendi_zval_copy_ctor(EX_T(opline->result.var).tmp_var);
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value, *ret;

	SAVE_OPLINE();
	value = opline->op1.zv;

	if (i_zend_is_true(value)) {
		if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
			Z_ADDREF_P(value);
			EX_T(opline->result.var).var.ptr = value;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		} else {
			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, value);
			EX_T(opline->result.var).var.ptr = ret;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			if (!0) {
				zval_copy_ctor(EX_T(opline->result.var).var.ptr);
			}
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = opline->op1.zv;

	ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
	if (!0) {
		zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value, *ret;

	SAVE_OPLINE();
	value = opline->op1.zv;

	if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		Z_ADDREF_P(value);
		EX_T(opline->result.var).var.ptr = value;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	} else {
		ALLOC_ZVAL(ret);
		INIT_PZVAL_COPY(ret, value);
		EX_T(opline->result.var).var.ptr = ret;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		if (!0) {
			zval_copy_ctor(EX_T(opline->result.var).var.ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CONST_CONST(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = opline->op1.zv;

 	if (IS_CONST != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CONST != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_CONST == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else {
			hash_value = str_hash(Z_STRVAL_P(varname), Z_STRLEN_P(varname));
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_CONST != IS_TMP_VAR) {

				}
				break;
			case ZEND_FETCH_LOCAL:

				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_CONST == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_CONST != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			EX_T(opline->result.var).var.ptr = *retval;
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_CONST(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_CONST(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_CONST(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	return zend_fetch_var_address_helper_SPEC_CONST_CONST(zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC) ? BP_VAR_W : BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_CONST(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_CONST(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = opline->op1.zv;
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);

	if (IS_CONST != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_TMP_VAR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = opline->op1.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_ARRAY)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {

		zval *value = *zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);

		PZVAL_LOCK(value);
		EX_T(opline->result.var).var.ptr = value;

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_CONST == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_CONST != IS_CONST &&
	           IS_CONST == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_CONST != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;


		if (IS_CONST == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = opline->op2.zv;

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_CONST == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_CONST == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_CONST != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 opline->op1.zv,
				 opline->op2.zv TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_CONSTANT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_CONST == IS_UNUSED) {
		zend_constant *c;
		zval *retval;

		if (CACHED_PTR(opline->op2.literal->cache_slot)) {
			c = CACHED_PTR(opline->op2.literal->cache_slot);
		} else if ((c = zend_quick_get_constant(opline->op2.literal + 1, opline->extended_value TSRMLS_CC)) == NULL) {
			if ((opline->extended_value & IS_CONSTANT_UNQUALIFIED) != 0) {
				char *actual = (char *)zend_memrchr(Z_STRVAL_P(opline->op2.zv), '\\', Z_STRLEN_P(opline->op2.zv));
				if(!actual) {
					actual = Z_STRVAL_P(opline->op2.zv);
				} else {
					actual++;
				}
				/* non-qualified constant - allow text substitution */
				zend_error(E_NOTICE, "Use of undefined constant %s - assumed '%s'", actual, actual);
				ZVAL_STRINGL(&EX_T(opline->result.var).tmp_var, actual, Z_STRLEN_P(opline->op2.zv)-(actual - Z_STRVAL_P(opline->op2.zv)), 1);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else {
				zend_error_noreturn(E_ERROR, "Undefined constant '%s'", Z_STRVAL_P(opline->op2.zv));
			}
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, c);
		}
		retval = &EX_T(opline->result.var).tmp_var;
		ZVAL_COPY_VALUE(retval, &c->value);
		zval_copy_ctor(retval);
	} else {
		/* class constant */
		zend_class_entry *ce;
		zval **value;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				value = CACHED_PTR(opline->op2.literal->cache_slot);
				ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
				zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
				goto constant_fetch_end;
			} else if (CACHED_PTR(opline->op1.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op1.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
				}
				CACHE_PTR(opline->op1.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op1.var).class_entry;
			if ((value = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce)) != NULL) {
				ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
				zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
				goto constant_fetch_end;
			}
		}

		if (EXPECTED(zend_hash_quick_find(&ce->constants_table, Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv)+1, Z_HASH_P(opline->op2.zv), (void **) &value) == SUCCESS)) {
			if (IS_CONSTANT_TYPE(Z_TYPE_PP(value))) {
				zend_class_entry *old_scope = EG(scope);

				EG(scope) = ce;
				zval_update_constant(value, 1 TSRMLS_CC);
				EG(scope) = old_scope;
			}
			if (IS_CONST == IS_CONST) {
				CACHE_PTR(opline->op2.literal->cache_slot, value);
			} else {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, value);
			}
			ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
			zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
		} else if (Z_STRLEN_P(opline->op2.zv) == sizeof("class")-1 && memcmp(Z_STRVAL_P(opline->op2.zv), "class", sizeof("class") - 1) == 0) {
			/* "class" is assigned as a case-sensitive keyword from zend_do_resolve_class_name */
			ZVAL_STRINGL(&EX_T(opline->result.var).tmp_var, ce->name, ce->name_length, 1);
		} else {
			zend_error_noreturn(E_ERROR, "Undefined class constant '%s'", Z_STRVAL_P(opline->op2.zv));
		}
	}
constant_fetch_end:
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_CONST == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=opline->op1.zv;
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CONST == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_CONST == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CONST != IS_UNUSED) {

		zval *offset = opline->op2.zv;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CONST == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;


	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = opline->op1.zv;

	if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_CONST != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
						zval_ptr_dtor(&varname);
					}

					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_CONST != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		zval_ptr_dtor(&varname);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = opline->op1.zv;

		if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_CONST != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_CONST == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_CONST != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DECLARE_CONST_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *name;
	zval *val;
	zend_constant c;

	SAVE_OPLINE();
	name  = opline->op1.zv;
	val   = opline->op2.zv;

	if (IS_CONSTANT_TYPE(Z_TYPE_P(val))) {
		zval tmp;
		zval *tmp_ptr = &tmp;

		ZVAL_COPY_VALUE(&tmp, val);
		INIT_PZVAL(&tmp);
		zval_update_constant(&tmp_ptr, 0 TSRMLS_CC);
		c.value = *tmp_ptr;
	} else {
		INIT_PZVAL_COPY(&c.value, val);
		if (Z_TYPE(c.value) == IS_ARRAY) {
			HashTable *ht;

			ALLOC_HASHTABLE(ht);
			zend_hash_init(ht, zend_hash_num_elements(Z_ARRVAL(c.value)), NULL, ZVAL_PTR_DTOR, 0);
			zend_hash_copy(ht, Z_ARRVAL(c.value), (copy_ctor_func_t) zval_deep_copy, NULL, sizeof(zval *));
			Z_ARRVAL(c.value) = ht;
		} else {
			zval_copy_ctor(&c.value);
		}
	}
	c.flags = CONST_CS; /* non persistent, case sensetive */
	c.name = str_strndup(Z_STRVAL_P(name), Z_STRLEN_P(name));
	c.name_len = Z_STRLEN_P(name)+1;
	c.module_number = PHP_USER_CONSTANT;

	if (zend_register_constant(&c TSRMLS_CC) == FAILURE) {
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_CONST == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;

	SAVE_OPLINE();
	container = opline->op1.zv;
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CONST != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_TMP_VAR == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_CONST != IS_CONST &&
	           IS_TMP_VAR == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_TMP_VAR != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;
		zend_free_op free_op2;

		if (IS_TMP_VAR == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_TMP_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_CONST == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_TMP_VAR != IS_CONST) {
			zval_dtor(free_op2.var);
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 opline->op1.zv,
				 _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_CONST == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=opline->op1.zv;
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CONST == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_CONST == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_TMP_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		zval_dtor(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_CONST == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!1) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CONST_VAR(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = opline->op1.zv;

 	if (IS_CONST != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CONST != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_CONST == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else {
			hash_value = str_hash(Z_STRVAL_P(varname), Z_STRLEN_P(varname));
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_CONST != IS_TMP_VAR) {

				}
				break;
			case ZEND_FETCH_LOCAL:

				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_CONST == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_CONST != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			EX_T(opline->result.var).var.ptr = *retval;
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_VAR(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_VAR(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_VAR(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	return zend_fetch_var_address_helper_SPEC_CONST_VAR(zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC) ? BP_VAR_W : BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_VAR(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_VAR(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;

	SAVE_OPLINE();
	container = opline->op1.zv;
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op2.var);
	if (IS_CONST != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_VAR == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_CONST != IS_CONST &&
	           IS_VAR == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_VAR != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;
		zend_free_op free_op2;

		if (IS_VAR == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_CONST == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_VAR != IS_CONST) {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 opline->op1.zv,
				 _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_CONST == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=opline->op1.zv;
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CONST == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_CONST == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;


	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = opline->op1.zv;

	if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_CONST != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
						zval_ptr_dtor(&varname);
					}

					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_CONST != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		zval_ptr_dtor(&varname);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = opline->op1.zv;

		if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_VAR != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_VAR == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_CONST != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_CONST == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CONST_UNUSED(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = opline->op1.zv;

 	if (IS_CONST != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CONST != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_CONST == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else {
			hash_value = str_hash(Z_STRVAL_P(varname), Z_STRLEN_P(varname));
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_CONST != IS_TMP_VAR) {

				}
				break;
			case ZEND_FETCH_LOCAL:

				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_CONST == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_CONST != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			EX_T(opline->result.var).var.ptr = *retval;
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC) ? BP_VAR_W : BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_UNUSED == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_CONST != IS_CONST &&
	           IS_UNUSED == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_UNUSED != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;


		if (IS_UNUSED == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = NULL;

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_UNUSED == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_UNUSED == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_CONST == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_UNUSED != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_CONST == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=opline->op1.zv;
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CONST == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_CONST == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_UNUSED != IS_UNUSED) {

		zval *offset = NULL;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_UNUSED == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;


	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = opline->op1.zv;

	if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_CONST != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
						zval_ptr_dtor(&varname);
					}

					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_CONST != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		zval_ptr_dtor(&varname);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = opline->op1.zv;

		if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_UNUSED != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_UNUSED == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_CONST != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_function *op_array;

	SAVE_OPLINE();

	if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), Z_HASH_P(opline->op1.zv), (void *) &op_array) == FAILURE) ||
	    UNEXPECTED(op_array->type != ZEND_USER_FUNCTION)) {
		zend_error_noreturn(E_ERROR, "Base lambda function for closure not found");
	}

	if (UNEXPECTED((op_array->common.fn_flags & ZEND_ACC_STATIC) ||
			(EX(prev_execute_data) &&
			 EX(prev_execute_data)->function_state.function->common.fn_flags & ZEND_ACC_STATIC))) {
		zend_create_closure(&EX_T(opline->result.var).tmp_var, (zend_function *) op_array,  EG(called_scope), NULL TSRMLS_CC);
	} else {
		zend_create_closure(&EX_T(opline->result.var).tmp_var, (zend_function *) op_array,  EG(scope), EG(This) TSRMLS_CC);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_CONST == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = opline->op1.zv;
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);

	if (IS_CONST != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_CV == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_CONST != IS_CONST &&
	           IS_CV == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_CV != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;


		if (IS_CV == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_CV == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_CONST == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_CV != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CATCH_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_class_entry *ce, *catch_ce;
	zval *exception;

	SAVE_OPLINE();
	/* Check whether an exception has been thrown, if not, jump over code */
	zend_exception_restore(TSRMLS_C);
	if (EG(exception) == NULL) {
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
	if (CACHED_PTR(opline->op1.literal->cache_slot)) {
		catch_ce = CACHED_PTR(opline->op1.literal->cache_slot);
	} else {
		catch_ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, ZEND_FETCH_CLASS_NO_AUTOLOAD TSRMLS_CC);

		CACHE_PTR(opline->op1.literal->cache_slot, catch_ce);
	}
	ce = Z_OBJCE_P(EG(exception));

#ifdef HAVE_DTRACE
	if (DTRACE_EXCEPTION_CAUGHT_ENABLED()) {
		DTRACE_EXCEPTION_CAUGHT((char *)ce->name);
	}
#endif /* HAVE_DTRACE */

	if (ce != catch_ce) {
		if (!instanceof_function(ce, catch_ce TSRMLS_CC)) {
			if (opline->result.num) {
				zend_throw_exception_internal(NULL TSRMLS_CC);
				HANDLE_EXCEPTION();
			}
			ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
			ZEND_VM_CONTINUE(); /* CHECK_ME */
		}
	}

	exception = EG(exception);
	if (!EG(active_symbol_table)) {
		if (EX_CV(opline->op2.var)) {
			zval_ptr_dtor(EX_CV(opline->op2.var));
		}
		EX_CV(opline->op2.var) = (zval**)EX_CV_NUM(execute_data, EX(op_array)->last_var + opline->op2.var);
		*EX_CV(opline->op2.var) = EG(exception);
	} else {
		zend_compiled_variable *cv = &CV_DEF_OF(opline->op2.var);
		zend_hash_quick_update(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value,
		    &EG(exception), sizeof(zval *), (void**)&EX_CV(opline->op2.var));
	}
	if (UNEXPECTED(EG(exception) != exception)) {
		Z_ADDREF_P(EG(exception));
		HANDLE_EXCEPTION();
	} else {
		EG(exception) = NULL;
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 opline->op1.zv,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_CONST == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=opline->op1.zv;
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CONST == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_CONST == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CV != IS_UNUSED) {

		zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CV == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_CONST == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_NOT_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_not_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_NOT_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_not_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ECHO_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *z;

	SAVE_OPLINE();
	z = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && Z_TYPE_P(z) == IS_OBJECT) {
		INIT_PZVAL(z);
	}
	zend_print_variable(z);

	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRINT_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZVAL_LONG(&EX_T(opline->result.var).tmp_var, 1);
	return ZEND_ECHO_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_JMPZ_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (!ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPZNZ_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (EXPECTED(retval != 0)) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on true to %d\n", opline->extended_value);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	} else {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on false to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
}

static int ZEND_FASTCALL  ZEND_JMPZ_EX_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (!retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_EX_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FREE_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_TMP_VAR) {
		zendi_zval_dtor(EX_T(opline->op1.var).tmp_var);
	} else {
		zval_ptr_dtor(&EX_T(opline->op1.var).var.ptr);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_RETURN_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zend_free_op free_op1;

	SAVE_OPLINE();
	retval_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (!EG(return_value_ptr_ptr)) {
		zval_dtor(free_op1.var);
	} else {
		if (IS_TMP_VAR == IS_CONST ||
		    IS_TMP_VAR == IS_TMP_VAR ||
		    PZVAL_IS_REF(retval_ptr)) {
			zval *ret;

			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, retval_ptr);
			if (IS_TMP_VAR != IS_TMP_VAR) {
				zval_copy_ctor(ret);
			}
			*EG(return_value_ptr_ptr) = ret;

		} else if ((IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) &&
		           retval_ptr == &EG(uninitialized_zval)) {
			zval *ret;

			if (IS_TMP_VAR == IS_VAR) {
				Z_DELREF_P(retval_ptr);
			}
			ALLOC_INIT_ZVAL(ret);
			*EG(return_value_ptr_ptr) = ret;
		} else {
			*EG(return_value_ptr_ptr) = retval_ptr;
			if (IS_TMP_VAR == IS_CV) {
				Z_ADDREF_P(retval_ptr);
			}
		}
	}
	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval **retval_ptr_ptr;
	zend_free_op free_op1;

	SAVE_OPLINE();

	do {
		if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR ||
		    (IS_TMP_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			if (!EG(return_value_ptr_ptr)) {
				if (IS_TMP_VAR == IS_TMP_VAR) {
					zval_dtor(free_op1.var);
				}
			} else if (!1) { /* Not a temp var */
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				zval_copy_ctor(ret);
				*EG(return_value_ptr_ptr) = ret;
			} else {
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				*EG(return_value_ptr_ptr) = ret;
			}
			break;
		}

		retval_ptr_ptr = NULL;

		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(retval_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot return string offsets by reference");
		}

		if (IS_TMP_VAR == IS_VAR && !Z_ISREF_PP(retval_ptr_ptr)) {
			if (opline->extended_value == ZEND_RETURNS_FUNCTION &&
			    EX_T(opline->op1.var).var.fcall_returned_reference) {
			} else if (EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EG(return_value_ptr_ptr)) {
					zval *ret;

					ALLOC_ZVAL(ret);
					INIT_PZVAL_COPY(ret, *retval_ptr_ptr);
					zval_copy_ctor(ret);
					*EG(return_value_ptr_ptr) = ret;
				}
				break;
			}
		}

		if (EG(return_value_ptr_ptr)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr_ptr);
			Z_ADDREF_PP(retval_ptr_ptr);

			*EG(return_value_ptr_ptr) = *retval_ptr_ptr;
		}
	} while (0);

	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_THROW_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *exception;
	zend_free_op free_op1;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Can only throw objects");
	}

	zend_exception_save(TSRMLS_C);
	/* Not sure if a complete copy is what we want here */
	ALLOC_ZVAL(exception);
	INIT_PZVAL_COPY(exception, value);
	if (!1) {
		zval_copy_ctor(exception);
	}

	zend_throw_exception_object(exception TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);

	HANDLE_EXCEPTION();
}

static int ZEND_FASTCALL  ZEND_SEND_VAL_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (opline->extended_value == ZEND_DO_FCALL_BY_NAME) {
		if (ARG_MUST_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.num)) {
			zend_error_noreturn(E_ERROR, "Cannot pass parameter %d by reference", opline->op2.num);
		}
	}

	{
		zval *valptr;
		zval *value;
		zend_free_op free_op1;

		value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		ALLOC_ZVAL(valptr);
		INIT_PZVAL_COPY(valptr, value);
		if (!1) {
			zval_copy_ctor(valptr);
		}
		zend_vm_stack_push(valptr TSRMLS_CC);

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *retval = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	/* PHP 3.0 returned "" for false and 1 for true, here we use 0 and 1 for now */
	ZVAL_BOOL(retval, i_zend_is_true(_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC)));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CLONE_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		Z_OBJVAL_P(retval) = clone_call(obj TSRMLS_CC);
		Z_TYPE_P(retval) = IS_OBJECT;
		Z_SET_REFCOUNT_P(retval, 1);
		Z_SET_ISREF_P(retval);
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&retval);
		} else {
			EX_T(opline->result.var).var.ptr = retval;
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CAST_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	expr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (opline->extended_value != IS_STRING) {
		ZVAL_COPY_VALUE(result, expr);
		if (!1) {
			zendi_zval_copy_ctor(*result);
		}
	}
	switch (opline->extended_value) {
		case IS_NULL:
			convert_to_null(result);
			break;
		case IS_BOOL:
			convert_to_boolean(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		case IS_DOUBLE:
			convert_to_double(result);
			break;
		case IS_STRING: {
			zval var_copy;
			int use_copy;

			zend_make_printable_zval(expr, &var_copy, &use_copy);
			if (use_copy) {
				ZVAL_COPY_VALUE(result, &var_copy);
				if (1) {
					zval_dtor(free_op1.var);
				}
			} else {
				ZVAL_COPY_VALUE(result, expr);
				if (!1) {
					zendi_zval_copy_ctor(*result);
				}
			}
			break;
		}
		case IS_ARRAY:
			convert_to_array(result);
			break;
		case IS_OBJECT:
			convert_to_object(result);
			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_op_array *new_op_array=NULL;
	zend_free_op free_op1;
	zval *inc_filename;
	zval *tmp_inc_filename = NULL;
	zend_bool failure_retval=0;

	SAVE_OPLINE();
	inc_filename = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (inc_filename->type!=IS_STRING) {
		MAKE_STD_ZVAL(tmp_inc_filename);
		ZVAL_COPY_VALUE(tmp_inc_filename, inc_filename);
		zval_copy_ctor(tmp_inc_filename);
		convert_to_string(tmp_inc_filename);
		inc_filename = tmp_inc_filename;
	}

	if (opline->extended_value != ZEND_EVAL && strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)) {
		if (opline->extended_value == ZEND_INCLUDE_ONCE || opline->extended_value == ZEND_INCLUDE) {
			zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		} else {
			zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		}
	} else {
		switch (opline->extended_value) {
			case ZEND_INCLUDE_ONCE:
			case ZEND_REQUIRE_ONCE: {
					zend_file_handle file_handle;
					char *resolved_path;

					resolved_path = zend_resolve_path(Z_STRVAL_P(inc_filename), Z_STRLEN_P(inc_filename) TSRMLS_CC);
					if (resolved_path) {
						failure_retval = zend_hash_exists(&EG(included_files), resolved_path, strlen(resolved_path)+1);
					} else {
						resolved_path = Z_STRVAL_P(inc_filename);
					}

					if (failure_retval) {
						/* do nothing, file already included */
					} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {

						if (!file_handle.opened_path) {
							file_handle.opened_path = estrdup(resolved_path);
						}

						if (zend_hash_add_empty_element(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path)+1)==SUCCESS) {
							new_op_array = zend_compile_file(&file_handle, (opline->extended_value==ZEND_INCLUDE_ONCE?ZEND_INCLUDE:ZEND_REQUIRE) TSRMLS_CC);
							zend_destroy_file_handle(&file_handle TSRMLS_CC);
						} else {
							zend_file_handle_dtor(&file_handle TSRMLS_CC);
							failure_retval=1;
						}
					} else {
						if (opline->extended_value == ZEND_INCLUDE_ONCE) {
							zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						} else {
							zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						}
					}
					if (resolved_path != Z_STRVAL_P(inc_filename)) {
						efree(resolved_path);
					}
				}
				break;
			case ZEND_INCLUDE:
			case ZEND_REQUIRE:
				new_op_array = compile_filename(opline->extended_value, inc_filename TSRMLS_CC);
				break;
			case ZEND_EVAL: {
					char *eval_desc = zend_make_compiled_string_description("eval()'d code" TSRMLS_CC);

					new_op_array = zend_compile_string(inc_filename, eval_desc TSRMLS_CC);
					efree(eval_desc);
				}
				break;
			EMPTY_SWITCH_DEFAULT_CASE()
		}
	}
	if (tmp_inc_filename) {
		zval_ptr_dtor(&tmp_inc_filename);
	}
	zval_dtor(free_op1.var);
	if (UNEXPECTED(EG(exception) != NULL)) {
		HANDLE_EXCEPTION();
	} else if (EXPECTED(new_op_array != NULL)) {
		EX(original_return_value) = EG(return_value_ptr_ptr);
		EG(active_op_array) = new_op_array;
		if (RETURN_VALUE_USED(opline)) {
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			EG(return_value_ptr_ptr) = EX_T(opline->result.var).var.ptr_ptr;
		} else {
			EG(return_value_ptr_ptr) = NULL;
		}

		EX(function_state).function = (zend_function *) new_op_array;
		EX(object) = NULL;

		if (!EG(active_symbol_table)) {
			zend_rebuild_symbol_table(TSRMLS_C);
		}

		if (EXPECTED(zend_execute_ex == execute_ex)) {
			ZEND_VM_ENTER();
		} else {
			zend_execute(new_op_array TSRMLS_CC);
		}

		EX(function_state).function = (zend_function *) EX(op_array);

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		EG(return_value_ptr_ptr) = EX(original_return_value);
		destroy_op_array(new_op_array TSRMLS_CC);
		efree(new_op_array);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}

	} else if (RETURN_VALUE_USED(opline)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		ZVAL_BOOL(retval, failure_retval);
		INIT_PZVAL(retval);
		EX_T(opline->result.var).var.ptr = retval;
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FE_RESET_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *array_ptr, **array_ptr_ptr;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;
	zend_class_entry *ce = NULL;
	zend_bool is_empty = 0;

	SAVE_OPLINE();

	if ((IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) &&
	    (opline->extended_value & ZEND_FE_RESET_VARIABLE)) {
		array_ptr_ptr = NULL;
		if (array_ptr_ptr == NULL || array_ptr_ptr == &EG(uninitialized_zval_ptr)) {
			MAKE_STD_ZVAL(array_ptr);
			ZVAL_NULL(array_ptr);
		} else if (Z_TYPE_PP(array_ptr_ptr) == IS_OBJECT) {
			if(Z_OBJ_HT_PP(array_ptr_ptr)->get_class_entry == NULL) {
				zend_error(E_WARNING, "foreach() cannot iterate over objects without PHP class");
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}

			ce = Z_OBJCE_PP(array_ptr_ptr);
			if (!ce || ce->get_iterator == NULL) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				Z_ADDREF_PP(array_ptr_ptr);
			}
			array_ptr = *array_ptr_ptr;
		} else {
			if (Z_TYPE_PP(array_ptr_ptr) == IS_ARRAY) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
					Z_SET_ISREF_PP(array_ptr_ptr);
				}
			}
			array_ptr = *array_ptr_ptr;
			Z_ADDREF_P(array_ptr);
		}
	} else {
		array_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* IS_TMP_VAR */
			zval *tmp;

			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			array_ptr = tmp;
			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
				ce = Z_OBJCE_P(array_ptr);
				if (ce && ce->get_iterator) {
					Z_DELREF_P(array_ptr);
				}
			}
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			ce = Z_OBJCE_P(array_ptr);
			if (!ce || !ce->get_iterator) {
				if (IS_TMP_VAR == IS_CV) {
					Z_ADDREF_P(array_ptr);
				}
			}
		} else if (IS_TMP_VAR == IS_CONST ||
		           (IS_TMP_VAR == IS_CV &&
		            !Z_ISREF_P(array_ptr) &&
		            Z_REFCOUNT_P(array_ptr) > 1) ||
		           (IS_TMP_VAR == IS_VAR &&
		            !Z_ISREF_P(array_ptr) &&
		            Z_REFCOUNT_P(array_ptr) > 2)) {
			zval *tmp;

			if (IS_TMP_VAR == IS_VAR) {
				Z_DELREF_P(array_ptr);
			}
			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			zval_copy_ctor(tmp);
			array_ptr = tmp;
		} else if (IS_TMP_VAR == IS_CV) {
			Z_ADDREF_P(array_ptr);
		}
	}

	if (ce && ce->get_iterator) {
		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);

		if (IS_TMP_VAR == IS_VAR && !(opline->extended_value & ZEND_FE_RESET_VARIABLE)) {

		}
		if (iter && EXPECTED(EG(exception) == NULL)) {
			array_ptr = zend_iterator_wrap(iter TSRMLS_CC);
		} else {
			if (IS_TMP_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

			}
			if (!EG(exception)) {
				zend_throw_exception_ex(NULL, 0 TSRMLS_CC, "Object of type %s did not create an Iterator", ce->name);
			}
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}
	}

	EX_T(opline->result.var).fe.ptr = array_ptr;

	if (iter) {
		iter->index = 0;
		if (iter->funcs->rewind) {
			iter->funcs->rewind(iter TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(&array_ptr);
				if (IS_TMP_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

				}
				HANDLE_EXCEPTION();
			}
		}
		is_empty = iter->funcs->valid(iter TSRMLS_CC) != SUCCESS;
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&array_ptr);
			if (IS_TMP_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

			}
			HANDLE_EXCEPTION();
		}
		iter->index = -1; /* will be set to 0 before using next handler */
	} else if ((fe_ht = HASH_OF(array_ptr)) != NULL) {
		zend_hash_internal_pointer_reset(fe_ht);
		if (ce) {
			zend_object *zobj = zend_objects_get_address(array_ptr TSRMLS_CC);
			while (zend_hash_has_more_elements(fe_ht) == SUCCESS) {
				char *str_key;
				uint str_key_len;
				ulong int_key;
				zend_uchar key_type;

				key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, NULL);
				if (key_type != HASH_KEY_NON_EXISTENT &&
					(key_type == HASH_KEY_IS_LONG ||
				     zend_check_property_access(zobj, str_key, str_key_len-1 TSRMLS_CC) == SUCCESS)) {
					break;
				}
				zend_hash_move_forward(fe_ht);
			}
		}
		is_empty = zend_hash_has_more_elements(fe_ht) != SUCCESS;
		zend_hash_get_pointer(fe_ht, &EX_T(opline->result.var).fe.fe_pos);
	} else {
		zend_error(E_WARNING, "Invalid argument supplied for foreach()");
		is_empty = 1;
	}

	if (IS_TMP_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

	}
	if (is_empty) {
		ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
	} else {
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_EXIT_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0 || (IS_TMP_VAR != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;
		zval *ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}
		zval_dtor(free_op1.var);
	}
#endif
	zend_bailout();
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

static int ZEND_FASTCALL  ZEND_END_SILENCE_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval restored_error_reporting;

	SAVE_OPLINE();
	if (!EG(error_reporting) && Z_LVAL(EX_T(opline->op1.var).tmp_var) != 0) {
		Z_TYPE(restored_error_reporting) = IS_LONG;
		Z_LVAL(restored_error_reporting) = Z_LVAL(EX_T(opline->op1.var).tmp_var);
		EG(error_reporting) = Z_LVAL(restored_error_reporting);
		convert_to_string(&restored_error_reporting);
		if (EXPECTED(EG(error_reporting_ini_entry) != NULL)) {
			if (EXPECTED(EG(error_reporting_ini_entry)->modified &&
			    EG(error_reporting_ini_entry)->value != EG(error_reporting_ini_entry)->orig_value)) {
				efree(EG(error_reporting_ini_entry)->value);
			}
			EG(error_reporting_ini_entry)->value = Z_STRVAL(restored_error_reporting);
			EG(error_reporting_ini_entry)->value_length = Z_STRLEN(restored_error_reporting);
		} else {
			zendi_zval_dtor(restored_error_reporting);
		}
	}
	if (EX(old_error_reporting) == &EX_T(opline->op1.var).tmp_var) {
		EX(old_error_reporting) = NULL;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMP_SET_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (i_zend_is_true(value)) {
		ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
		if (!1) {
			zendi_zval_copy_ctor(EX_T(opline->result.var).tmp_var);
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value, *ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (i_zend_is_true(value)) {
		if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
			Z_ADDREF_P(value);
			EX_T(opline->result.var).var.ptr = value;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		} else {
			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, value);
			EX_T(opline->result.var).var.ptr = ret;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			if (!1) {
				zval_copy_ctor(EX_T(opline->result.var).var.ptr);
			}
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
	if (!1) {
		zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value, *ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		Z_ADDREF_P(value);
		EX_T(opline->result.var).var.ptr = value;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	} else {
		ALLOC_ZVAL(ret);
		INIT_PZVAL_COPY(ret, value);
		EX_T(opline->result.var).var.ptr = ret;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		if (!1) {
			zval_copy_ctor(EX_T(opline->result.var).var.ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INSTANCEOF_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (Z_TYPE_P(expr) == IS_OBJECT && Z_OBJ_HT_P(expr)->get_class_entry) {
		result = instanceof_function(Z_OBJCE_P(expr), EX_T(opline->op2.var).class_entry TSRMLS_CC);
	} else {
		result = 0;
	}
	ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, result);
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_TMP_CONST(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

 	if (IS_TMP_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_TMP_VAR != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}
					zval_dtor(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
		zval_dtor(free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_TMP_VAR == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else {
			hash_value = str_hash(Z_STRVAL_P(varname), Z_STRLEN_P(varname));
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_TMP_VAR != IS_TMP_VAR) {
					zval_dtor(free_op1.var);
				}
				break;
			case ZEND_FETCH_LOCAL:
				zval_dtor(free_op1.var);
				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_TMP_VAR == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_TMP_VAR != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			EX_T(opline->result.var).var.ptr = *retval;
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_CONST(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_CONST(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_CONST(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	return zend_fetch_var_address_helper_SPEC_TMP_CONST(zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC) ? BP_VAR_W : BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_CONST(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_CONST(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);

	if (IS_TMP_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_dtor(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_TMP_VAR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_ARRAY)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {

		zval *value = *zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);

		PZVAL_LOCK(value);
		EX_T(opline->result.var).var.ptr = value;

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_CHAR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *str = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_char_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	add_char_to_string(str, str, opline->op2.zv);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *str = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	add_string_to_string(str, str, opline->op2.zv);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = opline->op2.zv;

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CONST != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CONST == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 opline->op2.zv TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_TMP_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_TMP_VAR == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CONST != IS_UNUSED) {

		zval *offset = opline->op2.zv;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CONST == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
						zval_ptr_dtor(&varname);
					}
					zval_dtor(free_op1.var);
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		zval_ptr_dtor(&varname);
	}
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_CONST != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_CONST == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_dtor(free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_TMP_VAR == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_TMP_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_dtor(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_VAR_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *str = &EX_T(opline->result.var).tmp_var;
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		zend_make_printable_zval(var, &var_copy, &use_copy);

		if (use_copy) {
			var = &var_copy;
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */
	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1, free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_TMP_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_TMP_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_dtor(free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_TMP_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_TMP_VAR == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_TMP_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		zval_dtor(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_TMP_VAR == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!1) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_TMP_VAR(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

 	if (IS_TMP_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_TMP_VAR != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}
					zval_dtor(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
		zval_dtor(free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_TMP_VAR == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else {
			hash_value = str_hash(Z_STRVAL_P(varname), Z_STRLEN_P(varname));
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_TMP_VAR != IS_TMP_VAR) {
					zval_dtor(free_op1.var);
				}
				break;
			case ZEND_FETCH_LOCAL:
				zval_dtor(free_op1.var);
				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_TMP_VAR == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_TMP_VAR != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			EX_T(opline->result.var).var.ptr = *retval;
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_VAR(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_VAR(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_VAR(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	return zend_fetch_var_address_helper_SPEC_TMP_VAR(zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC) ? BP_VAR_W : BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_VAR(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_VAR(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op2.var);
	if (IS_TMP_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_dtor(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_VAR_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *str = &EX_T(opline->result.var).tmp_var;
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		zend_make_printable_zval(var, &var_copy, &use_copy);

		if (use_copy) {
			var = &var_copy;
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */
	zval_ptr_dtor_nogc(&free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1, free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor_nogc(&free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_ptr_dtor_nogc(&free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_TMP_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_TMP_VAR == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
						zval_ptr_dtor(&varname);
					}
					zval_dtor(free_op1.var);
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		zval_ptr_dtor(&varname);
	}
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_VAR != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_VAR == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_dtor(free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_TMP_VAR == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_TMP_UNUSED(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

 	if (IS_TMP_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_TMP_VAR != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}
					zval_dtor(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
		zval_dtor(free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_TMP_VAR == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else {
			hash_value = str_hash(Z_STRVAL_P(varname), Z_STRLEN_P(varname));
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_TMP_VAR != IS_TMP_VAR) {
					zval_dtor(free_op1.var);
				}
				break;
			case ZEND_FETCH_LOCAL:
				zval_dtor(free_op1.var);
				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_TMP_VAR == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_TMP_VAR != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			EX_T(opline->result.var).var.ptr = *retval;
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC) ? BP_VAR_W : BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_TMP_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_TMP_VAR == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_UNUSED != IS_UNUSED) {

		zval *offset = NULL;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_UNUSED == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
						zval_ptr_dtor(&varname);
					}
					zval_dtor(free_op1.var);
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		zval_ptr_dtor(&varname);
	}
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_UNUSED != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_UNUSED == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_dtor(free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_TMP_VAR == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);

	if (IS_TMP_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_dtor(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_VAR_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *str = &EX_T(opline->result.var).tmp_var;
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		zend_make_printable_zval(var, &var_copy, &use_copy);

		if (use_copy) {
			var = &var_copy;
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CV != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CV == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_TMP_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_TMP_VAR == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CV != IS_UNUSED) {

		zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CV == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_TMP_VAR == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_NOT_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_not_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_NOT_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_not_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **var_ptr;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_increment_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_increment_function(*var_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **var_ptr;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_decrement_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_decrement_function(*var_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **var_ptr, *retval;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		ZVAL_NULL(&EX_T(opline->result.var).tmp_var);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	retval = &EX_T(opline->result.var).tmp_var;
	ZVAL_COPY_VALUE(retval, *var_ptr);
	zendi_zval_copy_ctor(*retval);

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_increment_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_increment_function(*var_ptr);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_DEC_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **var_ptr, *retval;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		ZVAL_NULL(&EX_T(opline->result.var).tmp_var);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	retval = &EX_T(opline->result.var).tmp_var;
	ZVAL_COPY_VALUE(retval, *var_ptr);
	zendi_zval_copy_ctor(*retval);

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_decrement_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_decrement_function(*var_ptr);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ECHO_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *z;

	SAVE_OPLINE();
	z = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && Z_TYPE_P(z) == IS_OBJECT) {
		INIT_PZVAL(z);
	}
	zend_print_variable(z);

	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRINT_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZVAL_LONG(&EX_T(opline->result.var).tmp_var, 1);
	return ZEND_ECHO_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_JMPZ_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);
		zval_ptr_dtor_nogc(&free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (!ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);
		zval_ptr_dtor_nogc(&free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPZNZ_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);
		zval_ptr_dtor_nogc(&free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (EXPECTED(retval != 0)) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on true to %d\n", opline->extended_value);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	} else {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on false to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
}

static int ZEND_FASTCALL  ZEND_JMPZ_EX_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);
		zval_ptr_dtor_nogc(&free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (!retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_EX_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);
		zval_ptr_dtor_nogc(&free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FREE_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_VAR == IS_TMP_VAR) {
		zendi_zval_dtor(EX_T(opline->op1.var).tmp_var);
	} else {
		zval_ptr_dtor(&EX_T(opline->op1.var).var.ptr);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_RETURN_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zend_free_op free_op1;

	SAVE_OPLINE();
	retval_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (!EG(return_value_ptr_ptr)) {
		zval_ptr_dtor_nogc(&free_op1.var);
	} else {
		if (IS_VAR == IS_CONST ||
		    IS_VAR == IS_TMP_VAR ||
		    PZVAL_IS_REF(retval_ptr)) {
			zval *ret;

			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, retval_ptr);
			if (IS_VAR != IS_TMP_VAR) {
				zval_copy_ctor(ret);
			}
			*EG(return_value_ptr_ptr) = ret;
			zval_ptr_dtor_nogc(&free_op1.var);
		} else if ((IS_VAR == IS_CV || IS_VAR == IS_VAR) &&
		           retval_ptr == &EG(uninitialized_zval)) {
			zval *ret;

			if (IS_VAR == IS_VAR) {
				Z_DELREF_P(retval_ptr);
			}
			ALLOC_INIT_ZVAL(ret);
			*EG(return_value_ptr_ptr) = ret;
		} else {
			*EG(return_value_ptr_ptr) = retval_ptr;
			if (IS_VAR == IS_CV) {
				Z_ADDREF_P(retval_ptr);
			}
		}
	}
	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval **retval_ptr_ptr;
	zend_free_op free_op1;

	SAVE_OPLINE();

	do {
		if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR ||
		    (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			if (!EG(return_value_ptr_ptr)) {
				if (IS_VAR == IS_TMP_VAR) {
					zval_ptr_dtor_nogc(&free_op1.var);
				}
			} else if (!0) { /* Not a temp var */
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				zval_copy_ctor(ret);
				*EG(return_value_ptr_ptr) = ret;
			} else {
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				*EG(return_value_ptr_ptr) = ret;
			}
			break;
		}

		retval_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(retval_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot return string offsets by reference");
		}

		if (IS_VAR == IS_VAR && !Z_ISREF_PP(retval_ptr_ptr)) {
			if (opline->extended_value == ZEND_RETURNS_FUNCTION &&
			    EX_T(opline->op1.var).var.fcall_returned_reference) {
			} else if (EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EG(return_value_ptr_ptr)) {
					zval *ret;

					ALLOC_ZVAL(ret);
					INIT_PZVAL_COPY(ret, *retval_ptr_ptr);
					zval_copy_ctor(ret);
					*EG(return_value_ptr_ptr) = ret;
				}
				break;
			}
		}

		if (EG(return_value_ptr_ptr)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr_ptr);
			Z_ADDREF_PP(retval_ptr_ptr);

			*EG(return_value_ptr_ptr) = *retval_ptr_ptr;
		}
	} while (0);

	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_THROW_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *exception;
	zend_free_op free_op1;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Can only throw objects");
	}

	zend_exception_save(TSRMLS_C);
	/* Not sure if a complete copy is what we want here */
	ALLOC_ZVAL(exception);
	INIT_PZVAL_COPY(exception, value);
	if (!0) {
		zval_copy_ctor(exception);
	}

	zend_throw_exception_object(exception TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);
	zval_ptr_dtor_nogc(&free_op1.var);
	HANDLE_EXCEPTION();
}

static int ZEND_FASTCALL zend_send_by_var_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr;
	zend_free_op free_op1;
	varptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (varptr == &EG(uninitialized_zval)) {
		if (IS_VAR == IS_VAR) {
			Z_DELREF_P(varptr);
		}
		ALLOC_INIT_ZVAL(varptr);
	} else if (PZVAL_IS_REF(varptr)) {
		if (IS_VAR == IS_CV ||
		    (IS_VAR == IS_VAR && Z_REFCOUNT_P(varptr) > 2)) {
			zval *original_var = varptr;

			ALLOC_ZVAL(varptr);
			INIT_PZVAL_COPY(varptr, original_var);
			zval_copy_ctor(varptr);
			zval_ptr_dtor_nogc(&free_op1.var);
		} else {
			Z_UNSET_ISREF_P(varptr);
		}
	} else if (IS_VAR == IS_CV) {
		Z_ADDREF_P(varptr);
	}
	zend_vm_stack_push(varptr TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varptr;

	SAVE_OPLINE();
	if (opline->extended_value & ZEND_ARG_COMPILE_TIME_BOUND) { /* Had function_ptr at compile_time */
		if (!(opline->extended_value & ZEND_ARG_SEND_BY_REF)) {
			return zend_send_by_var_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	} else {
		if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.num)) {
			return zend_send_by_var_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	}

	varptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if ((!(opline->extended_value & ZEND_ARG_SEND_FUNCTION) ||
	     EX_T(opline->op1.var).var.fcall_returned_reference) &&
	    varptr != &EG(uninitialized_zval) &&
	    (PZVAL_IS_REF(varptr) || Z_REFCOUNT_P(varptr) == 1)) {
		Z_SET_ISREF_P(varptr);
		if (IS_VAR == IS_CV) {
			Z_ADDREF_P(varptr);
		}
		zend_vm_stack_push(varptr TSRMLS_CC);
	} else {
		zval *valptr;

		if ((opline->extended_value & ZEND_ARG_COMPILE_TIME_BOUND) ?
			!(opline->extended_value & ZEND_ARG_SEND_SILENT) :
			!ARG_MAY_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.num)) {
			zend_error(E_STRICT, "Only variables should be passed by reference");
		}
		ALLOC_ZVAL(valptr);
		INIT_PZVAL_COPY(valptr, varptr);
		if (!0) {
			zval_copy_ctor(valptr);
		}
		zval_ptr_dtor_nogc(&free_op1.var);
		zend_vm_stack_push(valptr TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SEND_REF_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **varptr_ptr;
	zval *varptr;

	SAVE_OPLINE();
	varptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(varptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Only variables can be passed by reference");
	}

	if (IS_VAR == IS_VAR && UNEXPECTED(*varptr_ptr == &EG(error_zval))) {
		ALLOC_INIT_ZVAL(varptr);
		zend_vm_stack_push(varptr TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	if (opline->extended_value == ZEND_DO_FCALL_BY_NAME &&
	    EX(function_state).function->type == ZEND_INTERNAL_FUNCTION) {
		if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.num)) {
			return zend_send_by_var_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	}

	SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr_ptr);
	varptr = *varptr_ptr;
	Z_ADDREF_P(varptr);
	zend_vm_stack_push(varptr TSRMLS_CC);

	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SEND_VAR_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (opline->extended_value == ZEND_DO_FCALL_BY_NAME) {
		if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.num)) {
			return ZEND_SEND_REF_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	}
	SAVE_OPLINE();
	return zend_send_by_var_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_BOOL_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *retval = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	/* PHP 3.0 returned "" for false and 1 for true, here we use 0 and 1 for now */
	ZVAL_BOOL(retval, i_zend_is_true(_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC)));
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SWITCH_FREE_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	zval_ptr_dtor(&EX_T(opline->op1.var).var.ptr);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CLONE_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		Z_OBJVAL_P(retval) = clone_call(obj TSRMLS_CC);
		Z_TYPE_P(retval) = IS_OBJECT;
		Z_SET_REFCOUNT_P(retval, 1);
		Z_SET_ISREF_P(retval);
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&retval);
		} else {
			EX_T(opline->result.var).var.ptr = retval;
		}
	}
	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CAST_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	expr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (opline->extended_value != IS_STRING) {
		ZVAL_COPY_VALUE(result, expr);
		if (!0) {
			zendi_zval_copy_ctor(*result);
		}
	}
	switch (opline->extended_value) {
		case IS_NULL:
			convert_to_null(result);
			break;
		case IS_BOOL:
			convert_to_boolean(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		case IS_DOUBLE:
			convert_to_double(result);
			break;
		case IS_STRING: {
			zval var_copy;
			int use_copy;

			zend_make_printable_zval(expr, &var_copy, &use_copy);
			if (use_copy) {
				ZVAL_COPY_VALUE(result, &var_copy);
				if (0) {
					zval_ptr_dtor_nogc(&free_op1.var);
				}
			} else {
				ZVAL_COPY_VALUE(result, expr);
				if (!0) {
					zendi_zval_copy_ctor(*result);
				}
			}
			break;
		}
		case IS_ARRAY:
			convert_to_array(result);
			break;
		case IS_OBJECT:
			convert_to_object(result);
			break;
	}
	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_op_array *new_op_array=NULL;
	zend_free_op free_op1;
	zval *inc_filename;
	zval *tmp_inc_filename = NULL;
	zend_bool failure_retval=0;

	SAVE_OPLINE();
	inc_filename = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (inc_filename->type!=IS_STRING) {
		MAKE_STD_ZVAL(tmp_inc_filename);
		ZVAL_COPY_VALUE(tmp_inc_filename, inc_filename);
		zval_copy_ctor(tmp_inc_filename);
		convert_to_string(tmp_inc_filename);
		inc_filename = tmp_inc_filename;
	}

	if (opline->extended_value != ZEND_EVAL && strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)) {
		if (opline->extended_value == ZEND_INCLUDE_ONCE || opline->extended_value == ZEND_INCLUDE) {
			zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		} else {
			zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		}
	} else {
		switch (opline->extended_value) {
			case ZEND_INCLUDE_ONCE:
			case ZEND_REQUIRE_ONCE: {
					zend_file_handle file_handle;
					char *resolved_path;

					resolved_path = zend_resolve_path(Z_STRVAL_P(inc_filename), Z_STRLEN_P(inc_filename) TSRMLS_CC);
					if (resolved_path) {
						failure_retval = zend_hash_exists(&EG(included_files), resolved_path, strlen(resolved_path)+1);
					} else {
						resolved_path = Z_STRVAL_P(inc_filename);
					}

					if (failure_retval) {
						/* do nothing, file already included */
					} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {

						if (!file_handle.opened_path) {
							file_handle.opened_path = estrdup(resolved_path);
						}

						if (zend_hash_add_empty_element(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path)+1)==SUCCESS) {
							new_op_array = zend_compile_file(&file_handle, (opline->extended_value==ZEND_INCLUDE_ONCE?ZEND_INCLUDE:ZEND_REQUIRE) TSRMLS_CC);
							zend_destroy_file_handle(&file_handle TSRMLS_CC);
						} else {
							zend_file_handle_dtor(&file_handle TSRMLS_CC);
							failure_retval=1;
						}
					} else {
						if (opline->extended_value == ZEND_INCLUDE_ONCE) {
							zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						} else {
							zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						}
					}
					if (resolved_path != Z_STRVAL_P(inc_filename)) {
						efree(resolved_path);
					}
				}
				break;
			case ZEND_INCLUDE:
			case ZEND_REQUIRE:
				new_op_array = compile_filename(opline->extended_value, inc_filename TSRMLS_CC);
				break;
			case ZEND_EVAL: {
					char *eval_desc = zend_make_compiled_string_description("eval()'d code" TSRMLS_CC);

					new_op_array = zend_compile_string(inc_filename, eval_desc TSRMLS_CC);
					efree(eval_desc);
				}
				break;
			EMPTY_SWITCH_DEFAULT_CASE()
		}
	}
	if (tmp_inc_filename) {
		zval_ptr_dtor(&tmp_inc_filename);
	}
	zval_ptr_dtor_nogc(&free_op1.var);
	if (UNEXPECTED(EG(exception) != NULL)) {
		HANDLE_EXCEPTION();
	} else if (EXPECTED(new_op_array != NULL)) {
		EX(original_return_value) = EG(return_value_ptr_ptr);
		EG(active_op_array) = new_op_array;
		if (RETURN_VALUE_USED(opline)) {
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			EG(return_value_ptr_ptr) = EX_T(opline->result.var).var.ptr_ptr;
		} else {
			EG(return_value_ptr_ptr) = NULL;
		}

		EX(function_state).function = (zend_function *) new_op_array;
		EX(object) = NULL;

		if (!EG(active_symbol_table)) {
			zend_rebuild_symbol_table(TSRMLS_C);
		}

		if (EXPECTED(zend_execute_ex == execute_ex)) {
			ZEND_VM_ENTER();
		} else {
			zend_execute(new_op_array TSRMLS_CC);
		}

		EX(function_state).function = (zend_function *) EX(op_array);

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		EG(return_value_ptr_ptr) = EX(original_return_value);
		destroy_op_array(new_op_array TSRMLS_CC);
		efree(new_op_array);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}

	} else if (RETURN_VALUE_USED(opline)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		ZVAL_BOOL(retval, failure_retval);
		INIT_PZVAL(retval);
		EX_T(opline->result.var).var.ptr = retval;
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FE_RESET_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *array_ptr, **array_ptr_ptr;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;
	zend_class_entry *ce = NULL;
	zend_bool is_empty = 0;

	SAVE_OPLINE();

	if ((IS_VAR == IS_CV || IS_VAR == IS_VAR) &&
	    (opline->extended_value & ZEND_FE_RESET_VARIABLE)) {
		array_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (array_ptr_ptr == NULL || array_ptr_ptr == &EG(uninitialized_zval_ptr)) {
			MAKE_STD_ZVAL(array_ptr);
			ZVAL_NULL(array_ptr);
		} else if (Z_TYPE_PP(array_ptr_ptr) == IS_OBJECT) {
			if(Z_OBJ_HT_PP(array_ptr_ptr)->get_class_entry == NULL) {
				zend_error(E_WARNING, "foreach() cannot iterate over objects without PHP class");
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}

			ce = Z_OBJCE_PP(array_ptr_ptr);
			if (!ce || ce->get_iterator == NULL) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				Z_ADDREF_PP(array_ptr_ptr);
			}
			array_ptr = *array_ptr_ptr;
		} else {
			if (Z_TYPE_PP(array_ptr_ptr) == IS_ARRAY) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
					Z_SET_ISREF_PP(array_ptr_ptr);
				}
			}
			array_ptr = *array_ptr_ptr;
			Z_ADDREF_P(array_ptr);
		}
	} else {
		array_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* IS_TMP_VAR */
			zval *tmp;

			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			array_ptr = tmp;
			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
				ce = Z_OBJCE_P(array_ptr);
				if (ce && ce->get_iterator) {
					Z_DELREF_P(array_ptr);
				}
			}
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			ce = Z_OBJCE_P(array_ptr);
			if (!ce || !ce->get_iterator) {
				if (IS_VAR == IS_CV) {
					Z_ADDREF_P(array_ptr);
				}
			}
		} else if (IS_VAR == IS_CONST ||
		           (IS_VAR == IS_CV &&
		            !Z_ISREF_P(array_ptr) &&
		            Z_REFCOUNT_P(array_ptr) > 1) ||
		           (IS_VAR == IS_VAR &&
		            !Z_ISREF_P(array_ptr) &&
		            Z_REFCOUNT_P(array_ptr) > 2)) {
			zval *tmp;

			if (IS_VAR == IS_VAR) {
				Z_DELREF_P(array_ptr);
			}
			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			zval_copy_ctor(tmp);
			array_ptr = tmp;
		} else if (IS_VAR == IS_CV) {
			Z_ADDREF_P(array_ptr);
		}
	}

	if (ce && ce->get_iterator) {
		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);

		if (IS_VAR == IS_VAR && !(opline->extended_value & ZEND_FE_RESET_VARIABLE)) {
			zval_ptr_dtor_nogc(&free_op1.var);
		}
		if (iter && EXPECTED(EG(exception) == NULL)) {
			array_ptr = zend_iterator_wrap(iter TSRMLS_CC);
		} else {
			if (IS_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {
				if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
			}
			if (!EG(exception)) {
				zend_throw_exception_ex(NULL, 0 TSRMLS_CC, "Object of type %s did not create an Iterator", ce->name);
			}
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}
	}

	EX_T(opline->result.var).fe.ptr = array_ptr;

	if (iter) {
		iter->index = 0;
		if (iter->funcs->rewind) {
			iter->funcs->rewind(iter TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(&array_ptr);
				if (IS_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {
					if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
				}
				HANDLE_EXCEPTION();
			}
		}
		is_empty = iter->funcs->valid(iter TSRMLS_CC) != SUCCESS;
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&array_ptr);
			if (IS_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {
				if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
			}
			HANDLE_EXCEPTION();
		}
		iter->index = -1; /* will be set to 0 before using next handler */
	} else if ((fe_ht = HASH_OF(array_ptr)) != NULL) {
		zend_hash_internal_pointer_reset(fe_ht);
		if (ce) {
			zend_object *zobj = zend_objects_get_address(array_ptr TSRMLS_CC);
			while (zend_hash_has_more_elements(fe_ht) == SUCCESS) {
				char *str_key;
				uint str_key_len;
				ulong int_key;
				zend_uchar key_type;

				key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, NULL);
				if (key_type != HASH_KEY_NON_EXISTENT &&
					(key_type == HASH_KEY_IS_LONG ||
				     zend_check_property_access(zobj, str_key, str_key_len-1 TSRMLS_CC) == SUCCESS)) {
					break;
				}
				zend_hash_move_forward(fe_ht);
			}
		}
		is_empty = zend_hash_has_more_elements(fe_ht) != SUCCESS;
		zend_hash_get_pointer(fe_ht, &EX_T(opline->result.var).fe.fe_pos);
	} else {
		zend_error(E_WARNING, "Invalid argument supplied for foreach()");
		is_empty = 1;
	}

	if (IS_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	}
	if (is_empty) {
		ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
	} else {
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_FE_FETCH_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *array = EX_T(opline->op1.var).fe.ptr;
	zval **value;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;

	zval *key = NULL;
	if (opline->extended_value & ZEND_FE_FETCH_WITH_KEY) {
		key = &EX_T((opline+1)->result.var).tmp_var;
	}

	SAVE_OPLINE();

	switch (zend_iterator_unwrap(array, &iter TSRMLS_CC)) {
		default:
		case ZEND_ITER_INVALID:
			zend_error(E_WARNING, "Invalid argument supplied for foreach()");
			ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);

		case ZEND_ITER_PLAIN_OBJECT: {
			zend_object *zobj = zend_objects_get_address(array TSRMLS_CC);
			int key_type;
			char *str_key;
			zend_uint str_key_len;
			zend_ulong int_key;

			fe_ht = Z_OBJPROP_P(array);
			zend_hash_set_pointer(fe_ht, &EX_T(opline->op1.var).fe.fe_pos);
			do {
				if (zend_hash_get_current_data(fe_ht, (void **) &value)==FAILURE) {
					/* reached end of iteration */
					ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
				}
				key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, NULL);

				zend_hash_move_forward(fe_ht);
			} while (key_type != HASH_KEY_IS_LONG &&
			         zend_check_property_access(zobj, str_key, str_key_len - 1 TSRMLS_CC) != SUCCESS);

			if (key) {
				if (key_type == HASH_KEY_IS_LONG) {
					ZVAL_LONG(key, int_key);
				} else {
					const char *class_name, *prop_name;
					int prop_name_len;
					zend_unmangle_property_name_ex(
						str_key, str_key_len - 1, &class_name, &prop_name, &prop_name_len
					);
					ZVAL_STRINGL(key, prop_name, prop_name_len, 1);
				}
			}

			zend_hash_get_pointer(fe_ht, &EX_T(opline->op1.var).fe.fe_pos);
			break;
		}

		case ZEND_ITER_PLAIN_ARRAY:
			fe_ht = Z_ARRVAL_P(array);
			zend_hash_set_pointer(fe_ht, &EX_T(opline->op1.var).fe.fe_pos);
			if (zend_hash_get_current_data(fe_ht, (void **) &value)==FAILURE) {
				/* reached end of iteration */
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}
			if (key) {
				zend_hash_get_current_key_zval(fe_ht, key);
			}
			zend_hash_move_forward(fe_ht);
			zend_hash_get_pointer(fe_ht, &EX_T(opline->op1.var).fe.fe_pos);
			break;

		case ZEND_ITER_OBJECT:
			/* !iter happens from exception */
			if (iter && ++iter->index > 0) {
				/* This could cause an endless loop if index becomes zero again.
				 * In case that ever happens we need an additional flag. */
				iter->funcs->move_forward(iter TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					zval_ptr_dtor(&array);
					HANDLE_EXCEPTION();
				}
			}
			/* If index is zero we come from FE_RESET and checked valid() already. */
			if (!iter || (iter->index > 0 && iter->funcs->valid(iter TSRMLS_CC) == FAILURE)) {
				/* reached end of iteration */
				if (UNEXPECTED(EG(exception) != NULL)) {
					zval_ptr_dtor(&array);
					HANDLE_EXCEPTION();
				}
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}
			iter->funcs->get_current_data(iter, &value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(&array);
				HANDLE_EXCEPTION();
			}
			if (!value) {
				/* failure in get_current_data */
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}
			if (key) {
				if (iter->funcs->get_current_key) {
					iter->funcs->get_current_key(iter, key TSRMLS_CC);
					if (UNEXPECTED(EG(exception) != NULL)) {
						zval_ptr_dtor(&array);
						HANDLE_EXCEPTION();
					}
				} else {
					ZVAL_LONG(key, iter->index);
				}
			}
			break;
	}

	if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
		SEPARATE_ZVAL_IF_NOT_REF(value);
		Z_SET_ISREF_PP(value);
		EX_T(opline->result.var).var.ptr_ptr = value;
		Z_ADDREF_PP(value);
	} else {
		PZVAL_LOCK(*value);
		EX_T(opline->result.var).var.ptr = *value;
	}

	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_EXIT_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0 || (IS_VAR != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;
		zval *ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}
		zval_ptr_dtor_nogc(&free_op1.var);
	}
#endif
	zend_bailout();
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

static int ZEND_FASTCALL  ZEND_JMP_SET_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (i_zend_is_true(value)) {
		ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
		if (!0) {
			zendi_zval_copy_ctor(EX_T(opline->result.var).tmp_var);
		}
		zval_ptr_dtor_nogc(&free_op1.var);
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value, *ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (i_zend_is_true(value)) {
		if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
			Z_ADDREF_P(value);
			EX_T(opline->result.var).var.ptr = value;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		} else {
			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, value);
			EX_T(opline->result.var).var.ptr = ret;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			if (!0) {
				zval_copy_ctor(EX_T(opline->result.var).var.ptr);
			}
		}
		zval_ptr_dtor_nogc(&free_op1.var);
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
	if (!0) {
		zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
	}
	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value, *ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		Z_ADDREF_P(value);
		EX_T(opline->result.var).var.ptr = value;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	} else {
		ALLOC_ZVAL(ret);
		INIT_PZVAL_COPY(ret, value);
		EX_T(opline->result.var).var.ptr = ret;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		if (!0) {
			zval_copy_ctor(EX_T(opline->result.var).var.ptr);
		}
	}

	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INSTANCEOF_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (Z_TYPE_P(expr) == IS_OBJECT && Z_OBJ_HT_P(expr)->get_class_entry) {
		result = instanceof_function(Z_OBJCE_P(expr), EX_T(opline->op2.var).class_entry TSRMLS_CC);
	} else {
		result = 0;
	}
	ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, result);
	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *object;
	zval *property = opline->op2.zv;
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_VAR_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = opline->op2.zv;

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_CONST, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = opline->op2.zv;
			var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}

		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CONST(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CONST(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CONST(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CONST(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CONST(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CONST(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CONST(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CONST(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CONST(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CONST(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CONST(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_VAR_CONST(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = opline->op2.zv;
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					*retval = &EG(uninitialized_zval);
				}
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				incdec_op(*zptr);
				if (RETURN_VALUE_USED(opline)) {
					*retval = *zptr;
					PZVAL_LOCK(*retval);
				}
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_CONST(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_CONST(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_VAR_CONST(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = opline->op2.zv;
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				ZVAL_NULL(retval);
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				ZVAL_COPY_VALUE(retval, *zptr);
				zendi_zval_copy_ctor(*retval);

				incdec_op(*zptr);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z, *z_copy;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_CONST(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_CONST(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_VAR_CONST(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

 	if (IS_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_VAR != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}
					zval_ptr_dtor_nogc(&free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
		zval_ptr_dtor_nogc(&free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_VAR == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else {
			hash_value = str_hash(Z_STRVAL_P(varname), Z_STRLEN_P(varname));
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_VAR != IS_TMP_VAR) {
					zval_ptr_dtor_nogc(&free_op1.var);
				}
				break;
			case ZEND_FETCH_LOCAL:
				zval_ptr_dtor_nogc(&free_op1.var);
				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_VAR == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_VAR != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			EX_T(opline->result.var).var.ptr = *retval;
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_CONST(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_CONST(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_CONST(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	return zend_fetch_var_address_helper_SPEC_VAR_CONST(zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC) ? BP_VAR_W : BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_CONST(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_CONST(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);

	if (IS_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_ptr_dtor_nogc(&free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_W TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_RW TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_IS TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_W TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	} else {
		zval *container;

		if (IS_CONST == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);

		zval_ptr_dtor_nogc(&free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_UNSET TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_VAR_CONST(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_VAR_CONST(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = opline->op2.zv;

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = opline->op2.zv;
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = opline->op2.zv;
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_VAR_CONST(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = opline->op2.zv;

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property_name = opline->op2.zv;

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {

		zval *property_name = opline->op2.zv;

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {

		}
	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = opline->op2.zv;
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_CONST, BP_VAR_W TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					EX_T(opline->result.var).var.ptr = retval;
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				EX_T(opline->result.var).var.ptr = value;
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = opline->op2.zv;
	variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_CONST TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				EX_T(opline->result.var).var.ptr = retval;
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else if (IS_VAR == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		if (IS_CONST == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_CONST == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			EX_T(opline->result.var).var.ptr = value;
		}
	}

	if (IS_VAR == IS_VAR && (free_op1.var != NULL)) {
		zval_ptr_dtor_nogc(&value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = opline->op2.zv;

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CONST != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CONST == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_CONST == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_VAR != IS_CONST &&
	           IS_CONST == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_CONST != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;


		if (IS_CONST == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = opline->op2.zv;

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_CONST == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_VAR == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_CONST != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 opline->op2.zv TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_CONSTANT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_VAR == IS_UNUSED) {
		zend_constant *c;
		zval *retval;

		if (CACHED_PTR(opline->op2.literal->cache_slot)) {
			c = CACHED_PTR(opline->op2.literal->cache_slot);
		} else if ((c = zend_quick_get_constant(opline->op2.literal + 1, opline->extended_value TSRMLS_CC)) == NULL) {
			if ((opline->extended_value & IS_CONSTANT_UNQUALIFIED) != 0) {
				char *actual = (char *)zend_memrchr(Z_STRVAL_P(opline->op2.zv), '\\', Z_STRLEN_P(opline->op2.zv));
				if(!actual) {
					actual = Z_STRVAL_P(opline->op2.zv);
				} else {
					actual++;
				}
				/* non-qualified constant - allow text substitution */
				zend_error(E_NOTICE, "Use of undefined constant %s - assumed '%s'", actual, actual);
				ZVAL_STRINGL(&EX_T(opline->result.var).tmp_var, actual, Z_STRLEN_P(opline->op2.zv)-(actual - Z_STRVAL_P(opline->op2.zv)), 1);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else {
				zend_error_noreturn(E_ERROR, "Undefined constant '%s'", Z_STRVAL_P(opline->op2.zv));
			}
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, c);
		}
		retval = &EX_T(opline->result.var).tmp_var;
		ZVAL_COPY_VALUE(retval, &c->value);
		zval_copy_ctor(retval);
	} else {
		/* class constant */
		zend_class_entry *ce;
		zval **value;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				value = CACHED_PTR(opline->op2.literal->cache_slot);
				ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
				zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
				goto constant_fetch_end;
			} else if (CACHED_PTR(opline->op1.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op1.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
				}
				CACHE_PTR(opline->op1.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op1.var).class_entry;
			if ((value = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce)) != NULL) {
				ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
				zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
				goto constant_fetch_end;
			}
		}

		if (EXPECTED(zend_hash_quick_find(&ce->constants_table, Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv)+1, Z_HASH_P(opline->op2.zv), (void **) &value) == SUCCESS)) {
			if (IS_CONSTANT_TYPE(Z_TYPE_PP(value))) {
				zend_class_entry *old_scope = EG(scope);

				EG(scope) = ce;
				zval_update_constant(value, 1 TSRMLS_CC);
				EG(scope) = old_scope;
			}
			if (IS_VAR == IS_CONST) {
				CACHE_PTR(opline->op2.literal->cache_slot, value);
			} else {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, value);
			}
			ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
			zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
		} else if (Z_STRLEN_P(opline->op2.zv) == sizeof("class")-1 && memcmp(Z_STRVAL_P(opline->op2.zv), "class", sizeof("class") - 1) == 0) {
			/* "class" is assigned as a case-sensitive keyword from zend_do_resolve_class_name */
			ZVAL_STRINGL(&EX_T(opline->result.var).tmp_var, ce->name, ce->name_length, 1);
		} else {
			zend_error_noreturn(E_ERROR, "Undefined class constant '%s'", Z_STRVAL_P(opline->op2.zv));
		}
	}
constant_fetch_end:
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
			zval_ptr_dtor_nogc(&free_op1.var);
		} else if (IS_VAR == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CONST != IS_UNUSED) {

		zval *offset = opline->op2.zv;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CONST == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_VAR != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
						zval_ptr_dtor(&varname);
					}
					zval_ptr_dtor_nogc(&free_op1.var);
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_VAR != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		zval_ptr_dtor(&varname);
	}
	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = opline->op2.zv;

	if (IS_VAR != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_CONST == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
							hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim:
						zend_hash_index_del(ht, hval);
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}

				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {

				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:

				break;
		}
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = opline->op2.zv;

	if (IS_VAR != IS_VAR || container) {
		if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {

			}
		} else {

		}
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_CONST != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_CONST == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_ptr_dtor_nogc(&free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = opline->op2.zv;

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_P(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_CONST == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}

	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container) && Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}

	} else {

	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

				if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
				zval_ptr_dtor_nogc(&free_op1.var);
			} else {
				if (IS_VAR == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CONST(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *object;
	zval *property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_dtor(free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (1) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (1) {
			zval_ptr_dtor(&property);
		} else {
			zval_dtor(free_op2.var);
		}
		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_VAR_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_TMP_VAR, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
			var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
		zval_dtor(free_op2.var);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}
	zval_dtor(free_op2.var);

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_TMP(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_TMP(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_TMP(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_TMP(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_TMP(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_TMP(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_TMP(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_TMP(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_TMP(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_TMP(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_TMP(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_VAR_TMP(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					*retval = &EG(uninitialized_zval);
				}
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				incdec_op(*zptr);
				if (RETURN_VALUE_USED(opline)) {
					*retval = *zptr;
					PZVAL_LOCK(*retval);
				}
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_TMP(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_TMP(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_VAR_TMP(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		ZVAL_NULL(retval);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				ZVAL_NULL(retval);
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				ZVAL_COPY_VALUE(retval, *zptr);
				zendi_zval_copy_ctor(*retval);

				incdec_op(*zptr);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z, *z_copy;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_TMP(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_TMP(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_ptr_dtor_nogc(&free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_W TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_RW TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_IS TSRMLS_CC);
	zval_dtor(free_op2.var);
	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_W TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
		zval_dtor(free_op2.var);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	} else {
		zval *container;

		if (IS_TMP_VAR == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
		zval_dtor(free_op2.var);
		zval_ptr_dtor_nogc(&free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_UNSET TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_VAR_TMP(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		zval_dtor(free_op2.var);
	} else {
		zval *retval;

		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	}

	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_VAR_TMP(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		zval_dtor(free_op2.var);
	} else {
		zval *retval;

		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	}

	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (1) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (1) {
			zval_ptr_dtor(&property);
		} else {
			zval_dtor(free_op2.var);
		}
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_VAR_TMP(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property_name);
	} else {
		zval_dtor(free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {
		zend_free_op free_op2;
		zval *property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (1) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (1) {
			zval_ptr_dtor(&property_name);
		} else {
			zval_dtor(free_op2.var);
		}
	} else {
		zend_free_op free_op2, free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_TMP_VAR, BP_VAR_W TSRMLS_CC);
		zval_dtor(free_op2.var);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					EX_T(opline->result.var).var.ptr = retval;
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				EX_T(opline->result.var).var.ptr = value;
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_TMP_VAR TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				EX_T(opline->result.var).var.ptr = retval;
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else if (IS_VAR == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (1) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		if (IS_TMP_VAR == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_TMP_VAR == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			EX_T(opline->result.var).var.ptr = value;
		}
	}

	if (IS_VAR == IS_VAR && (free_op1.var != NULL)) {
		zval_ptr_dtor_nogc(&value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1, free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_TMP_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_TMP_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_dtor(free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_dtor(free_op2.var);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_TMP_VAR == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_VAR != IS_CONST &&
	           IS_TMP_VAR == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_TMP_VAR != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;
		zend_free_op free_op2;

		if (IS_TMP_VAR == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_TMP_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_VAR == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_TMP_VAR != IS_CONST) {
			zval_dtor(free_op2.var);
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
			zval_ptr_dtor_nogc(&free_op1.var);
		} else if (IS_VAR == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_TMP_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		zval_dtor(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_TMP_VAR == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
							hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim:
						zend_hash_index_del(ht, hval);
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}
				zval_dtor(free_op2.var);
				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (1) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (1) {
					zval_ptr_dtor(&offset);
				} else {
					zval_dtor(free_op2.var);
				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:
				zval_dtor(free_op2.var);
				break;
		}
	} else {
		zval_dtor(free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_VAR || container) {
		if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (1) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (1) {
				zval_ptr_dtor(&offset);
			} else {
				zval_dtor(free_op2.var);
			}
		} else {
			zval_dtor(free_op2.var);
		}
	} else {
		zval_dtor(free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_P(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_TMP_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}
		zval_dtor(free_op2.var);
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container) && Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		zval_dtor(free_op2.var);
	} else {
		zval_dtor(free_op2.var);
	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

				if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
				zval_ptr_dtor_nogc(&free_op1.var);
			} else {
				if (IS_VAR == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!1) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_TMP(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *object;
	zval *property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_ptr_dtor_nogc(&free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_VAR_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_VAR, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
			var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
		zval_ptr_dtor_nogc(&free_op2.var);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}
	zval_ptr_dtor_nogc(&free_op2.var);

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_VAR(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_VAR(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_VAR(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_VAR(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_VAR(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_VAR(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_VAR(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_VAR(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_VAR(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_VAR(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_VAR(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_VAR_VAR(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_ptr_dtor_nogc(&free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					*retval = &EG(uninitialized_zval);
				}
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				incdec_op(*zptr);
				if (RETURN_VALUE_USED(opline)) {
					*retval = *zptr;
					PZVAL_LOCK(*retval);
				}
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_VAR(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_VAR(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_VAR_VAR(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_ptr_dtor_nogc(&free_op2.var);
		ZVAL_NULL(retval);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				ZVAL_NULL(retval);
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				ZVAL_COPY_VALUE(retval, *zptr);
				zendi_zval_copy_ctor(*retval);

				incdec_op(*zptr);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z, *z_copy;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_VAR(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_VAR(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_VAR_VAR(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

 	if (IS_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_VAR != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}
					zval_ptr_dtor_nogc(&free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
		zval_ptr_dtor_nogc(&free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_VAR == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else {
			hash_value = str_hash(Z_STRVAL_P(varname), Z_STRLEN_P(varname));
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_VAR != IS_TMP_VAR) {
					zval_ptr_dtor_nogc(&free_op1.var);
				}
				break;
			case ZEND_FETCH_LOCAL:
				zval_ptr_dtor_nogc(&free_op1.var);
				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_VAR == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_VAR != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			EX_T(opline->result.var).var.ptr = *retval;
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_VAR(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_VAR(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_VAR(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	return zend_fetch_var_address_helper_SPEC_VAR_VAR(zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC) ? BP_VAR_W : BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_VAR(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_VAR(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op2.var);
	if (IS_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_ptr_dtor_nogc(&free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_W TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_RW TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_IS TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op2.var);
	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_W TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
		zval_ptr_dtor_nogc(&free_op2.var);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	} else {
		zval *container;

		if (IS_VAR == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
		zval_ptr_dtor_nogc(&free_op2.var);
		zval_ptr_dtor_nogc(&free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_UNSET TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_VAR_VAR(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	}

	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_VAR_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	}

	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_VAR_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {
		zend_free_op free_op2;
		zval *property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	} else {
		zend_free_op free_op2, free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_VAR, BP_VAR_W TSRMLS_CC);
		zval_ptr_dtor_nogc(&free_op2.var);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					EX_T(opline->result.var).var.ptr = retval;
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				EX_T(opline->result.var).var.ptr = value;
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_VAR TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				EX_T(opline->result.var).var.ptr = retval;
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else if (IS_VAR == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		if (IS_VAR == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_VAR == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			EX_T(opline->result.var).var.ptr = value;
		}
	}

	if (IS_VAR == IS_VAR && (free_op1.var != NULL)) {
		zval_ptr_dtor_nogc(&value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */
 	zval_ptr_dtor_nogc(&free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **variable_ptr_ptr;
	zval **value_ptr_ptr;

	SAVE_OPLINE();
	value_ptr_ptr = _get_zval_ptr_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr)) {
		zend_error_noreturn(E_ERROR, "Cannot assign by reference to overloaded object");
	}

	if (IS_VAR == IS_VAR &&
	    value_ptr_ptr &&
	    !Z_ISREF_PP(value_ptr_ptr) &&
	    opline->extended_value == ZEND_RETURNS_FUNCTION &&
	    !EX_T(opline->op2.var).var.fcall_returned_reference) {
		if (free_op2.var == NULL) {
			PZVAL_LOCK(*value_ptr_ptr); /* undo the effect of get_zval_ptr_ptr() */
		}
		zend_error(E_STRICT, "Only variables should be assigned by reference");
		if (UNEXPECTED(EG(exception) != NULL)) {
			if (free_op2.var) {zval_ptr_dtor_nogc(&free_op2.var);};
			HANDLE_EXCEPTION();
		}
		return ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		PZVAL_LOCK(*value_ptr_ptr);
	}

	variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if ((IS_VAR == IS_VAR && UNEXPECTED(value_ptr_ptr == NULL)) ||
	    (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL))) {
		zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets nor overloaded objects");
	}
	zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr TSRMLS_CC);

	if (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		Z_DELREF_PP(variable_ptr_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*variable_ptr_ptr);
		EX_T(opline->result.var).var.ptr = *variable_ptr_ptr;
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor_nogc(&free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1, free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor_nogc(&free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_ptr_dtor_nogc(&free_op2.var);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_VAR == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_VAR != IS_CONST &&
	           IS_VAR == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_VAR != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;
		zend_free_op free_op2;

		if (IS_VAR == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_VAR == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_VAR != IS_CONST) {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
			zval_ptr_dtor_nogc(&free_op1.var);
		} else if (IS_VAR == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_VAR != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
						zval_ptr_dtor(&varname);
					}
					zval_ptr_dtor_nogc(&free_op1.var);
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_VAR != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		zval_ptr_dtor(&varname);
	}
	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_VAR == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
							hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim:
						zend_hash_index_del(ht, hval);
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}
				zval_ptr_dtor_nogc(&free_op2.var);
				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {
					zval_ptr_dtor_nogc(&free_op2.var);
				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:
				zval_ptr_dtor_nogc(&free_op2.var);
				break;
		}
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_VAR || container) {
		if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {
				zval_ptr_dtor_nogc(&free_op2.var);
			}
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_VAR != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_VAR == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_ptr_dtor_nogc(&free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_P(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}
		zval_ptr_dtor_nogc(&free_op2.var);
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container) && Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

				if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
				zval_ptr_dtor_nogc(&free_op1.var);
			} else {
				if (IS_VAR == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);
	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_VAR(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *object;
	zval *property = NULL;
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_VAR_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = NULL;

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_UNUSED, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = NULL;
			var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}

		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_VAR_UNUSED(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

 	if (IS_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_VAR != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}
					zval_ptr_dtor_nogc(&free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
		zval_ptr_dtor_nogc(&free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_VAR == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else {
			hash_value = str_hash(Z_STRVAL_P(varname), Z_STRLEN_P(varname));
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_VAR != IS_TMP_VAR) {
					zval_ptr_dtor_nogc(&free_op1.var);
				}
				break;
			case ZEND_FETCH_LOCAL:
				zval_ptr_dtor_nogc(&free_op1.var);
				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_VAR == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_VAR != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			EX_T(opline->result.var).var.ptr = *retval;
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC) ? BP_VAR_W : BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_W TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_RW TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_W TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	} else {
		zval *container;

		if (IS_UNUSED == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_R TSRMLS_CC);

		zval_ptr_dtor_nogc(&free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {

		zval *property_name = NULL;

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {

		}
	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = NULL;
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_UNUSED, BP_VAR_W TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					EX_T(opline->result.var).var.ptr = retval;
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				EX_T(opline->result.var).var.ptr = value;
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_UNUSED == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_VAR != IS_CONST &&
	           IS_UNUSED == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_UNUSED != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;


		if (IS_UNUSED == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = NULL;

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_UNUSED == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_UNUSED == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_VAR == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_UNUSED != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
			zval_ptr_dtor_nogc(&free_op1.var);
		} else if (IS_VAR == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_UNUSED != IS_UNUSED) {

		zval *offset = NULL;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_UNUSED == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_VAR != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
						zval_ptr_dtor(&varname);
					}
					zval_ptr_dtor_nogc(&free_op1.var);
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_VAR != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		zval_ptr_dtor(&varname);
	}
	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_UNUSED != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_UNUSED == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_ptr_dtor_nogc(&free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SEPARATE_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr, *new_zv;

	SAVE_OPLINE();
	var_ptr = EX_T(opline->op1.var).var.ptr;
	if (Z_TYPE_P(var_ptr) != IS_OBJECT &&
			!PZVAL_IS_REF(var_ptr) &&
			Z_REFCOUNT_P(var_ptr) > 1) {

		Z_DELREF_P(var_ptr);
		ALLOC_ZVAL(new_zv);
		INIT_PZVAL_COPY(new_zv, var_ptr);
		var_ptr = new_zv;
		zval_copy_ctor(var_ptr);
		EX_T(opline->op1.var).var.ptr = var_ptr;
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

				if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
				zval_ptr_dtor_nogc(&free_op1.var);
			} else {
				if (IS_VAR == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_VAR_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *object;
	zval *property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_VAR_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_CV, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
			var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}

		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CV(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CV(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CV(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CV(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CV(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CV(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CV(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CV(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CV(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CV(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CV(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_VAR_CV(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					*retval = &EG(uninitialized_zval);
				}
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				incdec_op(*zptr);
				if (RETURN_VALUE_USED(opline)) {
					*retval = *zptr;
					PZVAL_LOCK(*retval);
				}
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_CV(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_CV(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_VAR_CV(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				ZVAL_NULL(retval);
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				ZVAL_COPY_VALUE(retval, *zptr);
				zendi_zval_copy_ctor(*retval);

				incdec_op(*zptr);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z, *z_copy;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_CV(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_CV(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);

	if (IS_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_ptr_dtor_nogc(&free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_W TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_RW TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_IS TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_W TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	} else {
		zval *container;

		if (IS_CV == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);

		zval_ptr_dtor_nogc(&free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_UNSET TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_VAR_CV(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_VAR_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	zval_ptr_dtor_nogc(&free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_VAR_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {

		zval *property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {

		}
	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_CV, BP_VAR_W TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					EX_T(opline->result.var).var.ptr = retval;
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				EX_T(opline->result.var).var.ptr = value;
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_CV TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				EX_T(opline->result.var).var.ptr = retval;
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else if (IS_VAR == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		if (IS_CV == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_CV == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			EX_T(opline->result.var).var.ptr = value;
		}
	}

	if (IS_VAR == IS_VAR && (free_op1.var != NULL)) {
		zval_ptr_dtor_nogc(&value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **variable_ptr_ptr;
	zval **value_ptr_ptr;

	SAVE_OPLINE();
	value_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr)) {
		zend_error_noreturn(E_ERROR, "Cannot assign by reference to overloaded object");
	}

	if (IS_CV == IS_VAR &&
	    value_ptr_ptr &&
	    !Z_ISREF_PP(value_ptr_ptr) &&
	    opline->extended_value == ZEND_RETURNS_FUNCTION &&
	    !EX_T(opline->op2.var).var.fcall_returned_reference) {
		if (free_op2.var == NULL) {
			PZVAL_LOCK(*value_ptr_ptr); /* undo the effect of get_zval_ptr_ptr() */
		}
		zend_error(E_STRICT, "Only variables should be assigned by reference");
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		return ZEND_ASSIGN_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		PZVAL_LOCK(*value_ptr_ptr);
	}

	variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if ((IS_CV == IS_VAR && UNEXPECTED(value_ptr_ptr == NULL)) ||
	    (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL))) {
		zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets nor overloaded objects");
	}
	zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr TSRMLS_CC);

	if (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		Z_DELREF_PP(variable_ptr_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*variable_ptr_ptr);
		EX_T(opline->result.var).var.ptr = *variable_ptr_ptr;
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CV != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CV == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_CV == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_VAR != IS_CONST &&
	           IS_CV == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_CV != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;


		if (IS_CV == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_CV == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_VAR == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_CV != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
			zval_ptr_dtor_nogc(&free_op1.var);
		} else if (IS_VAR == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CV != IS_UNUSED) {

		zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CV == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_VAR != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_CV == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
							hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim:
						zend_hash_index_del(ht, hval);
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}

				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {

				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:

				break;
		}
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_VAR != IS_VAR || container) {
		if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {

			}
		} else {

		}
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_P(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_CV == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}

	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container) && Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}

	} else {

	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

				if (free_op1.var) {zval_ptr_dtor_nogc(&free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
				zval_ptr_dtor_nogc(&free_op1.var);
			} else {
				if (IS_VAR == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_VAR_CV(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_CLONE_SPEC_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (IS_UNUSED == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		Z_OBJVAL_P(retval) = clone_call(obj TSRMLS_CC);
		Z_TYPE_P(retval) = IS_OBJECT;
		Z_SET_REFCOUNT_P(retval, 1);
		Z_SET_ISREF_P(retval);
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&retval);
		} else {
			EX_T(opline->result.var).var.ptr = retval;
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_EXIT_SPEC_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0 || (IS_UNUSED != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_UNUSED != IS_UNUSED) {

		zval *ptr = NULL;

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}

	}
#endif
	zend_bailout();
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval **object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	zval *object;
	zval *property = opline->op2.zv;
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_UNUSED_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

				if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_UNUSED == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = opline->op2.zv;

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_CONST, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = opline->op2.zv;
			var_ptr = NULL;
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}


		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_UNUSED_CONST(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = opline->op2.zv;
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					*retval = &EG(uninitialized_zval);
				}
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				incdec_op(*zptr);
				if (RETURN_VALUE_USED(opline)) {
					*retval = *zptr;
					PZVAL_LOCK(*retval);
				}
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_CONST(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_CONST(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_UNUSED_CONST(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = opline->op2.zv;
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				ZVAL_NULL(retval);
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				ZVAL_COPY_VALUE(retval, *zptr);
				zendi_zval_copy_ctor(*retval);

				incdec_op(*zptr);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z, *z_copy;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_CONST(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_CONST(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = opline->op2.zv;

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = opline->op2.zv;
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = opline->op2.zv;
		container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = opline->op2.zv;

	if (IS_UNUSED == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property_name = opline->op2.zv;

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {

	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_CHAR_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *str = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_char_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	add_char_to_string(str, str, opline->op2.zv);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *str = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	add_string_to_string(str, str, opline->op2.zv);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;

	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = opline->op2.zv;

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CONST != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CONST == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_UNUSED == IS_UNUSED) {
		zend_constant *c;
		zval *retval;

		if (CACHED_PTR(opline->op2.literal->cache_slot)) {
			c = CACHED_PTR(opline->op2.literal->cache_slot);
		} else if ((c = zend_quick_get_constant(opline->op2.literal + 1, opline->extended_value TSRMLS_CC)) == NULL) {
			if ((opline->extended_value & IS_CONSTANT_UNQUALIFIED) != 0) {
				char *actual = (char *)zend_memrchr(Z_STRVAL_P(opline->op2.zv), '\\', Z_STRLEN_P(opline->op2.zv));
				if(!actual) {
					actual = Z_STRVAL_P(opline->op2.zv);
				} else {
					actual++;
				}
				/* non-qualified constant - allow text substitution */
				zend_error(E_NOTICE, "Use of undefined constant %s - assumed '%s'", actual, actual);
				ZVAL_STRINGL(&EX_T(opline->result.var).tmp_var, actual, Z_STRLEN_P(opline->op2.zv)-(actual - Z_STRVAL_P(opline->op2.zv)), 1);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else {
				zend_error_noreturn(E_ERROR, "Undefined constant '%s'", Z_STRVAL_P(opline->op2.zv));
			}
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, c);
		}
		retval = &EX_T(opline->result.var).tmp_var;
		ZVAL_COPY_VALUE(retval, &c->value);
		zval_copy_ctor(retval);
	} else {
		/* class constant */
		zend_class_entry *ce;
		zval **value;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				value = CACHED_PTR(opline->op2.literal->cache_slot);
				ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
				zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
				goto constant_fetch_end;
			} else if (CACHED_PTR(opline->op1.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op1.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
				}
				CACHE_PTR(opline->op1.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op1.var).class_entry;
			if ((value = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce)) != NULL) {
				ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
				zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
				goto constant_fetch_end;
			}
		}

		if (EXPECTED(zend_hash_quick_find(&ce->constants_table, Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv)+1, Z_HASH_P(opline->op2.zv), (void **) &value) == SUCCESS)) {
			if (IS_CONSTANT_TYPE(Z_TYPE_PP(value))) {
				zend_class_entry *old_scope = EG(scope);

				EG(scope) = ce;
				zval_update_constant(value, 1 TSRMLS_CC);
				EG(scope) = old_scope;
			}
			if (IS_UNUSED == IS_CONST) {
				CACHE_PTR(opline->op2.literal->cache_slot, value);
			} else {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, value);
			}
			ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
			zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
		} else if (Z_STRLEN_P(opline->op2.zv) == sizeof("class")-1 && memcmp(Z_STRVAL_P(opline->op2.zv), "class", sizeof("class") - 1) == 0) {
			/* "class" is assigned as a case-sensitive keyword from zend_do_resolve_class_name */
			ZVAL_STRINGL(&EX_T(opline->result.var).tmp_var, ce->name, ce->name_length, 1);
		} else {
			zend_error_noreturn(E_ERROR, "Undefined class constant '%s'", Z_STRVAL_P(opline->op2.zv));
		}
	}
constant_fetch_end:
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = opline->op2.zv;

	if (IS_UNUSED != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_CONST == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
							hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim:
						zend_hash_index_del(ht, hval);
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}

				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {

				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:

				break;
		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	offset = opline->op2.zv;

	if (IS_UNUSED != IS_VAR || container) {
		if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {

			}
		} else {

		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset = opline->op2.zv;

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_P(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_CONST == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}

	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container) && Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}

	} else {

	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_UNUSED == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data1;
	zval **object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	zval *object;
	zval *property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_dtor(free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (1) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (1) {
			zval_ptr_dtor(&property);
		} else {
			zval_dtor(free_op2.var);
		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_UNUSED_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

				if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_UNUSED == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_TMP_VAR, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
			var_ptr = NULL;
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
		zval_dtor(free_op2.var);

		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}
	zval_dtor(free_op2.var);

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_UNUSED_TMP(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					*retval = &EG(uninitialized_zval);
				}
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				incdec_op(*zptr);
				if (RETURN_VALUE_USED(opline)) {
					*retval = *zptr;
					PZVAL_LOCK(*retval);
				}
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_TMP(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_TMP(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_UNUSED_TMP(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				ZVAL_NULL(retval);
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				ZVAL_COPY_VALUE(retval, *zptr);
				zendi_zval_copy_ctor(*retval);

				incdec_op(*zptr);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z, *z_copy;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_TMP(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_TMP(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		zval_dtor(free_op2.var);
	} else {
		zval *retval;

		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		zval_dtor(free_op2.var);
	} else {
		zval *retval;

		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

		if (1) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (1) {
			zval_ptr_dtor(&property);
		} else {
			zval_dtor(free_op2.var);
		}
		if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property_name);
	} else {
		zval_dtor(free_op2.var);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_VAR_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *str = &EX_T(opline->result.var).tmp_var;
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		zend_make_printable_zval(var, &var_copy, &use_copy);

		if (use_copy) {
			var = &var_copy;
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */
	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_TMP_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_TMP_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_dtor(free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_TMP_VAR == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
							hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim:
						zend_hash_index_del(ht, hval);
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}
				zval_dtor(free_op2.var);
				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (1) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (1) {
					zval_ptr_dtor(&offset);
				} else {
					zval_dtor(free_op2.var);
				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:
				zval_dtor(free_op2.var);
				break;
		}
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED != IS_VAR || container) {
		if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (1) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (1) {
				zval_ptr_dtor(&offset);
			} else {
				zval_dtor(free_op2.var);
			}
		} else {
			zval_dtor(free_op2.var);
		}
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_P(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_TMP_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}
		zval_dtor(free_op2.var);
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container) && Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		zval_dtor(free_op2.var);
	} else {
		zval_dtor(free_op2.var);
	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_UNUSED == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!1) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data1;
	zval **object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	zval *object;
	zval *property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_ptr_dtor_nogc(&free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_UNUSED_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

				if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_UNUSED == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_VAR, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
			var_ptr = NULL;
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
		zval_ptr_dtor_nogc(&free_op2.var);

		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}
	zval_ptr_dtor_nogc(&free_op2.var);

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_UNUSED_VAR(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_ptr_dtor_nogc(&free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					*retval = &EG(uninitialized_zval);
				}
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				incdec_op(*zptr);
				if (RETURN_VALUE_USED(opline)) {
					*retval = *zptr;
					PZVAL_LOCK(*retval);
				}
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_VAR(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_VAR(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_UNUSED_VAR(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_ptr_dtor_nogc(&free_op2.var);
		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				ZVAL_NULL(retval);
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				ZVAL_COPY_VALUE(retval, *zptr);
				zendi_zval_copy_ctor(*retval);

				incdec_op(*zptr);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z, *z_copy;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_VAR(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_VAR(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
		if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_VAR_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *str = &EX_T(opline->result.var).tmp_var;
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		zend_make_printable_zval(var, &var_copy, &use_copy);

		if (use_copy) {
			var = &var_copy;
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */
	zval_ptr_dtor_nogc(&free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor_nogc(&free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_ptr_dtor_nogc(&free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_VAR == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
							hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim:
						zend_hash_index_del(ht, hval);
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}
				zval_ptr_dtor_nogc(&free_op2.var);
				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {
					zval_ptr_dtor_nogc(&free_op2.var);
				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:
				zval_ptr_dtor_nogc(&free_op2.var);
				break;
		}
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED != IS_VAR || container) {
		if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {
				zval_ptr_dtor_nogc(&free_op2.var);
			}
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_P(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}
		zval_ptr_dtor_nogc(&free_op2.var);
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container) && Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_UNUSED == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval **object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	zval *object;
	zval *property = NULL;
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

				if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_UNUSED == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = NULL;

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_UNUSED, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = NULL;
			var_ptr = NULL;
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}


		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_UNUSED == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval **object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	zval *object;
	zval *property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_UNUSED_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

				if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_UNUSED == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_CV, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
			var_ptr = NULL;
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}


		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CV(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CV(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CV(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CV(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CV(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CV(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CV(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CV(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CV(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CV(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CV(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_UNUSED_CV(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					*retval = &EG(uninitialized_zval);
				}
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				incdec_op(*zptr);
				if (RETURN_VALUE_USED(opline)) {
					*retval = *zptr;
					PZVAL_LOCK(*retval);
				}
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_CV(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_CV(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_UNUSED_CV(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				ZVAL_NULL(retval);
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				ZVAL_COPY_VALUE(retval, *zptr);
				zendi_zval_copy_ctor(*retval);

				incdec_op(*zptr);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z, *z_copy;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_CV(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_CV(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_UNUSED_CV(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_UNUSED_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_UNUSED_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_UNUSED == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {

	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_VAR_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *str = &EX_T(opline->result.var).tmp_var;
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		zend_make_printable_zval(var, &var_copy, &use_copy);

		if (use_copy) {
			var = &var_copy;
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;

	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CV != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CV == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_UNUSED != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_CV == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
							hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim:
						zend_hash_index_del(ht, hval);
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}

				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {

				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:

				break;
		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_UNUSED != IS_VAR || container) {
		if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {

			}
		} else {

		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_P(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_CV == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}

	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container) && Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}

	} else {

	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_UNUSED == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_UNUSED_CV(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_BW_NOT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_not_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_NOT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_not_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **var_ptr;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_CV == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_increment_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_increment_function(*var_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **var_ptr;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_CV == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_decrement_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_decrement_function(*var_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **var_ptr, *retval;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_CV == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		ZVAL_NULL(&EX_T(opline->result.var).tmp_var);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	retval = &EX_T(opline->result.var).tmp_var;
	ZVAL_COPY_VALUE(retval, *var_ptr);
	zendi_zval_copy_ctor(*retval);

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_increment_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_increment_function(*var_ptr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_DEC_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **var_ptr, *retval;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_CV == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		ZVAL_NULL(&EX_T(opline->result.var).tmp_var);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	retval = &EX_T(opline->result.var).tmp_var;
	ZVAL_COPY_VALUE(retval, *var_ptr);
	zendi_zval_copy_ctor(*retval);

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_decrement_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_decrement_function(*var_ptr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *z;

	SAVE_OPLINE();
	z = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && Z_TYPE_P(z) == IS_OBJECT) {
		INIT_PZVAL(z);
	}
	zend_print_variable(z);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRINT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZVAL_LONG(&EX_T(opline->result.var).tmp_var, 1);
	return ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_JMPZ_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (!ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPZNZ_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (EXPECTED(retval != 0)) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on true to %d\n", opline->extended_value);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	} else {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on false to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
}

static int ZEND_FASTCALL  ZEND_JMPZ_EX_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (!retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_EX_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_RETURN_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;


	SAVE_OPLINE();
	retval_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (!EG(return_value_ptr_ptr)) {

	} else {
		if (IS_CV == IS_CONST ||
		    IS_CV == IS_TMP_VAR ||
		    PZVAL_IS_REF(retval_ptr)) {
			zval *ret;

			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, retval_ptr);
			if (IS_CV != IS_TMP_VAR) {
				zval_copy_ctor(ret);
			}
			*EG(return_value_ptr_ptr) = ret;

		} else if ((IS_CV == IS_CV || IS_CV == IS_VAR) &&
		           retval_ptr == &EG(uninitialized_zval)) {
			zval *ret;

			if (IS_CV == IS_VAR) {
				Z_DELREF_P(retval_ptr);
			}
			ALLOC_INIT_ZVAL(ret);
			*EG(return_value_ptr_ptr) = ret;
		} else {
			*EG(return_value_ptr_ptr) = retval_ptr;
			if (IS_CV == IS_CV) {
				Z_ADDREF_P(retval_ptr);
			}
		}
	}
	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_RETURN_BY_REF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval **retval_ptr_ptr;


	SAVE_OPLINE();

	do {
		if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR ||
		    (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
			if (!EG(return_value_ptr_ptr)) {
				if (IS_CV == IS_TMP_VAR) {

				}
			} else if (!0) { /* Not a temp var */
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				zval_copy_ctor(ret);
				*EG(return_value_ptr_ptr) = ret;
			} else {
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				*EG(return_value_ptr_ptr) = ret;
			}
			break;
		}

		retval_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(retval_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot return string offsets by reference");
		}

		if (IS_CV == IS_VAR && !Z_ISREF_PP(retval_ptr_ptr)) {
			if (opline->extended_value == ZEND_RETURNS_FUNCTION &&
			    EX_T(opline->op1.var).var.fcall_returned_reference) {
			} else if (EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EG(return_value_ptr_ptr)) {
					zval *ret;

					ALLOC_ZVAL(ret);
					INIT_PZVAL_COPY(ret, *retval_ptr_ptr);
					zval_copy_ctor(ret);
					*EG(return_value_ptr_ptr) = ret;
				}
				break;
			}
		}

		if (EG(return_value_ptr_ptr)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr_ptr);
			Z_ADDREF_PP(retval_ptr_ptr);

			*EG(return_value_ptr_ptr) = *retval_ptr_ptr;
		}
	} while (0);

	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_THROW_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *exception;


	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Can only throw objects");
	}

	zend_exception_save(TSRMLS_C);
	/* Not sure if a complete copy is what we want here */
	ALLOC_ZVAL(exception);
	INIT_PZVAL_COPY(exception, value);
	if (!0) {
		zval_copy_ctor(exception);
	}

	zend_throw_exception_object(exception TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);

	HANDLE_EXCEPTION();
}

static int ZEND_FASTCALL zend_send_by_var_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr;

	varptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (varptr == &EG(uninitialized_zval)) {
		if (IS_CV == IS_VAR) {
			Z_DELREF_P(varptr);
		}
		ALLOC_INIT_ZVAL(varptr);
	} else if (PZVAL_IS_REF(varptr)) {
		if (IS_CV == IS_CV ||
		    (IS_CV == IS_VAR && Z_REFCOUNT_P(varptr) > 2)) {
			zval *original_var = varptr;

			ALLOC_ZVAL(varptr);
			INIT_PZVAL_COPY(varptr, original_var);
			zval_copy_ctor(varptr);

		} else {
			Z_UNSET_ISREF_P(varptr);
		}
	} else if (IS_CV == IS_CV) {
		Z_ADDREF_P(varptr);
	}
	zend_vm_stack_push(varptr TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *varptr;

	SAVE_OPLINE();
	if (opline->extended_value & ZEND_ARG_COMPILE_TIME_BOUND) { /* Had function_ptr at compile_time */
		if (!(opline->extended_value & ZEND_ARG_SEND_BY_REF)) {
			return zend_send_by_var_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	} else {
		if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.num)) {
			return zend_send_by_var_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	}

	varptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	if ((!(opline->extended_value & ZEND_ARG_SEND_FUNCTION) ||
	     EX_T(opline->op1.var).var.fcall_returned_reference) &&
	    varptr != &EG(uninitialized_zval) &&
	    (PZVAL_IS_REF(varptr) || Z_REFCOUNT_P(varptr) == 1)) {
		Z_SET_ISREF_P(varptr);
		if (IS_CV == IS_CV) {
			Z_ADDREF_P(varptr);
		}
		zend_vm_stack_push(varptr TSRMLS_CC);
	} else {
		zval *valptr;

		if ((opline->extended_value & ZEND_ARG_COMPILE_TIME_BOUND) ?
			!(opline->extended_value & ZEND_ARG_SEND_SILENT) :
			!ARG_MAY_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.num)) {
			zend_error(E_STRICT, "Only variables should be passed by reference");
		}
		ALLOC_ZVAL(valptr);
		INIT_PZVAL_COPY(valptr, varptr);
		if (!0) {
			zval_copy_ctor(valptr);
		}

		zend_vm_stack_push(valptr TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SEND_REF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **varptr_ptr;
	zval *varptr;

	SAVE_OPLINE();
	varptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(varptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Only variables can be passed by reference");
	}

	if (IS_CV == IS_VAR && UNEXPECTED(*varptr_ptr == &EG(error_zval))) {
		ALLOC_INIT_ZVAL(varptr);
		zend_vm_stack_push(varptr TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	if (opline->extended_value == ZEND_DO_FCALL_BY_NAME &&
	    EX(function_state).function->type == ZEND_INTERNAL_FUNCTION) {
		if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.num)) {
			return zend_send_by_var_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	}

	SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr_ptr);
	varptr = *varptr_ptr;
	Z_ADDREF_P(varptr);
	zend_vm_stack_push(varptr TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SEND_VAR_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (opline->extended_value == ZEND_DO_FCALL_BY_NAME) {
		if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.num)) {
			return ZEND_SEND_REF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	}
	SAVE_OPLINE();
	return zend_send_by_var_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_BOOL_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *retval = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	/* PHP 3.0 returned "" for false and 1 for true, here we use 0 and 1 for now */
	ZVAL_BOOL(retval, i_zend_is_true(_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC)));

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CLONE_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		Z_OBJVAL_P(retval) = clone_call(obj TSRMLS_CC);
		Z_TYPE_P(retval) = IS_OBJECT;
		Z_SET_REFCOUNT_P(retval, 1);
		Z_SET_ISREF_P(retval);
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&retval);
		} else {
			EX_T(opline->result.var).var.ptr = retval;
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CAST_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	expr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (opline->extended_value != IS_STRING) {
		ZVAL_COPY_VALUE(result, expr);
		if (!0) {
			zendi_zval_copy_ctor(*result);
		}
	}
	switch (opline->extended_value) {
		case IS_NULL:
			convert_to_null(result);
			break;
		case IS_BOOL:
			convert_to_boolean(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		case IS_DOUBLE:
			convert_to_double(result);
			break;
		case IS_STRING: {
			zval var_copy;
			int use_copy;

			zend_make_printable_zval(expr, &var_copy, &use_copy);
			if (use_copy) {
				ZVAL_COPY_VALUE(result, &var_copy);
				if (0) {

				}
			} else {
				ZVAL_COPY_VALUE(result, expr);
				if (!0) {
					zendi_zval_copy_ctor(*result);
				}
			}
			break;
		}
		case IS_ARRAY:
			convert_to_array(result);
			break;
		case IS_OBJECT:
			convert_to_object(result);
			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_op_array *new_op_array=NULL;

	zval *inc_filename;
	zval *tmp_inc_filename = NULL;
	zend_bool failure_retval=0;

	SAVE_OPLINE();
	inc_filename = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (inc_filename->type!=IS_STRING) {
		MAKE_STD_ZVAL(tmp_inc_filename);
		ZVAL_COPY_VALUE(tmp_inc_filename, inc_filename);
		zval_copy_ctor(tmp_inc_filename);
		convert_to_string(tmp_inc_filename);
		inc_filename = tmp_inc_filename;
	}

	if (opline->extended_value != ZEND_EVAL && strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)) {
		if (opline->extended_value == ZEND_INCLUDE_ONCE || opline->extended_value == ZEND_INCLUDE) {
			zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		} else {
			zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		}
	} else {
		switch (opline->extended_value) {
			case ZEND_INCLUDE_ONCE:
			case ZEND_REQUIRE_ONCE: {
					zend_file_handle file_handle;
					char *resolved_path;

					resolved_path = zend_resolve_path(Z_STRVAL_P(inc_filename), Z_STRLEN_P(inc_filename) TSRMLS_CC);
					if (resolved_path) {
						failure_retval = zend_hash_exists(&EG(included_files), resolved_path, strlen(resolved_path)+1);
					} else {
						resolved_path = Z_STRVAL_P(inc_filename);
					}

					if (failure_retval) {
						/* do nothing, file already included */
					} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {

						if (!file_handle.opened_path) {
							file_handle.opened_path = estrdup(resolved_path);
						}

						if (zend_hash_add_empty_element(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path)+1)==SUCCESS) {
							new_op_array = zend_compile_file(&file_handle, (opline->extended_value==ZEND_INCLUDE_ONCE?ZEND_INCLUDE:ZEND_REQUIRE) TSRMLS_CC);
							zend_destroy_file_handle(&file_handle TSRMLS_CC);
						} else {
							zend_file_handle_dtor(&file_handle TSRMLS_CC);
							failure_retval=1;
						}
					} else {
						if (opline->extended_value == ZEND_INCLUDE_ONCE) {
							zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						} else {
							zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						}
					}
					if (resolved_path != Z_STRVAL_P(inc_filename)) {
						efree(resolved_path);
					}
				}
				break;
			case ZEND_INCLUDE:
			case ZEND_REQUIRE:
				new_op_array = compile_filename(opline->extended_value, inc_filename TSRMLS_CC);
				break;
			case ZEND_EVAL: {
					char *eval_desc = zend_make_compiled_string_description("eval()'d code" TSRMLS_CC);

					new_op_array = zend_compile_string(inc_filename, eval_desc TSRMLS_CC);
					efree(eval_desc);
				}
				break;
			EMPTY_SWITCH_DEFAULT_CASE()
		}
	}
	if (tmp_inc_filename) {
		zval_ptr_dtor(&tmp_inc_filename);
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		HANDLE_EXCEPTION();
	} else if (EXPECTED(new_op_array != NULL)) {
		EX(original_return_value) = EG(return_value_ptr_ptr);
		EG(active_op_array) = new_op_array;
		if (RETURN_VALUE_USED(opline)) {
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			EG(return_value_ptr_ptr) = EX_T(opline->result.var).var.ptr_ptr;
		} else {
			EG(return_value_ptr_ptr) = NULL;
		}

		EX(function_state).function = (zend_function *) new_op_array;
		EX(object) = NULL;

		if (!EG(active_symbol_table)) {
			zend_rebuild_symbol_table(TSRMLS_C);
		}

		if (EXPECTED(zend_execute_ex == execute_ex)) {
			ZEND_VM_ENTER();
		} else {
			zend_execute(new_op_array TSRMLS_CC);
		}

		EX(function_state).function = (zend_function *) EX(op_array);

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		EG(return_value_ptr_ptr) = EX(original_return_value);
		destroy_op_array(new_op_array TSRMLS_CC);
		efree(new_op_array);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}

	} else if (RETURN_VALUE_USED(opline)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		ZVAL_BOOL(retval, failure_retval);
		INIT_PZVAL(retval);
		EX_T(opline->result.var).var.ptr = retval;
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FE_RESET_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *array_ptr, **array_ptr_ptr;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;
	zend_class_entry *ce = NULL;
	zend_bool is_empty = 0;

	SAVE_OPLINE();

	if ((IS_CV == IS_CV || IS_CV == IS_VAR) &&
	    (opline->extended_value & ZEND_FE_RESET_VARIABLE)) {
		array_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (array_ptr_ptr == NULL || array_ptr_ptr == &EG(uninitialized_zval_ptr)) {
			MAKE_STD_ZVAL(array_ptr);
			ZVAL_NULL(array_ptr);
		} else if (Z_TYPE_PP(array_ptr_ptr) == IS_OBJECT) {
			if(Z_OBJ_HT_PP(array_ptr_ptr)->get_class_entry == NULL) {
				zend_error(E_WARNING, "foreach() cannot iterate over objects without PHP class");
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}

			ce = Z_OBJCE_PP(array_ptr_ptr);
			if (!ce || ce->get_iterator == NULL) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				Z_ADDREF_PP(array_ptr_ptr);
			}
			array_ptr = *array_ptr_ptr;
		} else {
			if (Z_TYPE_PP(array_ptr_ptr) == IS_ARRAY) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
					Z_SET_ISREF_PP(array_ptr_ptr);
				}
			}
			array_ptr = *array_ptr_ptr;
			Z_ADDREF_P(array_ptr);
		}
	} else {
		array_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* IS_TMP_VAR */
			zval *tmp;

			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			array_ptr = tmp;
			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
				ce = Z_OBJCE_P(array_ptr);
				if (ce && ce->get_iterator) {
					Z_DELREF_P(array_ptr);
				}
			}
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			ce = Z_OBJCE_P(array_ptr);
			if (!ce || !ce->get_iterator) {
				if (IS_CV == IS_CV) {
					Z_ADDREF_P(array_ptr);
				}
			}
		} else if (IS_CV == IS_CONST ||
		           (IS_CV == IS_CV &&
		            !Z_ISREF_P(array_ptr) &&
		            Z_REFCOUNT_P(array_ptr) > 1) ||
		           (IS_CV == IS_VAR &&
		            !Z_ISREF_P(array_ptr) &&
		            Z_REFCOUNT_P(array_ptr) > 2)) {
			zval *tmp;

			if (IS_CV == IS_VAR) {
				Z_DELREF_P(array_ptr);
			}
			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			zval_copy_ctor(tmp);
			array_ptr = tmp;
		} else if (IS_CV == IS_CV) {
			Z_ADDREF_P(array_ptr);
		}
	}

	if (ce && ce->get_iterator) {
		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);

		if (IS_CV == IS_VAR && !(opline->extended_value & ZEND_FE_RESET_VARIABLE)) {

		}
		if (iter && EXPECTED(EG(exception) == NULL)) {
			array_ptr = zend_iterator_wrap(iter TSRMLS_CC);
		} else {
			if (IS_CV == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

			}
			if (!EG(exception)) {
				zend_throw_exception_ex(NULL, 0 TSRMLS_CC, "Object of type %s did not create an Iterator", ce->name);
			}
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}
	}

	EX_T(opline->result.var).fe.ptr = array_ptr;

	if (iter) {
		iter->index = 0;
		if (iter->funcs->rewind) {
			iter->funcs->rewind(iter TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(&array_ptr);
				if (IS_CV == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

				}
				HANDLE_EXCEPTION();
			}
		}
		is_empty = iter->funcs->valid(iter TSRMLS_CC) != SUCCESS;
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&array_ptr);
			if (IS_CV == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

			}
			HANDLE_EXCEPTION();
		}
		iter->index = -1; /* will be set to 0 before using next handler */
	} else if ((fe_ht = HASH_OF(array_ptr)) != NULL) {
		zend_hash_internal_pointer_reset(fe_ht);
		if (ce) {
			zend_object *zobj = zend_objects_get_address(array_ptr TSRMLS_CC);
			while (zend_hash_has_more_elements(fe_ht) == SUCCESS) {
				char *str_key;
				uint str_key_len;
				ulong int_key;
				zend_uchar key_type;

				key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, NULL);
				if (key_type != HASH_KEY_NON_EXISTENT &&
					(key_type == HASH_KEY_IS_LONG ||
				     zend_check_property_access(zobj, str_key, str_key_len-1 TSRMLS_CC) == SUCCESS)) {
					break;
				}
				zend_hash_move_forward(fe_ht);
			}
		}
		is_empty = zend_hash_has_more_elements(fe_ht) != SUCCESS;
		zend_hash_get_pointer(fe_ht, &EX_T(opline->result.var).fe.fe_pos);
	} else {
		zend_error(E_WARNING, "Invalid argument supplied for foreach()");
		is_empty = 1;
	}

	if (IS_CV == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

	}
	if (is_empty) {
		ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
	} else {
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_EXIT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)/* 执行exit(xxx)语法产生的opcode */
{
#if 0 || (IS_CV != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_CV != IS_UNUSED) {

		zval *ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}

	}
#endif
	zend_bailout();/* 调用zend.c中的_zend_bailout()函数接受进程,不在执行以后的opcode */
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

static int ZEND_FASTCALL  ZEND_JMP_SET_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (i_zend_is_true(value)) {
		ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
		if (!0) {
			zendi_zval_copy_ctor(EX_T(opline->result.var).tmp_var);
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMP_SET_VAR_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value, *ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (i_zend_is_true(value)) {
		if (IS_CV == IS_VAR || IS_CV == IS_CV) {
			Z_ADDREF_P(value);
			EX_T(opline->result.var).var.ptr = value;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		} else {
			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, value);
			EX_T(opline->result.var).var.ptr = ret;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			if (!0) {
				zval_copy_ctor(EX_T(opline->result.var).var.ptr);
			}
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
	if (!0) {
		zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value, *ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		Z_ADDREF_P(value);
		EX_T(opline->result.var).var.ptr = value;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	} else {
		ALLOC_ZVAL(ret);
		INIT_PZVAL_COPY(ret, value);
		EX_T(opline->result.var).var.ptr = ret;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		if (!0) {
			zval_copy_ctor(EX_T(opline->result.var).var.ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INSTANCEOF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (Z_TYPE_P(expr) == IS_OBJECT && Z_OBJ_HT_P(expr)->get_class_entry) {
		result = instanceof_function(Z_OBJCE_P(expr), EX_T(opline->op2.var).class_entry TSRMLS_CC);
	} else {
		result = 0;
	}
	ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, result);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_CV_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *object;
	zval *property = opline->op2.zv;
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_CV_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_CV == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = opline->op2.zv;

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_CONST, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = opline->op2.zv;
			var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}


		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CONST(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CONST(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CONST(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CONST(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CONST(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CONST(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CONST(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CONST(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CONST(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CONST(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CONST(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_CV_CONST(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = opline->op2.zv;
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					*retval = &EG(uninitialized_zval);
				}
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				incdec_op(*zptr);
				if (RETURN_VALUE_USED(opline)) {
					*retval = *zptr;
					PZVAL_LOCK(*retval);
				}
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_CONST(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_CONST(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_CV_CONST(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = opline->op2.zv;
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				ZVAL_NULL(retval);
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				ZVAL_COPY_VALUE(retval, *zptr);
				zendi_zval_copy_ctor(*retval);

				incdec_op(*zptr);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z, *z_copy;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_CONST(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_CONST(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CV_CONST(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

 	if (IS_CV != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CV != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_CV == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else {
			hash_value = str_hash(Z_STRVAL_P(varname), Z_STRLEN_P(varname));
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_CV != IS_TMP_VAR) {

				}
				break;
			case ZEND_FETCH_LOCAL:

				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_CV == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_CV != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			EX_T(opline->result.var).var.ptr = *retval;
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_CONST(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_CONST(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_CONST(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	return zend_fetch_var_address_helper_SPEC_CV_CONST(zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC) ? BP_VAR_W : BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_CONST(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_CONST(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);

	if (IS_CV != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_W TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_RW TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_IS TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		zval **container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_W TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}


	} else {
		zval *container;

		if (IS_CONST == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);


	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_UNSET TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_CV_CONST(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_CV_CONST(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = opline->op2.zv;

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = opline->op2.zv;
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = opline->op2.zv;
		container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_CV_CONST(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	property = opline->op2.zv;

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	property_name = opline->op2.zv;

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {

	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {

		zval *property_name = opline->op2.zv;

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {

		}
	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = opline->op2.zv;
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_CONST, BP_VAR_W TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					EX_T(opline->result.var).var.ptr = retval;
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				EX_T(opline->result.var).var.ptr = value;
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = opline->op2.zv;
	variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_CONST TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				EX_T(opline->result.var).var.ptr = retval;
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else if (IS_CV == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		if (IS_CONST == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_CONST == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			EX_T(opline->result.var).var.ptr = value;
		}
	}

	if (IS_CV == IS_VAR && 0) {
		zval_ptr_dtor_nogc(&value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;

	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = opline->op2.zv;

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CONST != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CONST == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
				 opline->op2.zv TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CV == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_CV == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CONST != IS_UNUSED) {

		zval *offset = opline->op2.zv;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CONST == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;


	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_CV != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
						zval_ptr_dtor(&varname);
					}

					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_CV != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		zval_ptr_dtor(&varname);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = opline->op2.zv;

	if (IS_CV != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_CONST == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
							hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim:
						zend_hash_index_del(ht, hval);
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}

				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {

				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:

				break;
		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	offset = opline->op2.zv;

	if (IS_CV != IS_VAR || container) {
		if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {

			}
		} else {

		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_CONST != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_CONST == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_CV != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset = opline->op2.zv;

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_P(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_CONST == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}

	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container) && Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}

	} else {

	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_CV == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CONST(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_CV_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *object;
	zval *property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_dtor(free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (1) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (1) {
			zval_ptr_dtor(&property);
		} else {
			zval_dtor(free_op2.var);
		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_CV_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_CV == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_TMP_VAR, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
			var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
		zval_dtor(free_op2.var);

		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}
	zval_dtor(free_op2.var);

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_TMP(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_TMP(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_TMP(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_TMP(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_TMP(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_TMP(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_TMP(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_TMP(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_TMP(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_TMP(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_TMP(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_CV_TMP(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					*retval = &EG(uninitialized_zval);
				}
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				incdec_op(*zptr);
				if (RETURN_VALUE_USED(opline)) {
					*retval = *zptr;
					PZVAL_LOCK(*retval);
				}
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_TMP(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_TMP(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_CV_TMP(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				ZVAL_NULL(retval);
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				ZVAL_COPY_VALUE(retval, *zptr);
				zendi_zval_copy_ctor(*retval);

				incdec_op(*zptr);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z, *z_copy;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_TMP(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_TMP(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CV != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_W TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_RW TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_IS TSRMLS_CC);
	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		zval **container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_W TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
		zval_dtor(free_op2.var);

	} else {
		zval *container;

		if (IS_TMP_VAR == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
		zval_dtor(free_op2.var);

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_UNSET TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_CV_TMP(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		zval_dtor(free_op2.var);
	} else {
		zval *retval;

		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_CV_TMP(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		zval_dtor(free_op2.var);
	} else {
		zval *retval;

		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (1) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (1) {
			zval_ptr_dtor(&property);
		} else {
			zval_dtor(free_op2.var);
		}
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_CV_TMP(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property_name);
	} else {
		zval_dtor(free_op2.var);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {
		zend_free_op free_op2;
		zval *property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (1) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (1) {
			zval_ptr_dtor(&property_name);
		} else {
			zval_dtor(free_op2.var);
		}
	} else {
		zend_free_op free_op2, free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_TMP_VAR, BP_VAR_W TSRMLS_CC);
		zval_dtor(free_op2.var);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					EX_T(opline->result.var).var.ptr = retval;
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				EX_T(opline->result.var).var.ptr = value;
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_TMP_VAR TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				EX_T(opline->result.var).var.ptr = retval;
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else if (IS_CV == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (1) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		if (IS_TMP_VAR == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_TMP_VAR == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			EX_T(opline->result.var).var.ptr = value;
		}
	}

	if (IS_CV == IS_VAR && 0) {
		zval_ptr_dtor_nogc(&value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_TMP_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_TMP_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_dtor(free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
				 _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CV == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_CV == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_TMP_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		zval_dtor(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_TMP_VAR == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
							hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim:
						zend_hash_index_del(ht, hval);
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}
				zval_dtor(free_op2.var);
				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (1) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (1) {
					zval_ptr_dtor(&offset);
				} else {
					zval_dtor(free_op2.var);
				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:
				zval_dtor(free_op2.var);
				break;
		}
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV != IS_VAR || container) {
		if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (1) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (1) {
				zval_ptr_dtor(&offset);
			} else {
				zval_dtor(free_op2.var);
			}
		} else {
			zval_dtor(free_op2.var);
		}
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_P(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_TMP_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}
		zval_dtor(free_op2.var);
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container) && Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		zval_dtor(free_op2.var);
	} else {
		zval_dtor(free_op2.var);
	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_CV == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!1) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_TMP(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_CV_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *object;
	zval *property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_ptr_dtor_nogc(&free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_CV_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_CV == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_VAR, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
			var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
		zval_ptr_dtor_nogc(&free_op2.var);

		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}
	zval_ptr_dtor_nogc(&free_op2.var);

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_VAR(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_VAR(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_VAR(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_VAR(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_VAR(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_VAR(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_VAR(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_VAR(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_VAR(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_VAR(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_VAR(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_CV_VAR(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_ptr_dtor_nogc(&free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					*retval = &EG(uninitialized_zval);
				}
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				incdec_op(*zptr);
				if (RETURN_VALUE_USED(opline)) {
					*retval = *zptr;
					PZVAL_LOCK(*retval);
				}
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_VAR(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_VAR(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_CV_VAR(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_ptr_dtor_nogc(&free_op2.var);
		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				ZVAL_NULL(retval);
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				ZVAL_COPY_VALUE(retval, *zptr);
				zendi_zval_copy_ctor(*retval);

				incdec_op(*zptr);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z, *z_copy;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_VAR(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_VAR(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CV_VAR(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

 	if (IS_CV != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CV != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_CV == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else {
			hash_value = str_hash(Z_STRVAL_P(varname), Z_STRLEN_P(varname));
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_CV != IS_TMP_VAR) {

				}
				break;
			case ZEND_FETCH_LOCAL:

				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_CV == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_CV != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			EX_T(opline->result.var).var.ptr = *retval;
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_VAR(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_VAR(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_VAR(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	return zend_fetch_var_address_helper_SPEC_CV_VAR(zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC) ? BP_VAR_W : BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_VAR(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_VAR(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op2.var);
	if (IS_CV != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_W TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_RW TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_IS TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		zval **container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_W TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
		zval_ptr_dtor_nogc(&free_op2.var);

	} else {
		zval *container;

		if (IS_VAR == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
		zval_ptr_dtor_nogc(&free_op2.var);

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_UNSET TSRMLS_CC);
	zval_ptr_dtor_nogc(&free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_CV_VAR(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_CV_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_CV_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {
		zend_free_op free_op2;
		zval *property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	} else {
		zend_free_op free_op2, free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_VAR, BP_VAR_W TSRMLS_CC);
		zval_ptr_dtor_nogc(&free_op2.var);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					EX_T(opline->result.var).var.ptr = retval;
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				EX_T(opline->result.var).var.ptr = value;
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_VAR TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				EX_T(opline->result.var).var.ptr = retval;
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else if (IS_CV == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		if (IS_VAR == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_VAR == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			EX_T(opline->result.var).var.ptr = value;
		}
	}

	if (IS_CV == IS_VAR && 0) {
		zval_ptr_dtor_nogc(&value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */
 	zval_ptr_dtor_nogc(&free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **variable_ptr_ptr;
	zval **value_ptr_ptr;

	SAVE_OPLINE();
	value_ptr_ptr = _get_zval_ptr_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr)) {
		zend_error_noreturn(E_ERROR, "Cannot assign by reference to overloaded object");
	}

	if (IS_VAR == IS_VAR &&
	    value_ptr_ptr &&
	    !Z_ISREF_PP(value_ptr_ptr) &&
	    opline->extended_value == ZEND_RETURNS_FUNCTION &&
	    !EX_T(opline->op2.var).var.fcall_returned_reference) {
		if (free_op2.var == NULL) {
			PZVAL_LOCK(*value_ptr_ptr); /* undo the effect of get_zval_ptr_ptr() */
		}
		zend_error(E_STRICT, "Only variables should be assigned by reference");
		if (UNEXPECTED(EG(exception) != NULL)) {
			if (free_op2.var) {zval_ptr_dtor_nogc(&free_op2.var);};
			HANDLE_EXCEPTION();
		}
		return ZEND_ASSIGN_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		PZVAL_LOCK(*value_ptr_ptr);
	}

	variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if ((IS_VAR == IS_VAR && UNEXPECTED(value_ptr_ptr == NULL)) ||
	    (IS_CV == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL))) {
		zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets nor overloaded objects");
	}
	zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr TSRMLS_CC);

	if (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		Z_DELREF_PP(variable_ptr_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*variable_ptr_ptr);
		EX_T(opline->result.var).var.ptr = *variable_ptr_ptr;
	}

	if (free_op2.var) {zval_ptr_dtor_nogc(&free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor_nogc(&free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_ptr_dtor_nogc(&free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
				 _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CV == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_CV == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;


	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_CV != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
						zval_ptr_dtor(&varname);
					}

					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_CV != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		zval_ptr_dtor(&varname);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_VAR == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
							hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim:
						zend_hash_index_del(ht, hval);
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}
				zval_ptr_dtor_nogc(&free_op2.var);
				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {
					zval_ptr_dtor_nogc(&free_op2.var);
				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:
				zval_ptr_dtor_nogc(&free_op2.var);
				break;
		}
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV != IS_VAR || container) {
		if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {
				zval_ptr_dtor_nogc(&free_op2.var);
			}
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_VAR != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_VAR == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_CV != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_P(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}
		zval_ptr_dtor_nogc(&free_op2.var);
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			zval_ptr_dtor_nogc(&free_op2.var);
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container) && Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		zval_ptr_dtor_nogc(&free_op2.var);
	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_CV == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

		zval_ptr_dtor_nogc(&free_op2.var);
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(&free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_VAR(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *object;
	zval *property = NULL;
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_CV_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_CV == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = NULL;

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_UNUSED, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = NULL;
			var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}


		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_UNUSED(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_UNUSED(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_UNUSED(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_UNUSED(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_UNUSED(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_UNUSED(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_UNUSED(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_UNUSED(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_UNUSED(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_UNUSED(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_UNUSED(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CV_UNUSED(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

 	if (IS_CV != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CV != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_CV == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else {
			hash_value = str_hash(Z_STRVAL_P(varname), Z_STRLEN_P(varname));
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_CV != IS_TMP_VAR) {

				}
				break;
			case ZEND_FETCH_LOCAL:

				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_CV == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_CV != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			EX_T(opline->result.var).var.ptr = *retval;
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	return zend_fetch_var_address_helper_SPEC_CV_UNUSED(zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC) ? BP_VAR_W : BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_W TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_RW TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		zval **container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_W TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}


	} else {
		zval *container;

		if (IS_UNUSED == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_R TSRMLS_CC);


	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {

		zval *property_name = NULL;

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {

		}
	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = NULL;
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_UNUSED, BP_VAR_W TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					EX_T(opline->result.var).var.ptr = retval;
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				EX_T(opline->result.var).var.ptr = value;
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CV == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_CV == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_UNUSED != IS_UNUSED) {

		zval *offset = NULL;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_UNUSED == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;


	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_CV != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
						zval_ptr_dtor(&varname);
					}

					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_CV != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		zval_ptr_dtor(&varname);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_UNUSED != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_UNUSED == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_CV != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_CV == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_UNUSED(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_CV_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *object;
	zval *property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				have_get_ptr = 1;
				if (UNEXPECTED(*zptr == &EG(error_zval))) {
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(&EG(uninitialized_zval));
						EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					}
				} else {
					SEPARATE_ZVAL_IF_NOT_REF(zptr);

					binary_op(*zptr, *zptr, value TSRMLS_CC);
					if (RETURN_VALUE_USED(opline)) {
						PZVAL_LOCK(*zptr);
						EX_T(opline->result.var).var.ptr = *zptr;
					}
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			Z_ADDREF_P(object);
			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
				}
			}
			zval_ptr_dtor(&object);
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_CV_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			return zend_binary_assign_op_obj_helper_SPEC_CV_CV(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_CV == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					return zend_binary_assign_op_obj_helper_SPEC_CV_CV(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				} else {
					zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_CV, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
			var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}


		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		EX_T(opline->result.var).var.ptr = *var_ptr;
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CV(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CV(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CV(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CV(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CV(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CV(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CV(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CV(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CV(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CV(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CV(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_CV_CV(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					*retval = &EG(uninitialized_zval);
				}
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				incdec_op(*zptr);
				if (RETURN_VALUE_USED(opline)) {
					*retval = *zptr;
					PZVAL_LOCK(*retval);
				}
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_CV(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_CV(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_CV_CV(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			if (UNEXPECTED(*zptr == &EG(error_zval))) {
				ZVAL_NULL(retval);
			} else {
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				ZVAL_COPY_VALUE(retval, *zptr);
				zendi_zval_copy_ctor(*retval);

				incdec_op(*zptr);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z, *z_copy;

			Z_ADDREF_P(object);
			z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&object);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_CV(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_CV(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);

	if (IS_CV != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_W TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_RW TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_IS TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		zval **container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_W TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}


	} else {
		zval *container;

		if (IS_CV == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);


	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_UNSET TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_CV_CV(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_CV_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		EX_T(opline->result.var).var.ptr = retval;

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_CV_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {

	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {

		zval *property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {

		}
	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_CV, BP_VAR_W TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					EX_T(opline->result.var).var.ptr = retval;
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				EX_T(opline->result.var).var.ptr = value;
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_CV TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				EX_T(opline->result.var).var.ptr = retval;
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else if (IS_CV == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
		}
	} else {
		if (IS_CV == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_CV == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			EX_T(opline->result.var).var.ptr = value;
		}
	}

	if (IS_CV == IS_VAR && 0) {
		zval_ptr_dtor_nogc(&value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **variable_ptr_ptr;
	zval **value_ptr_ptr;

	SAVE_OPLINE();
	value_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr)) {
		zend_error_noreturn(E_ERROR, "Cannot assign by reference to overloaded object");
	}

	if (IS_CV == IS_VAR &&
	    value_ptr_ptr &&
	    !Z_ISREF_PP(value_ptr_ptr) &&
	    opline->extended_value == ZEND_RETURNS_FUNCTION &&
	    !EX_T(opline->op2.var).var.fcall_returned_reference) {
		if (free_op2.var == NULL) {
			PZVAL_LOCK(*value_ptr_ptr); /* undo the effect of get_zval_ptr_ptr() */
		}
		zend_error(E_STRICT, "Only variables should be assigned by reference");
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		return ZEND_ASSIGN_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		PZVAL_LOCK(*value_ptr_ptr);
	}

	variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if ((IS_CV == IS_VAR && UNEXPECTED(value_ptr_ptr == NULL)) ||
	    (IS_CV == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL))) {
		zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets nor overloaded objects");
	}
	zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr TSRMLS_CC);

	if (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		Z_DELREF_PP(variable_ptr_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*variable_ptr_ptr);
		EX_T(opline->result.var).var.ptr = *variable_ptr_ptr;
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;

	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CV != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CV == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on %s", function_name_strval, zend_get_type_by_const(Z_TYPE_P(call->object)));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CV == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);

		} else if (IS_CV == IS_CV) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CV != IS_UNUSED) {

		zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CV == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_CV == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
							hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim:
						zend_hash_index_del(ht, hval);
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}

				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {

				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:

				break;
		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_VAR || container) {
		if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {

			}
		} else {

		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_P(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_CV == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop);
					hval = str_hash(Z_STRVAL_P(offset), Z_STRLEN_P(offset));
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}

	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container) && Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}

	} else {

	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
				|| PZVAL_IS_REF(value)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;

			} else {
				if (IS_CV == IS_CV) {
					Z_ADDREF_P(value);
				}
				generator->value = value;
			}
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = &EX_T(opline->result.var).var.ptr;
		Z_ADDREF(EG(uninitialized_zval));
		EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_POW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	pow_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_POW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_binary_assign_op_helper_SPEC_CV_CV(pow_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_error_noreturn(E_ERROR, "Invalid opcode %d/%d/%d.", OPLINE->opcode, OPLINE->op1_type, OPLINE->op2_type);
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}


void zend_init_opcodes_handlers(void) /* ZEND_[opcode]_SPEC_(变量类型1)_(变量类型2)_HANDLER */
{
  static const opcode_handler_t labels[] = {
    ZEND_NOP_SPEC_HANDLER, /* 0 */
    ZEND_NOP_SPEC_HANDLER, /* 1 */
    ZEND_NOP_SPEC_HANDLER, /* 2 */
    ZEND_NOP_SPEC_HANDLER, /* 3 */
    ZEND_NOP_SPEC_HANDLER, /* 4 */
    ZEND_NOP_SPEC_HANDLER, /* 5 */
    ZEND_NOP_SPEC_HANDLER, /* 6 */
    ZEND_NOP_SPEC_HANDLER, /* 7 */
    ZEND_NOP_SPEC_HANDLER, /* 8 */
    ZEND_NOP_SPEC_HANDLER, /* 9 */
    ZEND_NOP_SPEC_HANDLER, /* 10 */
    ZEND_NOP_SPEC_HANDLER, /* 11 */
    ZEND_NOP_SPEC_HANDLER, /* 12 */
    ZEND_NOP_SPEC_HANDLER, /* 13 */
    ZEND_NOP_SPEC_HANDLER, /* 14 */
    ZEND_NOP_SPEC_HANDLER, /* 15 */
    ZEND_NOP_SPEC_HANDLER, /* 16 */
    ZEND_NOP_SPEC_HANDLER, /* 17 */
    ZEND_NOP_SPEC_HANDLER, /* 18 */
    ZEND_NOP_SPEC_HANDLER, /* 19 */
    ZEND_NOP_SPEC_HANDLER, /* 20 */
    ZEND_NOP_SPEC_HANDLER, /* 21 */
    ZEND_NOP_SPEC_HANDLER, /* 22 */
    ZEND_NOP_SPEC_HANDLER, /* 23 */
    ZEND_NOP_SPEC_HANDLER, /* 24 */
    ZEND_ADD_SPEC_CONST_CONST_HANDLER, /* 25 */
    ZEND_ADD_SPEC_CONST_TMP_HANDLER, /* 26 */
    ZEND_ADD_SPEC_CONST_VAR_HANDLER, /* 27 */
    ZEND_NULL_HANDLER, /* 28 */
    ZEND_ADD_SPEC_CONST_CV_HANDLER, /* 29 */
    ZEND_ADD_SPEC_TMP_CONST_HANDLER, /* 30 */
    ZEND_ADD_SPEC_TMP_TMP_HANDLER, /* 31 */
    ZEND_ADD_SPEC_TMP_VAR_HANDLER, /* 32 */
    ZEND_NULL_HANDLER, /* 33 */
    ZEND_ADD_SPEC_TMP_CV_HANDLER, /* 34 */
    ZEND_ADD_SPEC_VAR_CONST_HANDLER, /* 35 */
    ZEND_ADD_SPEC_VAR_TMP_HANDLER, /* 36 */
    ZEND_ADD_SPEC_VAR_VAR_HANDLER, /* 37 */
    ZEND_NULL_HANDLER, /* 38 */
    ZEND_ADD_SPEC_VAR_CV_HANDLER, /* 39 */
    ZEND_NULL_HANDLER, /* 40 */
    ZEND_NULL_HANDLER, /* 41 */
    ZEND_NULL_HANDLER, /* 42 */
    ZEND_NULL_HANDLER, /* 43 */
    ZEND_NULL_HANDLER, /* 44 */
    ZEND_ADD_SPEC_CV_CONST_HANDLER, /* 45 */
    ZEND_ADD_SPEC_CV_TMP_HANDLER, /* 46 */
    ZEND_ADD_SPEC_CV_VAR_HANDLER, /* 47 */
    ZEND_NULL_HANDLER, /* 48 */
    ZEND_ADD_SPEC_CV_CV_HANDLER, /* 49 */
    ZEND_SUB_SPEC_CONST_CONST_HANDLER, /* 50 */
    ZEND_SUB_SPEC_CONST_TMP_HANDLER, /* 51 */
    ZEND_SUB_SPEC_CONST_VAR_HANDLER, /* 52 */
    ZEND_NULL_HANDLER, /* 53 */
    ZEND_SUB_SPEC_CONST_CV_HANDLER, /* 54 */
    ZEND_SUB_SPEC_TMP_CONST_HANDLER, /* 55 */
    ZEND_SUB_SPEC_TMP_TMP_HANDLER, /* 56 */
    ZEND_SUB_SPEC_TMP_VAR_HANDLER, /* 57 */
    ZEND_NULL_HANDLER, /* 58 */
    ZEND_SUB_SPEC_TMP_CV_HANDLER, /* 59 */
    ZEND_SUB_SPEC_VAR_CONST_HANDLER, /* 60 */
    ZEND_SUB_SPEC_VAR_TMP_HANDLER, /* 61 */
    ZEND_SUB_SPEC_VAR_VAR_HANDLER, /* 62 */
    ZEND_NULL_HANDLER, /* 63 */
    ZEND_SUB_SPEC_VAR_CV_HANDLER, /* 64 */
    ZEND_NULL_HANDLER, /* 65 */
    ZEND_NULL_HANDLER, /* 66 */
    ZEND_NULL_HANDLER, /* 67 */
    ZEND_NULL_HANDLER, /* 68 */
    ZEND_NULL_HANDLER, /* 69 */
    ZEND_SUB_SPEC_CV_CONST_HANDLER, /* 70 */
    ZEND_SUB_SPEC_CV_TMP_HANDLER, /* 71 */
    ZEND_SUB_SPEC_CV_VAR_HANDLER, /* 72 */
    ZEND_NULL_HANDLER, /* 73 */
    ZEND_SUB_SPEC_CV_CV_HANDLER, /* 74 */
    ZEND_MUL_SPEC_CONST_CONST_HANDLER, /* 75 */
    ZEND_MUL_SPEC_CONST_TMP_HANDLER, /* 76 */
    ZEND_MUL_SPEC_CONST_VAR_HANDLER, /* 77 */
    ZEND_NULL_HANDLER, /* 78 */
    ZEND_MUL_SPEC_CONST_CV_HANDLER, /* 79 */
    ZEND_MUL_SPEC_TMP_CONST_HANDLER, /* 80 */
    ZEND_MUL_SPEC_TMP_TMP_HANDLER, /* 81 */
    ZEND_MUL_SPEC_TMP_VAR_HANDLER, /* 82 */
    ZEND_NULL_HANDLER, /* 83 */
    ZEND_MUL_SPEC_TMP_CV_HANDLER, /* 84 */
    ZEND_MUL_SPEC_VAR_CONST_HANDLER, /* 85 */
    ZEND_MUL_SPEC_VAR_TMP_HANDLER, /* 86 */
    ZEND_MUL_SPEC_VAR_VAR_HANDLER, /* 87 */
    ZEND_NULL_HANDLER, /* 88 */
    ZEND_MUL_SPEC_VAR_CV_HANDLER, /* 89 */
    ZEND_NULL_HANDLER, /* 90 */
    ZEND_NULL_HANDLER, /* 91 */
    ZEND_NULL_HANDLER, /* 92 */
    ZEND_NULL_HANDLER, /* 93 */
    ZEND_NULL_HANDLER, /* 94 */
    ZEND_MUL_SPEC_CV_CONST_HANDLER, /* 95 */
    ZEND_MUL_SPEC_CV_TMP_HANDLER, /* 96 */
    ZEND_MUL_SPEC_CV_VAR_HANDLER, /* 97 */
    ZEND_NULL_HANDLER, /* 98 */
    ZEND_MUL_SPEC_CV_CV_HANDLER, /* 99 */
    ZEND_DIV_SPEC_CONST_CONST_HANDLER, /* 100 */
    ZEND_DIV_SPEC_CONST_TMP_HANDLER, /* 101 */
    ZEND_DIV_SPEC_CONST_VAR_HANDLER, /* 102 */
    ZEND_NULL_HANDLER, /* 103 */
    ZEND_DIV_SPEC_CONST_CV_HANDLER, /* 104 */
    ZEND_DIV_SPEC_TMP_CONST_HANDLER, /* 105 */
    ZEND_DIV_SPEC_TMP_TMP_HANDLER, /* 106 */
    ZEND_DIV_SPEC_TMP_VAR_HANDLER, /* 107 */
    ZEND_NULL_HANDLER, /* 108 */
    ZEND_DIV_SPEC_TMP_CV_HANDLER, /* 109 */
    ZEND_DIV_SPEC_VAR_CONST_HANDLER, /* 110 */
    ZEND_DIV_SPEC_VAR_TMP_HANDLER, /* 111 */
    ZEND_DIV_SPEC_VAR_VAR_HANDLER, /* 112 */
    ZEND_NULL_HANDLER, /* 113 */
    ZEND_DIV_SPEC_VAR_CV_HANDLER, /* 114 */
    ZEND_NULL_HANDLER, /* 115 */
    ZEND_NULL_HANDLER, /* 116 */
    ZEND_NULL_HANDLER, /* 117 */
    ZEND_NULL_HANDLER, /* 118 */
    ZEND_NULL_HANDLER, /* 119 */
    ZEND_DIV_SPEC_CV_CONST_HANDLER, /* 120 */
    ZEND_DIV_SPEC_CV_TMP_HANDLER, /* 121 */
    ZEND_DIV_SPEC_CV_VAR_HANDLER, /* 122 */
    ZEND_NULL_HANDLER, /* 123 */
    ZEND_DIV_SPEC_CV_CV_HANDLER, /* 124 */
    ZEND_MOD_SPEC_CONST_CONST_HANDLER, /* 125 */
    ZEND_MOD_SPEC_CONST_TMP_HANDLER, /* 126 */
    ZEND_MOD_SPEC_CONST_VAR_HANDLER, /* 127 */
    ZEND_NULL_HANDLER, /* 128 */
    ZEND_MOD_SPEC_CONST_CV_HANDLER, /* 129 */
    ZEND_MOD_SPEC_TMP_CONST_HANDLER, /* 130 */
    ZEND_MOD_SPEC_TMP_TMP_HANDLER, /* 131 */
    ZEND_MOD_SPEC_TMP_VAR_HANDLER, /* 132 */
    ZEND_NULL_HANDLER, /* 133 */
    ZEND_MOD_SPEC_TMP_CV_HANDLER, /* 134 */
    ZEND_MOD_SPEC_VAR_CONST_HANDLER, /* 135 */
    ZEND_MOD_SPEC_VAR_TMP_HANDLER, /* 136 */
    ZEND_MOD_SPEC_VAR_VAR_HANDLER, /* 137 */
    ZEND_NULL_HANDLER, /* 138 */
    ZEND_MOD_SPEC_VAR_CV_HANDLER, /* 139 */
    ZEND_NULL_HANDLER, /* 140 */
    ZEND_NULL_HANDLER, /* 141 */
    ZEND_NULL_HANDLER, /* 142 */
    ZEND_NULL_HANDLER, /* 143 */
    ZEND_NULL_HANDLER, /* 144 */
    ZEND_MOD_SPEC_CV_CONST_HANDLER, /* 145 */
    ZEND_MOD_SPEC_CV_TMP_HANDLER, /* 146 */
    ZEND_MOD_SPEC_CV_VAR_HANDLER, /* 147 */
    ZEND_NULL_HANDLER, /* 148 */
    ZEND_MOD_SPEC_CV_CV_HANDLER, /* 149 */
    ZEND_SL_SPEC_CONST_CONST_HANDLER, /* 150 */
    ZEND_SL_SPEC_CONST_TMP_HANDLER, /* 151 */
    ZEND_SL_SPEC_CONST_VAR_HANDLER, /* 152 */
    ZEND_NULL_HANDLER, /* 153 */
    ZEND_SL_SPEC_CONST_CV_HANDLER, /* 154 */
    ZEND_SL_SPEC_TMP_CONST_HANDLER, /* 155 */
    ZEND_SL_SPEC_TMP_TMP_HANDLER, /* 156 */
    ZEND_SL_SPEC_TMP_VAR_HANDLER, /* 157 */
    ZEND_NULL_HANDLER, /* 158 */
    ZEND_SL_SPEC_TMP_CV_HANDLER, /* 159 */
    ZEND_SL_SPEC_VAR_CONST_HANDLER, /* 160 */
    ZEND_SL_SPEC_VAR_TMP_HANDLER, /* 161 */
    ZEND_SL_SPEC_VAR_VAR_HANDLER, /* 162 */
    ZEND_NULL_HANDLER, /* 163 */
    ZEND_SL_SPEC_VAR_CV_HANDLER, /* 164 */
    ZEND_NULL_HANDLER, /* 165 */
    ZEND_NULL_HANDLER, /* 166 */
    ZEND_NULL_HANDLER, /* 167 */
    ZEND_NULL_HANDLER, /* 168 */
    ZEND_NULL_HANDLER, /* 169 */
    ZEND_SL_SPEC_CV_CONST_HANDLER, /* 170 */
    ZEND_SL_SPEC_CV_TMP_HANDLER, /* 171 */
    ZEND_SL_SPEC_CV_VAR_HANDLER, /* 172 */
    ZEND_NULL_HANDLER, /* 173 */
    ZEND_SL_SPEC_CV_CV_HANDLER, /* 174 */
    ZEND_SR_SPEC_CONST_CONST_HANDLER, /* 175 */
    ZEND_SR_SPEC_CONST_TMP_HANDLER, /* 176 */
    ZEND_SR_SPEC_CONST_VAR_HANDLER, /* 177 */
    ZEND_NULL_HANDLER, /* 178 */
    ZEND_SR_SPEC_CONST_CV_HANDLER, /* 179 */
    ZEND_SR_SPEC_TMP_CONST_HANDLER, /* 180 */
    ZEND_SR_SPEC_TMP_TMP_HANDLER, /* 181 */
    ZEND_SR_SPEC_TMP_VAR_HANDLER, /* 182 */
    ZEND_NULL_HANDLER, /* 183 */
    ZEND_SR_SPEC_TMP_CV_HANDLER, /* 184 */
    ZEND_SR_SPEC_VAR_CONST_HANDLER, /* 185 */
    ZEND_SR_SPEC_VAR_TMP_HANDLER, /* 186 */
    ZEND_SR_SPEC_VAR_VAR_HANDLER, /* 187 */
    ZEND_NULL_HANDLER, /* 188 */
    ZEND_SR_SPEC_VAR_CV_HANDLER, /* 189 */
    ZEND_NULL_HANDLER, /* 190 */
    ZEND_NULL_HANDLER, /* 191 */
    ZEND_NULL_HANDLER, /* 192 */
    ZEND_NULL_HANDLER, /* 193 */
    ZEND_NULL_HANDLER, /* 194 */
    ZEND_SR_SPEC_CV_CONST_HANDLER, /* 195 */
    ZEND_SR_SPEC_CV_TMP_HANDLER, /* 196 */
    ZEND_SR_SPEC_CV_VAR_HANDLER, /* 197 */
    ZEND_NULL_HANDLER, /* 198 */
    ZEND_SR_SPEC_CV_CV_HANDLER, /* 199 */
    ZEND_CONCAT_SPEC_CONST_CONST_HANDLER, /* 200 */
    ZEND_CONCAT_SPEC_CONST_TMP_HANDLER, /* 201 */
    ZEND_CONCAT_SPEC_CONST_VAR_HANDLER, /* 202 */
    ZEND_NULL_HANDLER, /* 203 */
    ZEND_CONCAT_SPEC_CONST_CV_HANDLER, /* 204 */
    ZEND_CONCAT_SPEC_TMP_CONST_HANDLER, /* 205 */
    ZEND_CONCAT_SPEC_TMP_TMP_HANDLER, /* 206 */
    ZEND_CONCAT_SPEC_TMP_VAR_HANDLER, /* 207 */
    ZEND_NULL_HANDLER, /* 208 */
    ZEND_CONCAT_SPEC_TMP_CV_HANDLER, /* 209 */
    ZEND_CONCAT_SPEC_VAR_CONST_HANDLER, /* 210 */
    ZEND_CONCAT_SPEC_VAR_TMP_HANDLER, /* 211 */
    ZEND_CONCAT_SPEC_VAR_VAR_HANDLER, /* 212 */
    ZEND_NULL_HANDLER, /* 213 */
    ZEND_CONCAT_SPEC_VAR_CV_HANDLER, /* 214 */
    ZEND_NULL_HANDLER, /* 215 */
    ZEND_NULL_HANDLER, /* 216 */
    ZEND_NULL_HANDLER, /* 217 */
    ZEND_NULL_HANDLER, /* 218 */
    ZEND_NULL_HANDLER, /* 219 */
    ZEND_CONCAT_SPEC_CV_CONST_HANDLER, /* 220 */
    ZEND_CONCAT_SPEC_CV_TMP_HANDLER, /* 221 */
    ZEND_CONCAT_SPEC_CV_VAR_HANDLER, /* 222 */
    ZEND_NULL_HANDLER, /* 223 */
    ZEND_CONCAT_SPEC_CV_CV_HANDLER, /* 224 */
    ZEND_BW_OR_SPEC_CONST_CONST_HANDLER, /* 225 */
    ZEND_BW_OR_SPEC_CONST_TMP_HANDLER, /* 226 */
    ZEND_BW_OR_SPEC_CONST_VAR_HANDLER, /* 227 */
    ZEND_NULL_HANDLER, /* 228 */
    ZEND_BW_OR_SPEC_CONST_CV_HANDLER, /* 229 */
    ZEND_BW_OR_SPEC_TMP_CONST_HANDLER, /* 230 */
    ZEND_BW_OR_SPEC_TMP_TMP_HANDLER, /* 231 */
    ZEND_BW_OR_SPEC_TMP_VAR_HANDLER, /* 232 */
    ZEND_NULL_HANDLER, /* 233 */
    ZEND_BW_OR_SPEC_TMP_CV_HANDLER, /* 234 */
    ZEND_BW_OR_SPEC_VAR_CONST_HANDLER, /* 235 */
    ZEND_BW_OR_SPEC_VAR_TMP_HANDLER, /* 236 */
    ZEND_BW_OR_SPEC_VAR_VAR_HANDLER, /* 237 */
    ZEND_NULL_HANDLER, /* 238 */
    ZEND_BW_OR_SPEC_VAR_CV_HANDLER, /* 239 */
    ZEND_NULL_HANDLER, /* 240 */
    ZEND_NULL_HANDLER, /* 241 */
    ZEND_NULL_HANDLER, /* 242 */
    ZEND_NULL_HANDLER, /* 243 */
    ZEND_NULL_HANDLER, /* 244 */
    ZEND_BW_OR_SPEC_CV_CONST_HANDLER, /* 245 */
    ZEND_BW_OR_SPEC_CV_TMP_HANDLER, /* 246 */
    ZEND_BW_OR_SPEC_CV_VAR_HANDLER, /* 247 */
    ZEND_NULL_HANDLER, /* 248 */
    ZEND_BW_OR_SPEC_CV_CV_HANDLER, /* 249 */
    ZEND_BW_AND_SPEC_CONST_CONST_HANDLER, /* 250 */
    ZEND_BW_AND_SPEC_CONST_TMP_HANDLER, /* 251 */
    ZEND_BW_AND_SPEC_CONST_VAR_HANDLER, /* 252 */
    ZEND_NULL_HANDLER, /* 253 */
    ZEND_BW_AND_SPEC_CONST_CV_HANDLER, /* 254 */
    ZEND_BW_AND_SPEC_TMP_CONST_HANDLER, /* 255 */
    ZEND_BW_AND_SPEC_TMP_TMP_HANDLER, /* 256 */
    ZEND_BW_AND_SPEC_TMP_VAR_HANDLER, /* 257 */
    ZEND_NULL_HANDLER, /* 258 */
    ZEND_BW_AND_SPEC_TMP_CV_HANDLER, /* 259 */
    ZEND_BW_AND_SPEC_VAR_CONST_HANDLER, /* 260 */
    ZEND_BW_AND_SPEC_VAR_TMP_HANDLER, /* 261 */
    ZEND_BW_AND_SPEC_VAR_VAR_HANDLER, /* 262 */
    ZEND_NULL_HANDLER, /* 263 */
    ZEND_BW_AND_SPEC_VAR_CV_HANDLER, /* 264 */
    ZEND_NULL_HANDLER, /* 265 */
    ZEND_NULL_HANDLER, /* 266 */
    ZEND_NULL_HANDLER, /* 267 */
    ZEND_NULL_HANDLER, /* 268 */
    ZEND_NULL_HANDLER, /* 269 */
    ZEND_BW_AND_SPEC_CV_CONST_HANDLER, /* 270 */
    ZEND_BW_AND_SPEC_CV_TMP_HANDLER, /* 271 */
    ZEND_BW_AND_SPEC_CV_VAR_HANDLER, /* 272 */
    ZEND_NULL_HANDLER, /* 273 */
    ZEND_BW_AND_SPEC_CV_CV_HANDLER, /* 274 */
    ZEND_BW_XOR_SPEC_CONST_CONST_HANDLER, /* 275 */
    ZEND_BW_XOR_SPEC_CONST_TMP_HANDLER, /* 276 */
    ZEND_BW_XOR_SPEC_CONST_VAR_HANDLER, /* 277 */
    ZEND_NULL_HANDLER, /* 278 */
    ZEND_BW_XOR_SPEC_CONST_CV_HANDLER, /* 279 */
    ZEND_BW_XOR_SPEC_TMP_CONST_HANDLER, /* 280 */
    ZEND_BW_XOR_SPEC_TMP_TMP_HANDLER, /* 281 */
    ZEND_BW_XOR_SPEC_TMP_VAR_HANDLER, /* 282 */
    ZEND_NULL_HANDLER, /* 283 */
    ZEND_BW_XOR_SPEC_TMP_CV_HANDLER, /* 284 */
    ZEND_BW_XOR_SPEC_VAR_CONST_HANDLER, /* 285 */
    ZEND_BW_XOR_SPEC_VAR_TMP_HANDLER, /* 286 */
    ZEND_BW_XOR_SPEC_VAR_VAR_HANDLER, /* 287 */
    ZEND_NULL_HANDLER, /* 288 */
    ZEND_BW_XOR_SPEC_VAR_CV_HANDLER, /* 289 */
    ZEND_NULL_HANDLER, /* 290 */
    ZEND_NULL_HANDLER, /* 291 */
    ZEND_NULL_HANDLER, /* 292 */
    ZEND_NULL_HANDLER, /* 293 */
    ZEND_NULL_HANDLER, /* 294 */
    ZEND_BW_XOR_SPEC_CV_CONST_HANDLER, /* 295 */
    ZEND_BW_XOR_SPEC_CV_TMP_HANDLER, /* 296 */
    ZEND_BW_XOR_SPEC_CV_VAR_HANDLER, /* 297 */
    ZEND_NULL_HANDLER, /* 298 */
    ZEND_BW_XOR_SPEC_CV_CV_HANDLER, /* 299 */
    ZEND_BW_NOT_SPEC_CONST_HANDLER, /* 300 */
    ZEND_BW_NOT_SPEC_CONST_HANDLER, /* 301 */
    ZEND_BW_NOT_SPEC_CONST_HANDLER, /* 302 */
    ZEND_BW_NOT_SPEC_CONST_HANDLER, /* 303 */
    ZEND_BW_NOT_SPEC_CONST_HANDLER, /* 304 */
    ZEND_BW_NOT_SPEC_TMP_HANDLER, /* 305 */
    ZEND_BW_NOT_SPEC_TMP_HANDLER, /* 306 */
    ZEND_BW_NOT_SPEC_TMP_HANDLER, /* 307 */
    ZEND_BW_NOT_SPEC_TMP_HANDLER, /* 308 */
    ZEND_BW_NOT_SPEC_TMP_HANDLER, /* 309 */
    ZEND_BW_NOT_SPEC_VAR_HANDLER, /* 310 */
    ZEND_BW_NOT_SPEC_VAR_HANDLER, /* 311 */
    ZEND_BW_NOT_SPEC_VAR_HANDLER, /* 312 */
    ZEND_BW_NOT_SPEC_VAR_HANDLER, /* 313 */
    ZEND_BW_NOT_SPEC_VAR_HANDLER, /* 314 */
    ZEND_NULL_HANDLER, /* 315 */
    ZEND_NULL_HANDLER, /* 316 */
    ZEND_NULL_HANDLER, /* 317 */
    ZEND_NULL_HANDLER, /* 318 */
    ZEND_NULL_HANDLER, /* 319 */
    ZEND_BW_NOT_SPEC_CV_HANDLER, /* 320 */
    ZEND_BW_NOT_SPEC_CV_HANDLER, /* 321 */
    ZEND_BW_NOT_SPEC_CV_HANDLER, /* 322 */
    ZEND_BW_NOT_SPEC_CV_HANDLER, /* 323 */
    ZEND_BW_NOT_SPEC_CV_HANDLER, /* 324 */
    ZEND_BOOL_NOT_SPEC_CONST_HANDLER, /* 325 */
    ZEND_BOOL_NOT_SPEC_CONST_HANDLER, /* 326 */
    ZEND_BOOL_NOT_SPEC_CONST_HANDLER, /* 327 */
    ZEND_BOOL_NOT_SPEC_CONST_HANDLER, /* 328 */
    ZEND_BOOL_NOT_SPEC_CONST_HANDLER, /* 329 */
    ZEND_BOOL_NOT_SPEC_TMP_HANDLER, /* 330 */
    ZEND_BOOL_NOT_SPEC_TMP_HANDLER, /* 331 */
    ZEND_BOOL_NOT_SPEC_TMP_HANDLER, /* 332 */
    ZEND_BOOL_NOT_SPEC_TMP_HANDLER, /* 333 */
    ZEND_BOOL_NOT_SPEC_TMP_HANDLER, /* 334 */
    ZEND_BOOL_NOT_SPEC_VAR_HANDLER, /* 335 */
    ZEND_BOOL_NOT_SPEC_VAR_HANDLER, /* 336 */
    ZEND_BOOL_NOT_SPEC_VAR_HANDLER, /* 337 */
    ZEND_BOOL_NOT_SPEC_VAR_HANDLER, /* 338 */
    ZEND_BOOL_NOT_SPEC_VAR_HANDLER, /* 339 */
    ZEND_NULL_HANDLER, /* 340 */
    ZEND_NULL_HANDLER, /* 341 */
    ZEND_NULL_HANDLER, /* 342 */
    ZEND_NULL_HANDLER, /* 343 */
    ZEND_NULL_HANDLER, /* 344 */
    ZEND_BOOL_NOT_SPEC_CV_HANDLER, /* 345 */
    ZEND_BOOL_NOT_SPEC_CV_HANDLER, /* 346 */
    ZEND_BOOL_NOT_SPEC_CV_HANDLER, /* 347 */
    ZEND_BOOL_NOT_SPEC_CV_HANDLER, /* 348 */
    ZEND_BOOL_NOT_SPEC_CV_HANDLER, /* 349 */
    ZEND_BOOL_XOR_SPEC_CONST_CONST_HANDLER, /* 350 */
    ZEND_BOOL_XOR_SPEC_CONST_TMP_HANDLER, /* 351 */
    ZEND_BOOL_XOR_SPEC_CONST_VAR_HANDLER, /* 352 */
    ZEND_NULL_HANDLER, /* 353 */
    ZEND_BOOL_XOR_SPEC_CONST_CV_HANDLER, /* 354 */
    ZEND_BOOL_XOR_SPEC_TMP_CONST_HANDLER, /* 355 */
    ZEND_BOOL_XOR_SPEC_TMP_TMP_HANDLER, /* 356 */
    ZEND_BOOL_XOR_SPEC_TMP_VAR_HANDLER, /* 357 */
    ZEND_NULL_HANDLER, /* 358 */
    ZEND_BOOL_XOR_SPEC_TMP_CV_HANDLER, /* 359 */
    ZEND_BOOL_XOR_SPEC_VAR_CONST_HANDLER, /* 360 */
    ZEND_BOOL_XOR_SPEC_VAR_TMP_HANDLER, /* 361 */
    ZEND_BOOL_XOR_SPEC_VAR_VAR_HANDLER, /* 362 */
    ZEND_NULL_HANDLER, /* 363 */
    ZEND_BOOL_XOR_SPEC_VAR_CV_HANDLER, /* 364 */
    ZEND_NULL_HANDLER, /* 365 */
    ZEND_NULL_HANDLER, /* 366 */
    ZEND_NULL_HANDLER, /* 367 */
    ZEND_NULL_HANDLER, /* 368 */
    ZEND_NULL_HANDLER, /* 369 */
    ZEND_BOOL_XOR_SPEC_CV_CONST_HANDLER, /* 370 */
    ZEND_BOOL_XOR_SPEC_CV_TMP_HANDLER, /* 371 */
    ZEND_BOOL_XOR_SPEC_CV_VAR_HANDLER, /* 372 */
    ZEND_NULL_HANDLER, /* 373 */
    ZEND_BOOL_XOR_SPEC_CV_CV_HANDLER, /* 374 */
    ZEND_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER, /* 375 */
    ZEND_IS_IDENTICAL_SPEC_CONST_TMP_HANDLER, /* 376 */
    ZEND_IS_IDENTICAL_SPEC_CONST_VAR_HANDLER, /* 377 */
    ZEND_NULL_HANDLER, /* 378 */
    ZEND_IS_IDENTICAL_SPEC_CONST_CV_HANDLER, /* 379 */
    ZEND_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER, /* 380 */
    ZEND_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER, /* 381 */
    ZEND_IS_IDENTICAL_SPEC_TMP_VAR_HANDLER, /* 382 */
    ZEND_NULL_HANDLER, /* 383 */
    ZEND_IS_IDENTICAL_SPEC_TMP_CV_HANDLER, /* 384 */
    ZEND_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER, /* 385 */
    ZEND_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER, /* 386 */
    ZEND_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER, /* 387 */
    ZEND_NULL_HANDLER, /* 388 */
    ZEND_IS_IDENTICAL_SPEC_VAR_CV_HANDLER, /* 389 */
    ZEND_NULL_HANDLER, /* 390 */
    ZEND_NULL_HANDLER, /* 391 */
    ZEND_NULL_HANDLER, /* 392 */
    ZEND_NULL_HANDLER, /* 393 */
    ZEND_NULL_HANDLER, /* 394 */
    ZEND_IS_IDENTICAL_SPEC_CV_CONST_HANDLER, /* 395 */
    ZEND_IS_IDENTICAL_SPEC_CV_TMP_HANDLER, /* 396 */
    ZEND_IS_IDENTICAL_SPEC_CV_VAR_HANDLER, /* 397 */
    ZEND_NULL_HANDLER, /* 398 */
    ZEND_IS_IDENTICAL_SPEC_CV_CV_HANDLER, /* 399 */
    ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER, /* 400 */
    ZEND_IS_NOT_IDENTICAL_SPEC_CONST_TMP_HANDLER, /* 401 */
    ZEND_IS_NOT_IDENTICAL_SPEC_CONST_VAR_HANDLER, /* 402 */
    ZEND_NULL_HANDLER, /* 403 */
    ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CV_HANDLER, /* 404 */
    ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER, /* 405 */
    ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER, /* 406 */
    ZEND_IS_NOT_IDENTICAL_SPEC_TMP_VAR_HANDLER, /* 407 */
    ZEND_NULL_HANDLER, /* 408 */
    ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CV_HANDLER, /* 409 */
    ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER, /* 410 */
    ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER, /* 411 */
    ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER, /* 412 */
    ZEND_NULL_HANDLER, /* 413 */
    ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CV_HANDLER, /* 414 */
    ZEND_NULL_HANDLER, /* 415 */
    ZEND_NULL_HANDLER, /* 416 */
    ZEND_NULL_HANDLER, /* 417 */
    ZEND_NULL_HANDLER, /* 418 */
    ZEND_NULL_HANDLER, /* 419 */
    ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER, /* 420 */
    ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER, /* 421 */
    ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER, /* 422 */
    ZEND_NULL_HANDLER, /* 423 */
    ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER, /* 424 */
    ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER, /* 425 */
    ZEND_IS_EQUAL_SPEC_CONST_TMP_HANDLER, /* 426 */
    ZEND_IS_EQUAL_SPEC_CONST_VAR_HANDLER, /* 427 */
    ZEND_NULL_HANDLER, /* 428 */
    ZEND_IS_EQUAL_SPEC_CONST_CV_HANDLER, /* 429 */
    ZEND_IS_EQUAL_SPEC_TMP_CONST_HANDLER, /* 430 */
    ZEND_IS_EQUAL_SPEC_TMP_TMP_HANDLER, /* 431 */
    ZEND_IS_EQUAL_SPEC_TMP_VAR_HANDLER, /* 432 */
    ZEND_NULL_HANDLER, /* 433 */
    ZEND_IS_EQUAL_SPEC_TMP_CV_HANDLER, /* 434 */
    ZEND_IS_EQUAL_SPEC_VAR_CONST_HANDLER, /* 435 */
    ZEND_IS_EQUAL_SPEC_VAR_TMP_HANDLER, /* 436 */
    ZEND_IS_EQUAL_SPEC_VAR_VAR_HANDLER, /* 437 */
    ZEND_NULL_HANDLER, /* 438 */
    ZEND_IS_EQUAL_SPEC_VAR_CV_HANDLER, /* 439 */
    ZEND_NULL_HANDLER, /* 440 */
    ZEND_NULL_HANDLER, /* 441 */
    ZEND_NULL_HANDLER, /* 442 */
    ZEND_NULL_HANDLER, /* 443 */
    ZEND_NULL_HANDLER, /* 444 */
    ZEND_IS_EQUAL_SPEC_CV_CONST_HANDLER, /* 445 */
    ZEND_IS_EQUAL_SPEC_CV_TMP_HANDLER, /* 446 */
    ZEND_IS_EQUAL_SPEC_CV_VAR_HANDLER, /* 447 */
    ZEND_NULL_HANDLER, /* 448 */
    ZEND_IS_EQUAL_SPEC_CV_CV_HANDLER, /* 449 */
    ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER, /* 450 */
    ZEND_IS_NOT_EQUAL_SPEC_CONST_TMP_HANDLER, /* 451 */
    ZEND_IS_NOT_EQUAL_SPEC_CONST_VAR_HANDLER, /* 452 */
    ZEND_NULL_HANDLER, /* 453 */
    ZEND_IS_NOT_EQUAL_SPEC_CONST_CV_HANDLER, /* 454 */
    ZEND_IS_NOT_EQUAL_SPEC_TMP_CONST_HANDLER, /* 455 */
    ZEND_IS_NOT_EQUAL_SPEC_TMP_TMP_HANDLER, /* 456 */
    ZEND_IS_NOT_EQUAL_SPEC_TMP_VAR_HANDLER, /* 457 */
    ZEND_NULL_HANDLER, /* 458 */
    ZEND_IS_NOT_EQUAL_SPEC_TMP_CV_HANDLER, /* 459 */
    ZEND_IS_NOT_EQUAL_SPEC_VAR_CONST_HANDLER, /* 460 */
    ZEND_IS_NOT_EQUAL_SPEC_VAR_TMP_HANDLER, /* 461 */
    ZEND_IS_NOT_EQUAL_SPEC_VAR_VAR_HANDLER, /* 462 */
    ZEND_NULL_HANDLER, /* 463 */
    ZEND_IS_NOT_EQUAL_SPEC_VAR_CV_HANDLER, /* 464 */
    ZEND_NULL_HANDLER, /* 465 */
    ZEND_NULL_HANDLER, /* 466 */
    ZEND_NULL_HANDLER, /* 467 */
    ZEND_NULL_HANDLER, /* 468 */
    ZEND_NULL_HANDLER, /* 469 */
    ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER, /* 470 */
    ZEND_IS_NOT_EQUAL_SPEC_CV_TMP_HANDLER, /* 471 */
    ZEND_IS_NOT_EQUAL_SPEC_CV_VAR_HANDLER, /* 472 */
    ZEND_NULL_HANDLER, /* 473 */
    ZEND_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER, /* 474 */
    ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER, /* 475 */
    ZEND_IS_SMALLER_SPEC_CONST_TMP_HANDLER, /* 476 */
    ZEND_IS_SMALLER_SPEC_CONST_VAR_HANDLER, /* 477 */
    ZEND_NULL_HANDLER, /* 478 */
    ZEND_IS_SMALLER_SPEC_CONST_CV_HANDLER, /* 479 */
    ZEND_IS_SMALLER_SPEC_TMP_CONST_HANDLER, /* 480 */
    ZEND_IS_SMALLER_SPEC_TMP_TMP_HANDLER, /* 481 */
    ZEND_IS_SMALLER_SPEC_TMP_VAR_HANDLER, /* 482 */
    ZEND_NULL_HANDLER, /* 483 */
    ZEND_IS_SMALLER_SPEC_TMP_CV_HANDLER, /* 484 */
    ZEND_IS_SMALLER_SPEC_VAR_CONST_HANDLER, /* 485 */
    ZEND_IS_SMALLER_SPEC_VAR_TMP_HANDLER, /* 486 */
    ZEND_IS_SMALLER_SPEC_VAR_VAR_HANDLER, /* 487 */
    ZEND_NULL_HANDLER, /* 488 */
    ZEND_IS_SMALLER_SPEC_VAR_CV_HANDLER, /* 489 */
    ZEND_NULL_HANDLER, /* 490 */
    ZEND_NULL_HANDLER, /* 491 */
    ZEND_NULL_HANDLER, /* 492 */
    ZEND_NULL_HANDLER, /* 493 */
    ZEND_NULL_HANDLER, /* 494 */
    ZEND_IS_SMALLER_SPEC_CV_CONST_HANDLER, /* 495 */
    ZEND_IS_SMALLER_SPEC_CV_TMP_HANDLER, /* 496 */
    ZEND_IS_SMALLER_SPEC_CV_VAR_HANDLER, /* 497 */
    ZEND_NULL_HANDLER, /* 498 */
    ZEND_IS_SMALLER_SPEC_CV_CV_HANDLER, /* 499 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER, /* 500 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMP_HANDLER, /* 501 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_VAR_HANDLER, /* 502 */
    ZEND_NULL_HANDLER, /* 503 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CV_HANDLER, /* 504 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CONST_HANDLER, /* 505 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_TMP_HANDLER, /* 506 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_VAR_HANDLER, /* 507 */
    ZEND_NULL_HANDLER, /* 508 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CV_HANDLER, /* 509 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CONST_HANDLER, /* 510 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_TMP_HANDLER, /* 511 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_VAR_HANDLER, /* 512 */
    ZEND_NULL_HANDLER, /* 513 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CV_HANDLER, /* 514 */
    ZEND_NULL_HANDLER, /* 515 */
    ZEND_NULL_HANDLER, /* 516 */
    ZEND_NULL_HANDLER, /* 517 */
    ZEND_NULL_HANDLER, /* 518 */
    ZEND_NULL_HANDLER, /* 519 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CONST_HANDLER, /* 520 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_TMP_HANDLER, /* 521 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_VAR_HANDLER, /* 522 */
    ZEND_NULL_HANDLER, /* 523 */
    ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CV_HANDLER, /* 524 */
    ZEND_CAST_SPEC_CONST_HANDLER, /* 525 */
    ZEND_CAST_SPEC_CONST_HANDLER, /* 526 */
    ZEND_CAST_SPEC_CONST_HANDLER, /* 527 */
    ZEND_CAST_SPEC_CONST_HANDLER, /* 528 */
    ZEND_CAST_SPEC_CONST_HANDLER, /* 529 */
    ZEND_CAST_SPEC_TMP_HANDLER, /* 530 */
    ZEND_CAST_SPEC_TMP_HANDLER, /* 531 */
    ZEND_CAST_SPEC_TMP_HANDLER, /* 532 */
    ZEND_CAST_SPEC_TMP_HANDLER, /* 533 */
    ZEND_CAST_SPEC_TMP_HANDLER, /* 534 */
    ZEND_CAST_SPEC_VAR_HANDLER, /* 535 */
    ZEND_CAST_SPEC_VAR_HANDLER, /* 536 */
    ZEND_CAST_SPEC_VAR_HANDLER, /* 537 */
    ZEND_CAST_SPEC_VAR_HANDLER, /* 538 */
    ZEND_CAST_SPEC_VAR_HANDLER, /* 539 */
    ZEND_NULL_HANDLER, /* 540 */
    ZEND_NULL_HANDLER, /* 541 */
    ZEND_NULL_HANDLER, /* 542 */
    ZEND_NULL_HANDLER, /* 543 */
    ZEND_NULL_HANDLER, /* 544 */
    ZEND_CAST_SPEC_CV_HANDLER, /* 545 */
    ZEND_CAST_SPEC_CV_HANDLER, /* 546 */
    ZEND_CAST_SPEC_CV_HANDLER, /* 547 */
    ZEND_CAST_SPEC_CV_HANDLER, /* 548 */
    ZEND_CAST_SPEC_CV_HANDLER, /* 549 */
    ZEND_QM_ASSIGN_SPEC_CONST_HANDLER, /* 550 */
    ZEND_QM_ASSIGN_SPEC_CONST_HANDLER, /* 551 */
    ZEND_QM_ASSIGN_SPEC_CONST_HANDLER, /* 552 */
    ZEND_QM_ASSIGN_SPEC_CONST_HANDLER, /* 553 */
    ZEND_QM_ASSIGN_SPEC_CONST_HANDLER, /* 554 */
    ZEND_QM_ASSIGN_SPEC_TMP_HANDLER, /* 555 */
    ZEND_QM_ASSIGN_SPEC_TMP_HANDLER, /* 556 */
    ZEND_QM_ASSIGN_SPEC_TMP_HANDLER, /* 557 */
    ZEND_QM_ASSIGN_SPEC_TMP_HANDLER, /* 558 */
    ZEND_QM_ASSIGN_SPEC_TMP_HANDLER, /* 559 */
    ZEND_QM_ASSIGN_SPEC_VAR_HANDLER, /* 560 */
    ZEND_QM_ASSIGN_SPEC_VAR_HANDLER, /* 561 */
    ZEND_QM_ASSIGN_SPEC_VAR_HANDLER, /* 562 */
    ZEND_QM_ASSIGN_SPEC_VAR_HANDLER, /* 563 */
    ZEND_QM_ASSIGN_SPEC_VAR_HANDLER, /* 564 */
    ZEND_NULL_HANDLER, /* 565 */
    ZEND_NULL_HANDLER, /* 566 */
    ZEND_NULL_HANDLER, /* 567 */
    ZEND_NULL_HANDLER, /* 568 */
    ZEND_NULL_HANDLER, /* 569 */
    ZEND_QM_ASSIGN_SPEC_CV_HANDLER, /* 570 */
    ZEND_QM_ASSIGN_SPEC_CV_HANDLER, /* 571 */
    ZEND_QM_ASSIGN_SPEC_CV_HANDLER, /* 572 */
    ZEND_QM_ASSIGN_SPEC_CV_HANDLER, /* 573 */
    ZEND_QM_ASSIGN_SPEC_CV_HANDLER, /* 574 */
    ZEND_NULL_HANDLER, /* 575 */
    ZEND_NULL_HANDLER, /* 576 */
    ZEND_NULL_HANDLER, /* 577 */
    ZEND_NULL_HANDLER, /* 578 */
    ZEND_NULL_HANDLER, /* 579 */
    ZEND_NULL_HANDLER, /* 580 */
    ZEND_NULL_HANDLER, /* 581 */
    ZEND_NULL_HANDLER, /* 582 */
    ZEND_NULL_HANDLER, /* 583 */
    ZEND_NULL_HANDLER, /* 584 */
    ZEND_ASSIGN_ADD_SPEC_VAR_CONST_HANDLER, /* 585 */
    ZEND_ASSIGN_ADD_SPEC_VAR_TMP_HANDLER, /* 586 */
    ZEND_ASSIGN_ADD_SPEC_VAR_VAR_HANDLER, /* 587 */
    ZEND_ASSIGN_ADD_SPEC_VAR_UNUSED_HANDLER, /* 588 */
    ZEND_ASSIGN_ADD_SPEC_VAR_CV_HANDLER, /* 589 */
    ZEND_ASSIGN_ADD_SPEC_UNUSED_CONST_HANDLER, /* 590 */
    ZEND_ASSIGN_ADD_SPEC_UNUSED_TMP_HANDLER, /* 591 */
    ZEND_ASSIGN_ADD_SPEC_UNUSED_VAR_HANDLER, /* 592 */
    ZEND_ASSIGN_ADD_SPEC_UNUSED_UNUSED_HANDLER, /* 593 */
    ZEND_ASSIGN_ADD_SPEC_UNUSED_CV_HANDLER, /* 594 */
    ZEND_ASSIGN_ADD_SPEC_CV_CONST_HANDLER, /* 595 */
    ZEND_ASSIGN_ADD_SPEC_CV_TMP_HANDLER, /* 596 */
    ZEND_ASSIGN_ADD_SPEC_CV_VAR_HANDLER, /* 597 */
    ZEND_ASSIGN_ADD_SPEC_CV_UNUSED_HANDLER, /* 598 */
    ZEND_ASSIGN_ADD_SPEC_CV_CV_HANDLER, /* 599 */
    ZEND_NULL_HANDLER, /* 600 */
    ZEND_NULL_HANDLER, /* 601 */
    ZEND_NULL_HANDLER, /* 602 */
    ZEND_NULL_HANDLER, /* 603 */
    ZEND_NULL_HANDLER, /* 604 */
    ZEND_NULL_HANDLER, /* 605 */
    ZEND_NULL_HANDLER, /* 606 */
    ZEND_NULL_HANDLER, /* 607 */
    ZEND_NULL_HANDLER, /* 608 */
    ZEND_NULL_HANDLER, /* 609 */
    ZEND_ASSIGN_SUB_SPEC_VAR_CONST_HANDLER, /* 610 */
    ZEND_ASSIGN_SUB_SPEC_VAR_TMP_HANDLER, /* 611 */
    ZEND_ASSIGN_SUB_SPEC_VAR_VAR_HANDLER, /* 612 */
    ZEND_ASSIGN_SUB_SPEC_VAR_UNUSED_HANDLER, /* 613 */
    ZEND_ASSIGN_SUB_SPEC_VAR_CV_HANDLER, /* 614 */
    ZEND_ASSIGN_SUB_SPEC_UNUSED_CONST_HANDLER, /* 615 */
    ZEND_ASSIGN_SUB_SPEC_UNUSED_TMP_HANDLER, /* 616 */
    ZEND_ASSIGN_SUB_SPEC_UNUSED_VAR_HANDLER, /* 617 */
    ZEND_ASSIGN_SUB_SPEC_UNUSED_UNUSED_HANDLER, /* 618 */
    ZEND_ASSIGN_SUB_SPEC_UNUSED_CV_HANDLER, /* 619 */
    ZEND_ASSIGN_SUB_SPEC_CV_CONST_HANDLER, /* 620 */
    ZEND_ASSIGN_SUB_SPEC_CV_TMP_HANDLER, /* 621 */
    ZEND_ASSIGN_SUB_SPEC_CV_VAR_HANDLER, /* 622 */
    ZEND_ASSIGN_SUB_SPEC_CV_UNUSED_HANDLER, /* 623 */
    ZEND_ASSIGN_SUB_SPEC_CV_CV_HANDLER, /* 624 */
    ZEND_NULL_HANDLER, /* 625 */
    ZEND_NULL_HANDLER, /* 626 */
    ZEND_NULL_HANDLER, /* 627 */
    ZEND_NULL_HANDLER, /* 628 */
    ZEND_NULL_HANDLER, /* 629 */
    ZEND_NULL_HANDLER, /* 630 */
    ZEND_NULL_HANDLER, /* 631 */
    ZEND_NULL_HANDLER, /* 632 */
    ZEND_NULL_HANDLER, /* 633 */
    ZEND_NULL_HANDLER, /* 634 */
    ZEND_ASSIGN_MUL_SPEC_VAR_CONST_HANDLER, /* 635 */
    ZEND_ASSIGN_MUL_SPEC_VAR_TMP_HANDLER, /* 636 */
    ZEND_ASSIGN_MUL_SPEC_VAR_VAR_HANDLER, /* 637 */
    ZEND_ASSIGN_MUL_SPEC_VAR_UNUSED_HANDLER, /* 638 */
    ZEND_ASSIGN_MUL_SPEC_VAR_CV_HANDLER, /* 639 */
    ZEND_ASSIGN_MUL_SPEC_UNUSED_CONST_HANDLER, /* 640 */
    ZEND_ASSIGN_MUL_SPEC_UNUSED_TMP_HANDLER, /* 641 */
    ZEND_ASSIGN_MUL_SPEC_UNUSED_VAR_HANDLER, /* 642 */
    ZEND_ASSIGN_MUL_SPEC_UNUSED_UNUSED_HANDLER, /* 643 */
    ZEND_ASSIGN_MUL_SPEC_UNUSED_CV_HANDLER, /* 644 */
    ZEND_ASSIGN_MUL_SPEC_CV_CONST_HANDLER, /* 645 */
    ZEND_ASSIGN_MUL_SPEC_CV_TMP_HANDLER, /* 646 */
    ZEND_ASSIGN_MUL_SPEC_CV_VAR_HANDLER, /* 647 */
    ZEND_ASSIGN_MUL_SPEC_CV_UNUSED_HANDLER, /* 648 */
    ZEND_ASSIGN_MUL_SPEC_CV_CV_HANDLER, /* 649 */
    ZEND_NULL_HANDLER, /* 650 */
    ZEND_NULL_HANDLER, /* 651 */
    ZEND_NULL_HANDLER, /* 652 */
    ZEND_NULL_HANDLER, /* 653 */
    ZEND_NULL_HANDLER, /* 654 */
    ZEND_NULL_HANDLER, /* 655 */
    ZEND_NULL_HANDLER, /* 656 */
    ZEND_NULL_HANDLER, /* 657 */
    ZEND_NULL_HANDLER, /* 658 */
    ZEND_NULL_HANDLER, /* 659 */
    ZEND_ASSIGN_DIV_SPEC_VAR_CONST_HANDLER, /* 660 */
    ZEND_ASSIGN_DIV_SPEC_VAR_TMP_HANDLER, /* 661 */
    ZEND_ASSIGN_DIV_SPEC_VAR_VAR_HANDLER, /* 662 */
    ZEND_ASSIGN_DIV_SPEC_VAR_UNUSED_HANDLER, /* 663 */
    ZEND_ASSIGN_DIV_SPEC_VAR_CV_HANDLER, /* 664 */
    ZEND_ASSIGN_DIV_SPEC_UNUSED_CONST_HANDLER, /* 665 */
    ZEND_ASSIGN_DIV_SPEC_UNUSED_TMP_HANDLER, /* 666 */
    ZEND_ASSIGN_DIV_SPEC_UNUSED_VAR_HANDLER, /* 667 */
    ZEND_ASSIGN_DIV_SPEC_UNUSED_UNUSED_HANDLER, /* 668 */
    ZEND_ASSIGN_DIV_SPEC_UNUSED_CV_HANDLER, /* 669 */
    ZEND_ASSIGN_DIV_SPEC_CV_CONST_HANDLER, /* 670 */
    ZEND_ASSIGN_DIV_SPEC_CV_TMP_HANDLER, /* 671 */
    ZEND_ASSIGN_DIV_SPEC_CV_VAR_HANDLER, /* 672 */
    ZEND_ASSIGN_DIV_SPEC_CV_UNUSED_HANDLER, /* 673 */
    ZEND_ASSIGN_DIV_SPEC_CV_CV_HANDLER, /* 674 */
    ZEND_NULL_HANDLER, /* 675 */
    ZEND_NULL_HANDLER, /* 676 */
    ZEND_NULL_HANDLER, /* 677 */
    ZEND_NULL_HANDLER, /* 678 */
    ZEND_NULL_HANDLER, /* 679 */
    ZEND_NULL_HANDLER, /* 680 */
    ZEND_NULL_HANDLER, /* 681 */
    ZEND_NULL_HANDLER, /* 682 */
    ZEND_NULL_HANDLER, /* 683 */
    ZEND_NULL_HANDLER, /* 684 */
    ZEND_ASSIGN_MOD_SPEC_VAR_CONST_HANDLER, /* 685 */
    ZEND_ASSIGN_MOD_SPEC_VAR_TMP_HANDLER, /* 686 */
    ZEND_ASSIGN_MOD_SPEC_VAR_VAR_HANDLER, /* 687 */
    ZEND_ASSIGN_MOD_SPEC_VAR_UNUSED_HANDLER, /* 688 */
    ZEND_ASSIGN_MOD_SPEC_VAR_CV_HANDLER, /* 689 */
    ZEND_ASSIGN_MOD_SPEC_UNUSED_CONST_HANDLER, /* 690 */
    ZEND_ASSIGN_MOD_SPEC_UNUSED_TMP_HANDLER, /* 691 */
    ZEND_ASSIGN_MOD_SPEC_UNUSED_VAR_HANDLER, /* 692 */
    ZEND_ASSIGN_MOD_SPEC_UNUSED_UNUSED_HANDLER, /* 693 */
    ZEND_ASSIGN_MOD_SPEC_UNUSED_CV_HANDLER, /* 694 */
    ZEND_ASSIGN_MOD_SPEC_CV_CONST_HANDLER, /* 695 */
    ZEND_ASSIGN_MOD_SPEC_CV_TMP_HANDLER, /* 696 */
    ZEND_ASSIGN_MOD_SPEC_CV_VAR_HANDLER, /* 697 */
    ZEND_ASSIGN_MOD_SPEC_CV_UNUSED_HANDLER, /* 698 */
    ZEND_ASSIGN_MOD_SPEC_CV_CV_HANDLER, /* 699 */
    ZEND_NULL_HANDLER, /* 700 */
    ZEND_NULL_HANDLER, /* 701 */
    ZEND_NULL_HANDLER, /* 702 */
    ZEND_NULL_HANDLER, /* 703 */
    ZEND_NULL_HANDLER, /* 704 */
    ZEND_NULL_HANDLER, /* 705 */
    ZEND_NULL_HANDLER, /* 706 */
    ZEND_NULL_HANDLER, /* 707 */
    ZEND_NULL_HANDLER, /* 708 */
    ZEND_NULL_HANDLER, /* 709 */
    ZEND_ASSIGN_SL_SPEC_VAR_CONST_HANDLER, /* 710 */
    ZEND_ASSIGN_SL_SPEC_VAR_TMP_HANDLER, /* 711 */
    ZEND_ASSIGN_SL_SPEC_VAR_VAR_HANDLER, /* 712 */
    ZEND_ASSIGN_SL_SPEC_VAR_UNUSED_HANDLER, /* 713 */
    ZEND_ASSIGN_SL_SPEC_VAR_CV_HANDLER, /* 714 */
    ZEND_ASSIGN_SL_SPEC_UNUSED_CONST_HANDLER, /* 715 */
    ZEND_ASSIGN_SL_SPEC_UNUSED_TMP_HANDLER, /* 716 */
    ZEND_ASSIGN_SL_SPEC_UNUSED_VAR_HANDLER, /* 717 */
    ZEND_ASSIGN_SL_SPEC_UNUSED_UNUSED_HANDLER, /* 718 */
    ZEND_ASSIGN_SL_SPEC_UNUSED_CV_HANDLER, /* 719 */
    ZEND_ASSIGN_SL_SPEC_CV_CONST_HANDLER, /* 720 */
    ZEND_ASSIGN_SL_SPEC_CV_TMP_HANDLER, /* 721 */
    ZEND_ASSIGN_SL_SPEC_CV_VAR_HANDLER, /* 722 */
    ZEND_ASSIGN_SL_SPEC_CV_UNUSED_HANDLER, /* 723 */
    ZEND_ASSIGN_SL_SPEC_CV_CV_HANDLER, /* 724 */
    ZEND_NULL_HANDLER, /* 725 */
    ZEND_NULL_HANDLER, /* 726 */
    ZEND_NULL_HANDLER, /* 727 */
    ZEND_NULL_HANDLER, /* 728 */
    ZEND_NULL_HANDLER, /* 729 */
    ZEND_NULL_HANDLER, /* 730 */
    ZEND_NULL_HANDLER, /* 731 */
    ZEND_NULL_HANDLER, /* 732 */
    ZEND_NULL_HANDLER, /* 733 */
    ZEND_NULL_HANDLER, /* 734 */
    ZEND_ASSIGN_SR_SPEC_VAR_CONST_HANDLER, /* 735 */
    ZEND_ASSIGN_SR_SPEC_VAR_TMP_HANDLER, /* 736 */
    ZEND_ASSIGN_SR_SPEC_VAR_VAR_HANDLER, /* 737 */
    ZEND_ASSIGN_SR_SPEC_VAR_UNUSED_HANDLER, /* 738 */
    ZEND_ASSIGN_SR_SPEC_VAR_CV_HANDLER, /* 739 */
    ZEND_ASSIGN_SR_SPEC_UNUSED_CONST_HANDLER, /* 740 */
    ZEND_ASSIGN_SR_SPEC_UNUSED_TMP_HANDLER, /* 741 */
    ZEND_ASSIGN_SR_SPEC_UNUSED_VAR_HANDLER, /* 742 */
    ZEND_ASSIGN_SR_SPEC_UNUSED_UNUSED_HANDLER, /* 743 */
    ZEND_ASSIGN_SR_SPEC_UNUSED_CV_HANDLER, /* 744 */
    ZEND_ASSIGN_SR_SPEC_CV_CONST_HANDLER, /* 745 */
    ZEND_ASSIGN_SR_SPEC_CV_TMP_HANDLER, /* 746 */
    ZEND_ASSIGN_SR_SPEC_CV_VAR_HANDLER, /* 747 */
    ZEND_ASSIGN_SR_SPEC_CV_UNUSED_HANDLER, /* 748 */
    ZEND_ASSIGN_SR_SPEC_CV_CV_HANDLER, /* 749 */
    ZEND_NULL_HANDLER, /* 750 */
    ZEND_NULL_HANDLER, /* 751 */
    ZEND_NULL_HANDLER, /* 752 */
    ZEND_NULL_HANDLER, /* 753 */
    ZEND_NULL_HANDLER, /* 754 */
    ZEND_NULL_HANDLER, /* 755 */
    ZEND_NULL_HANDLER, /* 756 */
    ZEND_NULL_HANDLER, /* 757 */
    ZEND_NULL_HANDLER, /* 758 */
    ZEND_NULL_HANDLER, /* 759 */
    ZEND_ASSIGN_CONCAT_SPEC_VAR_CONST_HANDLER, /* 760 */
    ZEND_ASSIGN_CONCAT_SPEC_VAR_TMP_HANDLER, /* 761 */
    ZEND_ASSIGN_CONCAT_SPEC_VAR_VAR_HANDLER, /* 762 */
    ZEND_ASSIGN_CONCAT_SPEC_VAR_UNUSED_HANDLER, /* 763 */
    ZEND_ASSIGN_CONCAT_SPEC_VAR_CV_HANDLER, /* 764 */
    ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CONST_HANDLER, /* 765 */
    ZEND_ASSIGN_CONCAT_SPEC_UNUSED_TMP_HANDLER, /* 766 */
    ZEND_ASSIGN_CONCAT_SPEC_UNUSED_VAR_HANDLER, /* 767 */
    ZEND_ASSIGN_CONCAT_SPEC_UNUSED_UNUSED_HANDLER, /* 768 */
    ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CV_HANDLER, /* 769 */
    ZEND_ASSIGN_CONCAT_SPEC_CV_CONST_HANDLER, /* 770 */
    ZEND_ASSIGN_CONCAT_SPEC_CV_TMP_HANDLER, /* 771 */
    ZEND_ASSIGN_CONCAT_SPEC_CV_VAR_HANDLER, /* 772 */
    ZEND_ASSIGN_CONCAT_SPEC_CV_UNUSED_HANDLER, /* 773 */
    ZEND_ASSIGN_CONCAT_SPEC_CV_CV_HANDLER, /* 774 */
    ZEND_NULL_HANDLER, /* 775 */
    ZEND_NULL_HANDLER, /* 776 */
    ZEND_NULL_HANDLER, /* 777 */
    ZEND_NULL_HANDLER, /* 778 */
    ZEND_NULL_HANDLER, /* 779 */
    ZEND_NULL_HANDLER, /* 780 */
    ZEND_NULL_HANDLER, /* 781 */
    ZEND_NULL_HANDLER, /* 782 */
    ZEND_NULL_HANDLER, /* 783 */
    ZEND_NULL_HANDLER, /* 784 */
    ZEND_ASSIGN_BW_OR_SPEC_VAR_CONST_HANDLER, /* 785 */
    ZEND_ASSIGN_BW_OR_SPEC_VAR_TMP_HANDLER, /* 786 */
    ZEND_ASSIGN_BW_OR_SPEC_VAR_VAR_HANDLER, /* 787 */
    ZEND_ASSIGN_BW_OR_SPEC_VAR_UNUSED_HANDLER, /* 788 */
    ZEND_ASSIGN_BW_OR_SPEC_VAR_CV_HANDLER, /* 789 */
    ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CONST_HANDLER, /* 790 */
    ZEND_ASSIGN_BW_OR_SPEC_UNUSED_TMP_HANDLER, /* 791 */
    ZEND_ASSIGN_BW_OR_SPEC_UNUSED_VAR_HANDLER, /* 792 */
    ZEND_ASSIGN_BW_OR_SPEC_UNUSED_UNUSED_HANDLER, /* 793 */
    ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CV_HANDLER, /* 794 */
    ZEND_ASSIGN_BW_OR_SPEC_CV_CONST_HANDLER, /* 795 */
    ZEND_ASSIGN_BW_OR_SPEC_CV_TMP_HANDLER, /* 796 */
    ZEND_ASSIGN_BW_OR_SPEC_CV_VAR_HANDLER, /* 797 */
    ZEND_ASSIGN_BW_OR_SPEC_CV_UNUSED_HANDLER, /* 798 */
    ZEND_ASSIGN_BW_OR_SPEC_CV_CV_HANDLER, /* 799 */
    ZEND_NULL_HANDLER, /* 800 */
    ZEND_NULL_HANDLER, /* 801 */
    ZEND_NULL_HANDLER, /* 802 */
    ZEND_NULL_HANDLER, /* 803 */
    ZEND_NULL_HANDLER, /* 804 */
    ZEND_NULL_HANDLER, /* 805 */
    ZEND_NULL_HANDLER, /* 806 */
    ZEND_NULL_HANDLER, /* 807 */
    ZEND_NULL_HANDLER, /* 808 */
    ZEND_NULL_HANDLER, /* 809 */
    ZEND_ASSIGN_BW_AND_SPEC_VAR_CONST_HANDLER, /* 810 */
    ZEND_ASSIGN_BW_AND_SPEC_VAR_TMP_HANDLER, /* 811 */
    ZEND_ASSIGN_BW_AND_SPEC_VAR_VAR_HANDLER, /* 812 */
    ZEND_ASSIGN_BW_AND_SPEC_VAR_UNUSED_HANDLER, /* 813 */
    ZEND_ASSIGN_BW_AND_SPEC_VAR_CV_HANDLER, /* 814 */
    ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CONST_HANDLER, /* 815 */
    ZEND_ASSIGN_BW_AND_SPEC_UNUSED_TMP_HANDLER, /* 816 */
    ZEND_ASSIGN_BW_AND_SPEC_UNUSED_VAR_HANDLER, /* 817 */
    ZEND_ASSIGN_BW_AND_SPEC_UNUSED_UNUSED_HANDLER, /* 818 */
    ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CV_HANDLER, /* 819 */
    ZEND_ASSIGN_BW_AND_SPEC_CV_CONST_HANDLER, /* 820 */
    ZEND_ASSIGN_BW_AND_SPEC_CV_TMP_HANDLER, /* 821 */
    ZEND_ASSIGN_BW_AND_SPEC_CV_VAR_HANDLER, /* 822 */
    ZEND_ASSIGN_BW_AND_SPEC_CV_UNUSED_HANDLER, /* 823 */
    ZEND_ASSIGN_BW_AND_SPEC_CV_CV_HANDLER, /* 824 */
    ZEND_NULL_HANDLER, /* 825 */
    ZEND_NULL_HANDLER, /* 826 */
    ZEND_NULL_HANDLER, /* 827 */
    ZEND_NULL_HANDLER, /* 828 */
    ZEND_NULL_HANDLER, /* 829 */
    ZEND_NULL_HANDLER, /* 830 */
    ZEND_NULL_HANDLER, /* 831 */
    ZEND_NULL_HANDLER, /* 832 */
    ZEND_NULL_HANDLER, /* 833 */
    ZEND_NULL_HANDLER, /* 834 */
    ZEND_ASSIGN_BW_XOR_SPEC_VAR_CONST_HANDLER, /* 835 */
    ZEND_ASSIGN_BW_XOR_SPEC_VAR_TMP_HANDLER, /* 836 */
    ZEND_ASSIGN_BW_XOR_SPEC_VAR_VAR_HANDLER, /* 837 */
    ZEND_ASSIGN_BW_XOR_SPEC_VAR_UNUSED_HANDLER, /* 838 */
    ZEND_ASSIGN_BW_XOR_SPEC_VAR_CV_HANDLER, /* 839 */
    ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CONST_HANDLER, /* 840 */
    ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_TMP_HANDLER, /* 841 */
    ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_VAR_HANDLER, /* 842 */
    ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_UNUSED_HANDLER, /* 843 */
    ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CV_HANDLER, /* 844 */
    ZEND_ASSIGN_BW_XOR_SPEC_CV_CONST_HANDLER, /* 845 */
    ZEND_ASSIGN_BW_XOR_SPEC_CV_TMP_HANDLER, /* 846 */
    ZEND_ASSIGN_BW_XOR_SPEC_CV_VAR_HANDLER, /* 847 */
    ZEND_ASSIGN_BW_XOR_SPEC_CV_UNUSED_HANDLER, /* 848 */
    ZEND_ASSIGN_BW_XOR_SPEC_CV_CV_HANDLER, /* 849 */
    ZEND_NULL_HANDLER, /* 850 */
    ZEND_NULL_HANDLER, /* 851 */
    ZEND_NULL_HANDLER, /* 852 */
    ZEND_NULL_HANDLER, /* 853 */
    ZEND_NULL_HANDLER, /* 854 */
    ZEND_NULL_HANDLER, /* 855 */
    ZEND_NULL_HANDLER, /* 856 */
    ZEND_NULL_HANDLER, /* 857 */
    ZEND_NULL_HANDLER, /* 858 */
    ZEND_NULL_HANDLER, /* 859 */
    ZEND_PRE_INC_SPEC_VAR_HANDLER, /* 860 */
    ZEND_PRE_INC_SPEC_VAR_HANDLER, /* 861 */
    ZEND_PRE_INC_SPEC_VAR_HANDLER, /* 862 */
    ZEND_PRE_INC_SPEC_VAR_HANDLER, /* 863 */
    ZEND_PRE_INC_SPEC_VAR_HANDLER, /* 864 */
    ZEND_NULL_HANDLER, /* 865 */
    ZEND_NULL_HANDLER, /* 866 */
    ZEND_NULL_HANDLER, /* 867 */
    ZEND_NULL_HANDLER, /* 868 */
    ZEND_NULL_HANDLER, /* 869 */
    ZEND_PRE_INC_SPEC_CV_HANDLER, /* 870 */
    ZEND_PRE_INC_SPEC_CV_HANDLER, /* 871 */
    ZEND_PRE_INC_SPEC_CV_HANDLER, /* 872 */
    ZEND_PRE_INC_SPEC_CV_HANDLER, /* 873 */
    ZEND_PRE_INC_SPEC_CV_HANDLER, /* 874 */
    ZEND_NULL_HANDLER, /* 875 */
    ZEND_NULL_HANDLER, /* 876 */
    ZEND_NULL_HANDLER, /* 877 */
    ZEND_NULL_HANDLER, /* 878 */
    ZEND_NULL_HANDLER, /* 879 */
    ZEND_NULL_HANDLER, /* 880 */
    ZEND_NULL_HANDLER, /* 881 */
    ZEND_NULL_HANDLER, /* 882 */
    ZEND_NULL_HANDLER, /* 883 */
    ZEND_NULL_HANDLER, /* 884 */
    ZEND_PRE_DEC_SPEC_VAR_HANDLER, /* 885 */
    ZEND_PRE_DEC_SPEC_VAR_HANDLER, /* 886 */
    ZEND_PRE_DEC_SPEC_VAR_HANDLER, /* 887 */
    ZEND_PRE_DEC_SPEC_VAR_HANDLER, /* 888 */
    ZEND_PRE_DEC_SPEC_VAR_HANDLER, /* 889 */
    ZEND_NULL_HANDLER, /* 890 */
    ZEND_NULL_HANDLER, /* 891 */
    ZEND_NULL_HANDLER, /* 892 */
    ZEND_NULL_HANDLER, /* 893 */
    ZEND_NULL_HANDLER, /* 894 */
    ZEND_PRE_DEC_SPEC_CV_HANDLER, /* 895 */
    ZEND_PRE_DEC_SPEC_CV_HANDLER, /* 896 */
    ZEND_PRE_DEC_SPEC_CV_HANDLER, /* 897 */
    ZEND_PRE_DEC_SPEC_CV_HANDLER, /* 898 */
    ZEND_PRE_DEC_SPEC_CV_HANDLER, /* 899 */
    ZEND_NULL_HANDLER, /* 900 */
    ZEND_NULL_HANDLER, /* 901 */
    ZEND_NULL_HANDLER, /* 902 */
    ZEND_NULL_HANDLER, /* 903 */
    ZEND_NULL_HANDLER, /* 904 */
    ZEND_NULL_HANDLER, /* 905 */
    ZEND_NULL_HANDLER, /* 906 */
    ZEND_NULL_HANDLER, /* 907 */
    ZEND_NULL_HANDLER, /* 908 */
    ZEND_NULL_HANDLER, /* 909 */
    ZEND_POST_INC_SPEC_VAR_HANDLER, /* 910 */
    ZEND_POST_INC_SPEC_VAR_HANDLER, /* 911 */
    ZEND_POST_INC_SPEC_VAR_HANDLER, /* 912 */
    ZEND_POST_INC_SPEC_VAR_HANDLER, /* 913 */
    ZEND_POST_INC_SPEC_VAR_HANDLER, /* 914 */
    ZEND_NULL_HANDLER, /* 915 */
    ZEND_NULL_HANDLER, /* 916 */
    ZEND_NULL_HANDLER, /* 917 */
    ZEND_NULL_HANDLER, /* 918 */
    ZEND_NULL_HANDLER, /* 919 */
    ZEND_POST_INC_SPEC_CV_HANDLER, /* 920 */
    ZEND_POST_INC_SPEC_CV_HANDLER, /* 921 */
    ZEND_POST_INC_SPEC_CV_HANDLER, /* 922 */
    ZEND_POST_INC_SPEC_CV_HANDLER, /* 923 */
    ZEND_POST_INC_SPEC_CV_HANDLER, /* 924 */
    ZEND_NULL_HANDLER, /* 925 */
    ZEND_NULL_HANDLER, /* 926 */
    ZEND_NULL_HANDLER, /* 927 */
    ZEND_NULL_HANDLER, /* 928 */
    ZEND_NULL_HANDLER, /* 929 */
    ZEND_NULL_HANDLER, /* 930 */
    ZEND_NULL_HANDLER, /* 931 */
    ZEND_NULL_HANDLER, /* 932 */
    ZEND_NULL_HANDLER, /* 933 */
    ZEND_NULL_HANDLER, /* 934 */
    ZEND_POST_DEC_SPEC_VAR_HANDLER, /* 935 */
    ZEND_POST_DEC_SPEC_VAR_HANDLER, /* 936 */
    ZEND_POST_DEC_SPEC_VAR_HANDLER, /* 937 */
    ZEND_POST_DEC_SPEC_VAR_HANDLER, /* 938 */
    ZEND_POST_DEC_SPEC_VAR_HANDLER, /* 939 */
    ZEND_NULL_HANDLER, /* 940 */
    ZEND_NULL_HANDLER, /* 941 */
    ZEND_NULL_HANDLER, /* 942 */
    ZEND_NULL_HANDLER, /* 943 */
    ZEND_NULL_HANDLER, /* 944 */
    ZEND_POST_DEC_SPEC_CV_HANDLER, /* 945 */
    ZEND_POST_DEC_SPEC_CV_HANDLER, /* 946 */
    ZEND_POST_DEC_SPEC_CV_HANDLER, /* 947 */
    ZEND_POST_DEC_SPEC_CV_HANDLER, /* 948 */
    ZEND_POST_DEC_SPEC_CV_HANDLER, /* 949 */
    ZEND_NULL_HANDLER, /* 950 */
    ZEND_NULL_HANDLER, /* 951 */
    ZEND_NULL_HANDLER, /* 952 */
    ZEND_NULL_HANDLER, /* 953 */
    ZEND_NULL_HANDLER, /* 954 */
    ZEND_NULL_HANDLER, /* 955 */
    ZEND_NULL_HANDLER, /* 956 */
    ZEND_NULL_HANDLER, /* 957 */
    ZEND_NULL_HANDLER, /* 958 */
    ZEND_NULL_HANDLER, /* 959 */
    ZEND_ASSIGN_SPEC_VAR_CONST_HANDLER, /* 960 */
    ZEND_ASSIGN_SPEC_VAR_TMP_HANDLER, /* 961 */
    ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER, /* 962 */
    ZEND_NULL_HANDLER, /* 963 */
    ZEND_ASSIGN_SPEC_VAR_CV_HANDLER, /* 964 */
    ZEND_NULL_HANDLER, /* 965 */
    ZEND_NULL_HANDLER, /* 966 */
    ZEND_NULL_HANDLER, /* 967 */
    ZEND_NULL_HANDLER, /* 968 */
    ZEND_NULL_HANDLER, /* 969 */
    ZEND_ASSIGN_SPEC_CV_CONST_HANDLER, /* 970 */
    ZEND_ASSIGN_SPEC_CV_TMP_HANDLER, /* 971 */
    ZEND_ASSIGN_SPEC_CV_VAR_HANDLER, /* 972 */
    ZEND_NULL_HANDLER, /* 973 */
    ZEND_ASSIGN_SPEC_CV_CV_HANDLER, /* 974 */
    ZEND_NULL_HANDLER, /* 975 */
    ZEND_NULL_HANDLER, /* 976 */
    ZEND_NULL_HANDLER, /* 977 */
    ZEND_NULL_HANDLER, /* 978 */
    ZEND_NULL_HANDLER, /* 979 */
    ZEND_NULL_HANDLER, /* 980 */
    ZEND_NULL_HANDLER, /* 981 */
    ZEND_NULL_HANDLER, /* 982 */
    ZEND_NULL_HANDLER, /* 983 */
    ZEND_NULL_HANDLER, /* 984 */
    ZEND_NULL_HANDLER, /* 985 */
    ZEND_NULL_HANDLER, /* 986 */
    ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER, /* 987 */
    ZEND_NULL_HANDLER, /* 988 */
    ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER, /* 989 */
    ZEND_NULL_HANDLER, /* 990 */
    ZEND_NULL_HANDLER, /* 991 */
    ZEND_NULL_HANDLER, /* 992 */
    ZEND_NULL_HANDLER, /* 993 */
    ZEND_NULL_HANDLER, /* 994 */
    ZEND_NULL_HANDLER, /* 995 */
    ZEND_NULL_HANDLER, /* 996 */
    ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER, /* 997 */
    ZEND_NULL_HANDLER, /* 998 */
    ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER, /* 999 */
    ZEND_ECHO_SPEC_CONST_HANDLER, /* 1000 */
    ZEND_ECHO_SPEC_CONST_HANDLER, /* 1001 */
    ZEND_ECHO_SPEC_CONST_HANDLER, /* 1002 */
    ZEND_ECHO_SPEC_CONST_HANDLER, /* 1003 */
    ZEND_ECHO_SPEC_CONST_HANDLER, /* 1004 */
    ZEND_ECHO_SPEC_TMP_HANDLER, /* 1005 */
    ZEND_ECHO_SPEC_TMP_HANDLER, /* 1006 */
    ZEND_ECHO_SPEC_TMP_HANDLER, /* 1007 */
    ZEND_ECHO_SPEC_TMP_HANDLER, /* 1008 */
    ZEND_ECHO_SPEC_TMP_HANDLER, /* 1009 */
    ZEND_ECHO_SPEC_VAR_HANDLER, /* 1010 */
    ZEND_ECHO_SPEC_VAR_HANDLER, /* 1011 */
    ZEND_ECHO_SPEC_VAR_HANDLER, /* 1012 */
    ZEND_ECHO_SPEC_VAR_HANDLER, /* 1013 */
    ZEND_ECHO_SPEC_VAR_HANDLER, /* 1014 */
    ZEND_NULL_HANDLER, /* 1015 */
    ZEND_NULL_HANDLER, /* 1016 */
    ZEND_NULL_HANDLER, /* 1017 */
    ZEND_NULL_HANDLER, /* 1018 */
    ZEND_NULL_HANDLER, /* 1019 */
    ZEND_ECHO_SPEC_CV_HANDLER, /* 1020 */
    ZEND_ECHO_SPEC_CV_HANDLER, /* 1021 */
    ZEND_ECHO_SPEC_CV_HANDLER, /* 1022 */
    ZEND_ECHO_SPEC_CV_HANDLER, /* 1023 */
    ZEND_ECHO_SPEC_CV_HANDLER, /* 1024 */
    ZEND_PRINT_SPEC_CONST_HANDLER, /* 1025 */
    ZEND_PRINT_SPEC_CONST_HANDLER, /* 1026 */
    ZEND_PRINT_SPEC_CONST_HANDLER, /* 1027 */
    ZEND_PRINT_SPEC_CONST_HANDLER, /* 1028 */
    ZEND_PRINT_SPEC_CONST_HANDLER, /* 1029 */
    ZEND_PRINT_SPEC_TMP_HANDLER, /* 1030 */
    ZEND_PRINT_SPEC_TMP_HANDLER, /* 1031 */
    ZEND_PRINT_SPEC_TMP_HANDLER, /* 1032 */
    ZEND_PRINT_SPEC_TMP_HANDLER, /* 1033 */
    ZEND_PRINT_SPEC_TMP_HANDLER, /* 1034 */
    ZEND_PRINT_SPEC_VAR_HANDLER, /* 1035 */
    ZEND_PRINT_SPEC_VAR_HANDLER, /* 1036 */
    ZEND_PRINT_SPEC_VAR_HANDLER, /* 1037 */
    ZEND_PRINT_SPEC_VAR_HANDLER, /* 1038 */
    ZEND_PRINT_SPEC_VAR_HANDLER, /* 1039 */
    ZEND_NULL_HANDLER, /* 1040 */
    ZEND_NULL_HANDLER, /* 1041 */
    ZEND_NULL_HANDLER, /* 1042 */
    ZEND_NULL_HANDLER, /* 1043 */
    ZEND_NULL_HANDLER, /* 1044 */
    ZEND_PRINT_SPEC_CV_HANDLER, /* 1045 */
    ZEND_PRINT_SPEC_CV_HANDLER, /* 1046 */
    ZEND_PRINT_SPEC_CV_HANDLER, /* 1047 */
    ZEND_PRINT_SPEC_CV_HANDLER, /* 1048 */
    ZEND_PRINT_SPEC_CV_HANDLER, /* 1049 */
    ZEND_JMP_SPEC_HANDLER, /* 1050 */
    ZEND_JMP_SPEC_HANDLER, /* 1051 */
    ZEND_JMP_SPEC_HANDLER, /* 1052 */
    ZEND_JMP_SPEC_HANDLER, /* 1053 */
    ZEND_JMP_SPEC_HANDLER, /* 1054 */
    ZEND_JMP_SPEC_HANDLER, /* 1055 */
    ZEND_JMP_SPEC_HANDLER, /* 1056 */
    ZEND_JMP_SPEC_HANDLER, /* 1057 */
    ZEND_JMP_SPEC_HANDLER, /* 1058 */
    ZEND_JMP_SPEC_HANDLER, /* 1059 */
    ZEND_JMP_SPEC_HANDLER, /* 1060 */
    ZEND_JMP_SPEC_HANDLER, /* 1061 */
    ZEND_JMP_SPEC_HANDLER, /* 1062 */
    ZEND_JMP_SPEC_HANDLER, /* 1063 */
    ZEND_JMP_SPEC_HANDLER, /* 1064 */
    ZEND_JMP_SPEC_HANDLER, /* 1065 */
    ZEND_JMP_SPEC_HANDLER, /* 1066 */
    ZEND_JMP_SPEC_HANDLER, /* 1067 */
    ZEND_JMP_SPEC_HANDLER, /* 1068 */
    ZEND_JMP_SPEC_HANDLER, /* 1069 */
    ZEND_JMP_SPEC_HANDLER, /* 1070 */
    ZEND_JMP_SPEC_HANDLER, /* 1071 */
    ZEND_JMP_SPEC_HANDLER, /* 1072 */
    ZEND_JMP_SPEC_HANDLER, /* 1073 */
    ZEND_JMP_SPEC_HANDLER, /* 1074 */
    ZEND_JMPZ_SPEC_CONST_HANDLER, /* 1075 */
    ZEND_JMPZ_SPEC_CONST_HANDLER, /* 1076 */
    ZEND_JMPZ_SPEC_CONST_HANDLER, /* 1077 */
    ZEND_JMPZ_SPEC_CONST_HANDLER, /* 1078 */
    ZEND_JMPZ_SPEC_CONST_HANDLER, /* 1079 */
    ZEND_JMPZ_SPEC_TMP_HANDLER, /* 1080 */
    ZEND_JMPZ_SPEC_TMP_HANDLER, /* 1081 */
    ZEND_JMPZ_SPEC_TMP_HANDLER, /* 1082 */
    ZEND_JMPZ_SPEC_TMP_HANDLER, /* 1083 */
    ZEND_JMPZ_SPEC_TMP_HANDLER, /* 1084 */
    ZEND_JMPZ_SPEC_VAR_HANDLER, /* 1085 */
    ZEND_JMPZ_SPEC_VAR_HANDLER, /* 1086 */
    ZEND_JMPZ_SPEC_VAR_HANDLER, /* 1087 */
    ZEND_JMPZ_SPEC_VAR_HANDLER, /* 1088 */
    ZEND_JMPZ_SPEC_VAR_HANDLER, /* 1089 */
    ZEND_NULL_HANDLER, /* 1090 */
    ZEND_NULL_HANDLER, /* 1091 */
    ZEND_NULL_HANDLER, /* 1092 */
    ZEND_NULL_HANDLER, /* 1093 */
    ZEND_NULL_HANDLER, /* 1094 */
    ZEND_JMPZ_SPEC_CV_HANDLER, /* 1095 */
    ZEND_JMPZ_SPEC_CV_HANDLER, /* 1096 */
    ZEND_JMPZ_SPEC_CV_HANDLER, /* 1097 */
    ZEND_JMPZ_SPEC_CV_HANDLER, /* 1098 */
    ZEND_JMPZ_SPEC_CV_HANDLER, /* 1099 */
    ZEND_JMPNZ_SPEC_CONST_HANDLER, /* 1100 */
    ZEND_JMPNZ_SPEC_CONST_HANDLER, /* 1101 */
    ZEND_JMPNZ_SPEC_CONST_HANDLER, /* 1102 */
    ZEND_JMPNZ_SPEC_CONST_HANDLER, /* 1103 */
    ZEND_JMPNZ_SPEC_CONST_HANDLER, /* 1104 */
    ZEND_JMPNZ_SPEC_TMP_HANDLER, /* 1105 */
    ZEND_JMPNZ_SPEC_TMP_HANDLER, /* 1106 */
    ZEND_JMPNZ_SPEC_TMP_HANDLER, /* 1107 */
    ZEND_JMPNZ_SPEC_TMP_HANDLER, /* 1108 */
    ZEND_JMPNZ_SPEC_TMP_HANDLER, /* 1109 */
    ZEND_JMPNZ_SPEC_VAR_HANDLER, /* 1110 */
    ZEND_JMPNZ_SPEC_VAR_HANDLER, /* 1111 */
    ZEND_JMPNZ_SPEC_VAR_HANDLER, /* 1112 */
    ZEND_JMPNZ_SPEC_VAR_HANDLER, /* 1113 */
    ZEND_JMPNZ_SPEC_VAR_HANDLER, /* 1114 */
    ZEND_NULL_HANDLER, /* 1115 */
    ZEND_NULL_HANDLER, /* 1116 */
    ZEND_NULL_HANDLER, /* 1117 */
    ZEND_NULL_HANDLER, /* 1118 */
    ZEND_NULL_HANDLER, /* 1119 */
    ZEND_JMPNZ_SPEC_CV_HANDLER, /* 1120 */
    ZEND_JMPNZ_SPEC_CV_HANDLER, /* 1121 */
    ZEND_JMPNZ_SPEC_CV_HANDLER, /* 1122 */
    ZEND_JMPNZ_SPEC_CV_HANDLER, /* 1123 */
    ZEND_JMPNZ_SPEC_CV_HANDLER, /* 1124 */
    ZEND_JMPZNZ_SPEC_CONST_HANDLER, /* 1125 */
    ZEND_JMPZNZ_SPEC_CONST_HANDLER, /* 1126 */
    ZEND_JMPZNZ_SPEC_CONST_HANDLER, /* 1127 */
    ZEND_JMPZNZ_SPEC_CONST_HANDLER, /* 1128 */
    ZEND_JMPZNZ_SPEC_CONST_HANDLER, /* 1129 */
    ZEND_JMPZNZ_SPEC_TMP_HANDLER, /* 1130 */
    ZEND_JMPZNZ_SPEC_TMP_HANDLER, /* 1131 */
    ZEND_JMPZNZ_SPEC_TMP_HANDLER, /* 1132 */
    ZEND_JMPZNZ_SPEC_TMP_HANDLER, /* 1133 */
    ZEND_JMPZNZ_SPEC_TMP_HANDLER, /* 1134 */
    ZEND_JMPZNZ_SPEC_VAR_HANDLER, /* 1135 */
    ZEND_JMPZNZ_SPEC_VAR_HANDLER, /* 1136 */
    ZEND_JMPZNZ_SPEC_VAR_HANDLER, /* 1137 */
    ZEND_JMPZNZ_SPEC_VAR_HANDLER, /* 1138 */
    ZEND_JMPZNZ_SPEC_VAR_HANDLER, /* 1139 */
    ZEND_NULL_HANDLER, /* 1140 */
    ZEND_NULL_HANDLER, /* 1141 */
    ZEND_NULL_HANDLER, /* 1142 */
    ZEND_NULL_HANDLER, /* 1143 */
    ZEND_NULL_HANDLER, /* 1144 */
    ZEND_JMPZNZ_SPEC_CV_HANDLER, /* 1145 */
    ZEND_JMPZNZ_SPEC_CV_HANDLER, /* 1146 */
    ZEND_JMPZNZ_SPEC_CV_HANDLER, /* 1147 */
    ZEND_JMPZNZ_SPEC_CV_HANDLER, /* 1148 */
    ZEND_JMPZNZ_SPEC_CV_HANDLER, /* 1149 */
    ZEND_JMPZ_EX_SPEC_CONST_HANDLER, /* 1150 */
    ZEND_JMPZ_EX_SPEC_CONST_HANDLER, /* 1151 */
    ZEND_JMPZ_EX_SPEC_CONST_HANDLER, /* 1152 */
    ZEND_JMPZ_EX_SPEC_CONST_HANDLER, /* 1153 */
    ZEND_JMPZ_EX_SPEC_CONST_HANDLER, /* 1154 */
    ZEND_JMPZ_EX_SPEC_TMP_HANDLER, /* 1155 */
    ZEND_JMPZ_EX_SPEC_TMP_HANDLER, /* 1156 */
    ZEND_JMPZ_EX_SPEC_TMP_HANDLER, /* 1157 */
    ZEND_JMPZ_EX_SPEC_TMP_HANDLER, /* 1158 */
    ZEND_JMPZ_EX_SPEC_TMP_HANDLER, /* 1159 */
    ZEND_JMPZ_EX_SPEC_VAR_HANDLER, /* 1160 */
    ZEND_JMPZ_EX_SPEC_VAR_HANDLER, /* 1161 */
    ZEND_JMPZ_EX_SPEC_VAR_HANDLER, /* 1162 */
    ZEND_JMPZ_EX_SPEC_VAR_HANDLER, /* 1163 */
    ZEND_JMPZ_EX_SPEC_VAR_HANDLER, /* 1164 */
    ZEND_NULL_HANDLER, /* 1165 */
    ZEND_NULL_HANDLER, /* 1166 */
    ZEND_NULL_HANDLER, /* 1167 */
    ZEND_NULL_HANDLER, /* 1168 */
    ZEND_NULL_HANDLER, /* 1169 */
    ZEND_JMPZ_EX_SPEC_CV_HANDLER, /* 1170 */
    ZEND_JMPZ_EX_SPEC_CV_HANDLER, /* 1171 */
    ZEND_JMPZ_EX_SPEC_CV_HANDLER, /* 1172 */
    ZEND_JMPZ_EX_SPEC_CV_HANDLER, /* 1173 */
    ZEND_JMPZ_EX_SPEC_CV_HANDLER, /* 1174 */
    ZEND_JMPNZ_EX_SPEC_CONST_HANDLER, /* 1175 */
    ZEND_JMPNZ_EX_SPEC_CONST_HANDLER, /* 1176 */
    ZEND_JMPNZ_EX_SPEC_CONST_HANDLER, /* 1177 */
    ZEND_JMPNZ_EX_SPEC_CONST_HANDLER, /* 1178 */
    ZEND_JMPNZ_EX_SPEC_CONST_HANDLER, /* 1179 */
    ZEND_JMPNZ_EX_SPEC_TMP_HANDLER, /* 1180 */
    ZEND_JMPNZ_EX_SPEC_TMP_HANDLER, /* 1181 */
    ZEND_JMPNZ_EX_SPEC_TMP_HANDLER, /* 1182 */
    ZEND_JMPNZ_EX_SPEC_TMP_HANDLER, /* 1183 */
    ZEND_JMPNZ_EX_SPEC_TMP_HANDLER, /* 1184 */
    ZEND_JMPNZ_EX_SPEC_VAR_HANDLER, /* 1185 */
    ZEND_JMPNZ_EX_SPEC_VAR_HANDLER, /* 1186 */
    ZEND_JMPNZ_EX_SPEC_VAR_HANDLER, /* 1187 */
    ZEND_JMPNZ_EX_SPEC_VAR_HANDLER, /* 1188 */
    ZEND_JMPNZ_EX_SPEC_VAR_HANDLER, /* 1189 */
    ZEND_NULL_HANDLER, /* 1190 */
    ZEND_NULL_HANDLER, /* 1191 */
    ZEND_NULL_HANDLER, /* 1192 */
    ZEND_NULL_HANDLER, /* 1193 */
    ZEND_NULL_HANDLER, /* 1194 */
    ZEND_JMPNZ_EX_SPEC_CV_HANDLER, /* 1195 */
    ZEND_JMPNZ_EX_SPEC_CV_HANDLER, /* 1196 */
    ZEND_JMPNZ_EX_SPEC_CV_HANDLER, /* 1197 */
    ZEND_JMPNZ_EX_SPEC_CV_HANDLER, /* 1198 */
    ZEND_JMPNZ_EX_SPEC_CV_HANDLER, /* 1199 */
    ZEND_CASE_SPEC_CONST_CONST_HANDLER, /* 1200 */
    ZEND_CASE_SPEC_CONST_TMP_HANDLER, /* 1201 */
    ZEND_CASE_SPEC_CONST_VAR_HANDLER, /* 1202 */
    ZEND_NULL_HANDLER, /* 1203 */
    ZEND_CASE_SPEC_CONST_CV_HANDLER, /* 1204 */
    ZEND_CASE_SPEC_TMP_CONST_HANDLER, /* 1205 */
    ZEND_CASE_SPEC_TMP_TMP_HANDLER, /* 1206 */
    ZEND_CASE_SPEC_TMP_VAR_HANDLER, /* 1207 */
    ZEND_NULL_HANDLER, /* 1208 */
    ZEND_CASE_SPEC_TMP_CV_HANDLER, /* 1209 */
    ZEND_CASE_SPEC_VAR_CONST_HANDLER, /* 1210 */
    ZEND_CASE_SPEC_VAR_TMP_HANDLER, /* 1211 */
    ZEND_CASE_SPEC_VAR_VAR_HANDLER, /* 1212 */
    ZEND_NULL_HANDLER, /* 1213 */
    ZEND_CASE_SPEC_VAR_CV_HANDLER, /* 1214 */
    ZEND_NULL_HANDLER, /* 1215 */
    ZEND_NULL_HANDLER, /* 1216 */
    ZEND_NULL_HANDLER, /* 1217 */
    ZEND_NULL_HANDLER, /* 1218 */
    ZEND_NULL_HANDLER, /* 1219 */
    ZEND_CASE_SPEC_CV_CONST_HANDLER, /* 1220 */
    ZEND_CASE_SPEC_CV_TMP_HANDLER, /* 1221 */
    ZEND_CASE_SPEC_CV_VAR_HANDLER, /* 1222 */
    ZEND_NULL_HANDLER, /* 1223 */
    ZEND_CASE_SPEC_CV_CV_HANDLER, /* 1224 */
    ZEND_NULL_HANDLER, /* 1225 */
    ZEND_NULL_HANDLER, /* 1226 */
    ZEND_NULL_HANDLER, /* 1227 */
    ZEND_NULL_HANDLER, /* 1228 */
    ZEND_NULL_HANDLER, /* 1229 */
    ZEND_NULL_HANDLER, /* 1230 */
    ZEND_NULL_HANDLER, /* 1231 */
    ZEND_NULL_HANDLER, /* 1232 */
    ZEND_NULL_HANDLER, /* 1233 */
    ZEND_NULL_HANDLER, /* 1234 */
    ZEND_SWITCH_FREE_SPEC_VAR_HANDLER, /* 1235 */
    ZEND_SWITCH_FREE_SPEC_VAR_HANDLER, /* 1236 */
    ZEND_SWITCH_FREE_SPEC_VAR_HANDLER, /* 1237 */
    ZEND_SWITCH_FREE_SPEC_VAR_HANDLER, /* 1238 */
    ZEND_SWITCH_FREE_SPEC_VAR_HANDLER, /* 1239 */
    ZEND_NULL_HANDLER, /* 1240 */
    ZEND_NULL_HANDLER, /* 1241 */
    ZEND_NULL_HANDLER, /* 1242 */
    ZEND_NULL_HANDLER, /* 1243 */
    ZEND_NULL_HANDLER, /* 1244 */
    ZEND_NULL_HANDLER, /* 1245 */
    ZEND_NULL_HANDLER, /* 1246 */
    ZEND_NULL_HANDLER, /* 1247 */
    ZEND_NULL_HANDLER, /* 1248 */
    ZEND_NULL_HANDLER, /* 1249 */
    ZEND_BRK_SPEC_CONST_HANDLER, /* 1250 */
    ZEND_NULL_HANDLER, /* 1251 */
    ZEND_NULL_HANDLER, /* 1252 */
    ZEND_NULL_HANDLER, /* 1253 */
    ZEND_NULL_HANDLER, /* 1254 */
    ZEND_BRK_SPEC_CONST_HANDLER, /* 1255 */
    ZEND_NULL_HANDLER, /* 1256 */
    ZEND_NULL_HANDLER, /* 1257 */
    ZEND_NULL_HANDLER, /* 1258 */
    ZEND_NULL_HANDLER, /* 1259 */
    ZEND_BRK_SPEC_CONST_HANDLER, /* 1260 */
    ZEND_NULL_HANDLER, /* 1261 */
    ZEND_NULL_HANDLER, /* 1262 */
    ZEND_NULL_HANDLER, /* 1263 */
    ZEND_NULL_HANDLER, /* 1264 */
    ZEND_BRK_SPEC_CONST_HANDLER, /* 1265 */
    ZEND_NULL_HANDLER, /* 1266 */
    ZEND_NULL_HANDLER, /* 1267 */
    ZEND_NULL_HANDLER, /* 1268 */
    ZEND_NULL_HANDLER, /* 1269 */
    ZEND_BRK_SPEC_CONST_HANDLER, /* 1270 */
    ZEND_NULL_HANDLER, /* 1271 */
    ZEND_NULL_HANDLER, /* 1272 */
    ZEND_NULL_HANDLER, /* 1273 */
    ZEND_NULL_HANDLER, /* 1274 */
    ZEND_CONT_SPEC_CONST_HANDLER, /* 1275 */
    ZEND_NULL_HANDLER, /* 1276 */
    ZEND_NULL_HANDLER, /* 1277 */
    ZEND_NULL_HANDLER, /* 1278 */
    ZEND_NULL_HANDLER, /* 1279 */
    ZEND_CONT_SPEC_CONST_HANDLER, /* 1280 */
    ZEND_NULL_HANDLER, /* 1281 */
    ZEND_NULL_HANDLER, /* 1282 */
    ZEND_NULL_HANDLER, /* 1283 */
    ZEND_NULL_HANDLER, /* 1284 */
    ZEND_CONT_SPEC_CONST_HANDLER, /* 1285 */
    ZEND_NULL_HANDLER, /* 1286 */
    ZEND_NULL_HANDLER, /* 1287 */
    ZEND_NULL_HANDLER, /* 1288 */
    ZEND_NULL_HANDLER, /* 1289 */
    ZEND_CONT_SPEC_CONST_HANDLER, /* 1290 */
    ZEND_NULL_HANDLER, /* 1291 */
    ZEND_NULL_HANDLER, /* 1292 */
    ZEND_NULL_HANDLER, /* 1293 */
    ZEND_NULL_HANDLER, /* 1294 */
    ZEND_CONT_SPEC_CONST_HANDLER, /* 1295 */
    ZEND_NULL_HANDLER, /* 1296 */
    ZEND_NULL_HANDLER, /* 1297 */
    ZEND_NULL_HANDLER, /* 1298 */
    ZEND_NULL_HANDLER, /* 1299 */
    ZEND_BOOL_SPEC_CONST_HANDLER, /* 1300 */
    ZEND_BOOL_SPEC_CONST_HANDLER, /* 1301 */
    ZEND_BOOL_SPEC_CONST_HANDLER, /* 1302 */
    ZEND_BOOL_SPEC_CONST_HANDLER, /* 1303 */
    ZEND_BOOL_SPEC_CONST_HANDLER, /* 1304 */
    ZEND_BOOL_SPEC_TMP_HANDLER, /* 1305 */
    ZEND_BOOL_SPEC_TMP_HANDLER, /* 1306 */
    ZEND_BOOL_SPEC_TMP_HANDLER, /* 1307 */
    ZEND_BOOL_SPEC_TMP_HANDLER, /* 1308 */
    ZEND_BOOL_SPEC_TMP_HANDLER, /* 1309 */
    ZEND_BOOL_SPEC_VAR_HANDLER, /* 1310 */
    ZEND_BOOL_SPEC_VAR_HANDLER, /* 1311 */
    ZEND_BOOL_SPEC_VAR_HANDLER, /* 1312 */
    ZEND_BOOL_SPEC_VAR_HANDLER, /* 1313 */
    ZEND_BOOL_SPEC_VAR_HANDLER, /* 1314 */
    ZEND_NULL_HANDLER, /* 1315 */
    ZEND_NULL_HANDLER, /* 1316 */
    ZEND_NULL_HANDLER, /* 1317 */
    ZEND_NULL_HANDLER, /* 1318 */
    ZEND_NULL_HANDLER, /* 1319 */
    ZEND_BOOL_SPEC_CV_HANDLER, /* 1320 */
    ZEND_BOOL_SPEC_CV_HANDLER, /* 1321 */
    ZEND_BOOL_SPEC_CV_HANDLER, /* 1322 */
    ZEND_BOOL_SPEC_CV_HANDLER, /* 1323 */
    ZEND_BOOL_SPEC_CV_HANDLER, /* 1324 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1325 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1326 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1327 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1328 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1329 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1330 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1331 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1332 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1333 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1334 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1335 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1336 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1337 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1338 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1339 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1340 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1341 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1342 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1343 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1344 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1345 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1346 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1347 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1348 */
    ZEND_INIT_STRING_SPEC_HANDLER, /* 1349 */
    ZEND_NULL_HANDLER, /* 1350 */
    ZEND_NULL_HANDLER, /* 1351 */
    ZEND_NULL_HANDLER, /* 1352 */
    ZEND_NULL_HANDLER, /* 1353 */
    ZEND_NULL_HANDLER, /* 1354 */
    ZEND_ADD_CHAR_SPEC_TMP_CONST_HANDLER, /* 1355 */
    ZEND_NULL_HANDLER, /* 1356 */
    ZEND_NULL_HANDLER, /* 1357 */
    ZEND_NULL_HANDLER, /* 1358 */
    ZEND_NULL_HANDLER, /* 1359 */
    ZEND_NULL_HANDLER, /* 1360 */
    ZEND_NULL_HANDLER, /* 1361 */
    ZEND_NULL_HANDLER, /* 1362 */
    ZEND_NULL_HANDLER, /* 1363 */
    ZEND_NULL_HANDLER, /* 1364 */
    ZEND_ADD_CHAR_SPEC_UNUSED_CONST_HANDLER, /* 1365 */
    ZEND_NULL_HANDLER, /* 1366 */
    ZEND_NULL_HANDLER, /* 1367 */
    ZEND_NULL_HANDLER, /* 1368 */
    ZEND_NULL_HANDLER, /* 1369 */
    ZEND_NULL_HANDLER, /* 1370 */
    ZEND_NULL_HANDLER, /* 1371 */
    ZEND_NULL_HANDLER, /* 1372 */
    ZEND_NULL_HANDLER, /* 1373 */
    ZEND_NULL_HANDLER, /* 1374 */
    ZEND_NULL_HANDLER, /* 1375 */
    ZEND_NULL_HANDLER, /* 1376 */
    ZEND_NULL_HANDLER, /* 1377 */
    ZEND_NULL_HANDLER, /* 1378 */
    ZEND_NULL_HANDLER, /* 1379 */
    ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER, /* 1380 */
    ZEND_NULL_HANDLER, /* 1381 */
    ZEND_NULL_HANDLER, /* 1382 */
    ZEND_NULL_HANDLER, /* 1383 */
    ZEND_NULL_HANDLER, /* 1384 */
    ZEND_NULL_HANDLER, /* 1385 */
    ZEND_NULL_HANDLER, /* 1386 */
    ZEND_NULL_HANDLER, /* 1387 */
    ZEND_NULL_HANDLER, /* 1388 */
    ZEND_NULL_HANDLER, /* 1389 */
    ZEND_ADD_STRING_SPEC_UNUSED_CONST_HANDLER, /* 1390 */
    ZEND_NULL_HANDLER, /* 1391 */
    ZEND_NULL_HANDLER, /* 1392 */
    ZEND_NULL_HANDLER, /* 1393 */
    ZEND_NULL_HANDLER, /* 1394 */
    ZEND_NULL_HANDLER, /* 1395 */
    ZEND_NULL_HANDLER, /* 1396 */
    ZEND_NULL_HANDLER, /* 1397 */
    ZEND_NULL_HANDLER, /* 1398 */
    ZEND_NULL_HANDLER, /* 1399 */
    ZEND_NULL_HANDLER, /* 1400 */
    ZEND_NULL_HANDLER, /* 1401 */
    ZEND_NULL_HANDLER, /* 1402 */
    ZEND_NULL_HANDLER, /* 1403 */
    ZEND_NULL_HANDLER, /* 1404 */
    ZEND_NULL_HANDLER, /* 1405 */
    ZEND_ADD_VAR_SPEC_TMP_TMP_HANDLER, /* 1406 */
    ZEND_ADD_VAR_SPEC_TMP_VAR_HANDLER, /* 1407 */
    ZEND_NULL_HANDLER, /* 1408 */
    ZEND_ADD_VAR_SPEC_TMP_CV_HANDLER, /* 1409 */
    ZEND_NULL_HANDLER, /* 1410 */
    ZEND_NULL_HANDLER, /* 1411 */
    ZEND_NULL_HANDLER, /* 1412 */
    ZEND_NULL_HANDLER, /* 1413 */
    ZEND_NULL_HANDLER, /* 1414 */
    ZEND_NULL_HANDLER, /* 1415 */
    ZEND_ADD_VAR_SPEC_UNUSED_TMP_HANDLER, /* 1416 */
    ZEND_ADD_VAR_SPEC_UNUSED_VAR_HANDLER, /* 1417 */
    ZEND_NULL_HANDLER, /* 1418 */
    ZEND_ADD_VAR_SPEC_UNUSED_CV_HANDLER, /* 1419 */
    ZEND_NULL_HANDLER, /* 1420 */
    ZEND_NULL_HANDLER, /* 1421 */
    ZEND_NULL_HANDLER, /* 1422 */
    ZEND_NULL_HANDLER, /* 1423 */
    ZEND_NULL_HANDLER, /* 1424 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1425 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1426 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1427 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1428 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1429 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1430 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1431 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1432 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1433 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1434 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1435 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1436 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1437 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1438 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1439 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1440 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1441 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1442 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1443 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1444 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1445 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1446 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1447 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1448 */
    ZEND_BEGIN_SILENCE_SPEC_HANDLER, /* 1449 */
    ZEND_NULL_HANDLER, /* 1450 */
    ZEND_NULL_HANDLER, /* 1451 */
    ZEND_NULL_HANDLER, /* 1452 */
    ZEND_NULL_HANDLER, /* 1453 */
    ZEND_NULL_HANDLER, /* 1454 */
    ZEND_END_SILENCE_SPEC_TMP_HANDLER, /* 1455 */
    ZEND_END_SILENCE_SPEC_TMP_HANDLER, /* 1456 */
    ZEND_END_SILENCE_SPEC_TMP_HANDLER, /* 1457 */
    ZEND_END_SILENCE_SPEC_TMP_HANDLER, /* 1458 */
    ZEND_END_SILENCE_SPEC_TMP_HANDLER, /* 1459 */
    ZEND_NULL_HANDLER, /* 1460 */
    ZEND_NULL_HANDLER, /* 1461 */
    ZEND_NULL_HANDLER, /* 1462 */
    ZEND_NULL_HANDLER, /* 1463 */
    ZEND_NULL_HANDLER, /* 1464 */
    ZEND_NULL_HANDLER, /* 1465 */
    ZEND_NULL_HANDLER, /* 1466 */
    ZEND_NULL_HANDLER, /* 1467 */
    ZEND_NULL_HANDLER, /* 1468 */
    ZEND_NULL_HANDLER, /* 1469 */
    ZEND_NULL_HANDLER, /* 1470 */
    ZEND_NULL_HANDLER, /* 1471 */
    ZEND_NULL_HANDLER, /* 1472 */
    ZEND_NULL_HANDLER, /* 1473 */
    ZEND_NULL_HANDLER, /* 1474 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER, /* 1475 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER, /* 1476 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER, /* 1477 */
    ZEND_NULL_HANDLER, /* 1478 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER, /* 1479 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER, /* 1480 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER, /* 1481 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER, /* 1482 */
    ZEND_NULL_HANDLER, /* 1483 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER, /* 1484 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER, /* 1485 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER, /* 1486 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER, /* 1487 */
    ZEND_NULL_HANDLER, /* 1488 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER, /* 1489 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER, /* 1490 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER, /* 1491 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER, /* 1492 */
    ZEND_NULL_HANDLER, /* 1493 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER, /* 1494 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER, /* 1495 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER, /* 1496 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER, /* 1497 */
    ZEND_NULL_HANDLER, /* 1498 */
    ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER, /* 1499 */
    ZEND_DO_FCALL_SPEC_CONST_HANDLER, /* 1500 */
    ZEND_DO_FCALL_SPEC_CONST_HANDLER, /* 1501 */
    ZEND_DO_FCALL_SPEC_CONST_HANDLER, /* 1502 */
    ZEND_DO_FCALL_SPEC_CONST_HANDLER, /* 1503 */
    ZEND_DO_FCALL_SPEC_CONST_HANDLER, /* 1504 */
    ZEND_NULL_HANDLER, /* 1505 */
    ZEND_NULL_HANDLER, /* 1506 */
    ZEND_NULL_HANDLER, /* 1507 */
    ZEND_NULL_HANDLER, /* 1508 */
    ZEND_NULL_HANDLER, /* 1509 */
    ZEND_NULL_HANDLER, /* 1510 */
    ZEND_NULL_HANDLER, /* 1511 */
    ZEND_NULL_HANDLER, /* 1512 */
    ZEND_NULL_HANDLER, /* 1513 */
    ZEND_NULL_HANDLER, /* 1514 */
    ZEND_NULL_HANDLER, /* 1515 */
    ZEND_NULL_HANDLER, /* 1516 */
    ZEND_NULL_HANDLER, /* 1517 */
    ZEND_NULL_HANDLER, /* 1518 */
    ZEND_NULL_HANDLER, /* 1519 */
    ZEND_NULL_HANDLER, /* 1520 */
    ZEND_NULL_HANDLER, /* 1521 */
    ZEND_NULL_HANDLER, /* 1522 */
    ZEND_NULL_HANDLER, /* 1523 */
    ZEND_NULL_HANDLER, /* 1524 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1525 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1526 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1527 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1528 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1529 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1530 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1531 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1532 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1533 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1534 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1535 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1536 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1537 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1538 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1539 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1540 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1541 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1542 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1543 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1544 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1545 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1546 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1547 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1548 */
    ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER, /* 1549 */
    ZEND_RETURN_SPEC_CONST_HANDLER, /* 1550 */
    ZEND_RETURN_SPEC_CONST_HANDLER, /* 1551 */
    ZEND_RETURN_SPEC_CONST_HANDLER, /* 1552 */
    ZEND_RETURN_SPEC_CONST_HANDLER, /* 1553 */
    ZEND_RETURN_SPEC_CONST_HANDLER, /* 1554 */
    ZEND_RETURN_SPEC_TMP_HANDLER, /* 1555 */
    ZEND_RETURN_SPEC_TMP_HANDLER, /* 1556 */
    ZEND_RETURN_SPEC_TMP_HANDLER, /* 1557 */
    ZEND_RETURN_SPEC_TMP_HANDLER, /* 1558 */
    ZEND_RETURN_SPEC_TMP_HANDLER, /* 1559 */
    ZEND_RETURN_SPEC_VAR_HANDLER, /* 1560 */
    ZEND_RETURN_SPEC_VAR_HANDLER, /* 1561 */
    ZEND_RETURN_SPEC_VAR_HANDLER, /* 1562 */
    ZEND_RETURN_SPEC_VAR_HANDLER, /* 1563 */
    ZEND_RETURN_SPEC_VAR_HANDLER, /* 1564 */
    ZEND_NULL_HANDLER, /* 1565 */
    ZEND_NULL_HANDLER, /* 1566 */
    ZEND_NULL_HANDLER, /* 1567 */
    ZEND_NULL_HANDLER, /* 1568 */
    ZEND_NULL_HANDLER, /* 1569 */
    ZEND_RETURN_SPEC_CV_HANDLER, /* 1570 */
    ZEND_RETURN_SPEC_CV_HANDLER, /* 1571 */
    ZEND_RETURN_SPEC_CV_HANDLER, /* 1572 */
    ZEND_RETURN_SPEC_CV_HANDLER, /* 1573 */
    ZEND_RETURN_SPEC_CV_HANDLER, /* 1574 */
    ZEND_RECV_SPEC_HANDLER, /* 1575 */
    ZEND_RECV_SPEC_HANDLER, /* 1576 */
    ZEND_RECV_SPEC_HANDLER, /* 1577 */
    ZEND_RECV_SPEC_HANDLER, /* 1578 */
    ZEND_RECV_SPEC_HANDLER, /* 1579 */
    ZEND_RECV_SPEC_HANDLER, /* 1580 */
    ZEND_RECV_SPEC_HANDLER, /* 1581 */
    ZEND_RECV_SPEC_HANDLER, /* 1582 */
    ZEND_RECV_SPEC_HANDLER, /* 1583 */
    ZEND_RECV_SPEC_HANDLER, /* 1584 */
    ZEND_RECV_SPEC_HANDLER, /* 1585 */
    ZEND_RECV_SPEC_HANDLER, /* 1586 */
    ZEND_RECV_SPEC_HANDLER, /* 1587 */
    ZEND_RECV_SPEC_HANDLER, /* 1588 */
    ZEND_RECV_SPEC_HANDLER, /* 1589 */
    ZEND_RECV_SPEC_HANDLER, /* 1590 */
    ZEND_RECV_SPEC_HANDLER, /* 1591 */
    ZEND_RECV_SPEC_HANDLER, /* 1592 */
    ZEND_RECV_SPEC_HANDLER, /* 1593 */
    ZEND_RECV_SPEC_HANDLER, /* 1594 */
    ZEND_RECV_SPEC_HANDLER, /* 1595 */
    ZEND_RECV_SPEC_HANDLER, /* 1596 */
    ZEND_RECV_SPEC_HANDLER, /* 1597 */
    ZEND_RECV_SPEC_HANDLER, /* 1598 */
    ZEND_RECV_SPEC_HANDLER, /* 1599 */
    ZEND_RECV_INIT_SPEC_CONST_HANDLER, /* 1600 */
    ZEND_NULL_HANDLER, /* 1601 */
    ZEND_NULL_HANDLER, /* 1602 */
    ZEND_NULL_HANDLER, /* 1603 */
    ZEND_NULL_HANDLER, /* 1604 */
    ZEND_RECV_INIT_SPEC_CONST_HANDLER, /* 1605 */
    ZEND_NULL_HANDLER, /* 1606 */
    ZEND_NULL_HANDLER, /* 1607 */
    ZEND_NULL_HANDLER, /* 1608 */
    ZEND_NULL_HANDLER, /* 1609 */
    ZEND_RECV_INIT_SPEC_CONST_HANDLER, /* 1610 */
    ZEND_NULL_HANDLER, /* 1611 */
    ZEND_NULL_HANDLER, /* 1612 */
    ZEND_NULL_HANDLER, /* 1613 */
    ZEND_NULL_HANDLER, /* 1614 */
    ZEND_RECV_INIT_SPEC_CONST_HANDLER, /* 1615 */
    ZEND_NULL_HANDLER, /* 1616 */
    ZEND_NULL_HANDLER, /* 1617 */
    ZEND_NULL_HANDLER, /* 1618 */
    ZEND_NULL_HANDLER, /* 1619 */
    ZEND_RECV_INIT_SPEC_CONST_HANDLER, /* 1620 */
    ZEND_NULL_HANDLER, /* 1621 */
    ZEND_NULL_HANDLER, /* 1622 */
    ZEND_NULL_HANDLER, /* 1623 */
    ZEND_NULL_HANDLER, /* 1624 */
    ZEND_SEND_VAL_SPEC_CONST_HANDLER, /* 1625 */
    ZEND_SEND_VAL_SPEC_CONST_HANDLER, /* 1626 */
    ZEND_SEND_VAL_SPEC_CONST_HANDLER, /* 1627 */
    ZEND_SEND_VAL_SPEC_CONST_HANDLER, /* 1628 */
    ZEND_SEND_VAL_SPEC_CONST_HANDLER, /* 1629 */
    ZEND_SEND_VAL_SPEC_TMP_HANDLER, /* 1630 */
    ZEND_SEND_VAL_SPEC_TMP_HANDLER, /* 1631 */
    ZEND_SEND_VAL_SPEC_TMP_HANDLER, /* 1632 */
    ZEND_SEND_VAL_SPEC_TMP_HANDLER, /* 1633 */
    ZEND_SEND_VAL_SPEC_TMP_HANDLER, /* 1634 */
    ZEND_NULL_HANDLER, /* 1635 */
    ZEND_NULL_HANDLER, /* 1636 */
    ZEND_NULL_HANDLER, /* 1637 */
    ZEND_NULL_HANDLER, /* 1638 */
    ZEND_NULL_HANDLER, /* 1639 */
    ZEND_NULL_HANDLER, /* 1640 */
    ZEND_NULL_HANDLER, /* 1641 */
    ZEND_NULL_HANDLER, /* 1642 */
    ZEND_NULL_HANDLER, /* 1643 */
    ZEND_NULL_HANDLER, /* 1644 */
    ZEND_NULL_HANDLER, /* 1645 */
    ZEND_NULL_HANDLER, /* 1646 */
    ZEND_NULL_HANDLER, /* 1647 */
    ZEND_NULL_HANDLER, /* 1648 */
    ZEND_NULL_HANDLER, /* 1649 */
    ZEND_NULL_HANDLER, /* 1650 */
    ZEND_NULL_HANDLER, /* 1651 */
    ZEND_NULL_HANDLER, /* 1652 */
    ZEND_NULL_HANDLER, /* 1653 */
    ZEND_NULL_HANDLER, /* 1654 */
    ZEND_NULL_HANDLER, /* 1655 */
    ZEND_NULL_HANDLER, /* 1656 */
    ZEND_NULL_HANDLER, /* 1657 */
    ZEND_NULL_HANDLER, /* 1658 */
    ZEND_NULL_HANDLER, /* 1659 */
    ZEND_SEND_VAR_SPEC_VAR_HANDLER, /* 1660 */
    ZEND_SEND_VAR_SPEC_VAR_HANDLER, /* 1661 */
    ZEND_SEND_VAR_SPEC_VAR_HANDLER, /* 1662 */
    ZEND_SEND_VAR_SPEC_VAR_HANDLER, /* 1663 */
    ZEND_SEND_VAR_SPEC_VAR_HANDLER, /* 1664 */
    ZEND_NULL_HANDLER, /* 1665 */
    ZEND_NULL_HANDLER, /* 1666 */
    ZEND_NULL_HANDLER, /* 1667 */
    ZEND_NULL_HANDLER, /* 1668 */
    ZEND_NULL_HANDLER, /* 1669 */
    ZEND_SEND_VAR_SPEC_CV_HANDLER, /* 1670 */
    ZEND_SEND_VAR_SPEC_CV_HANDLER, /* 1671 */
    ZEND_SEND_VAR_SPEC_CV_HANDLER, /* 1672 */
    ZEND_SEND_VAR_SPEC_CV_HANDLER, /* 1673 */
    ZEND_SEND_VAR_SPEC_CV_HANDLER, /* 1674 */
    ZEND_NULL_HANDLER, /* 1675 */
    ZEND_NULL_HANDLER, /* 1676 */
    ZEND_NULL_HANDLER, /* 1677 */
    ZEND_NULL_HANDLER, /* 1678 */
    ZEND_NULL_HANDLER, /* 1679 */
    ZEND_NULL_HANDLER, /* 1680 */
    ZEND_NULL_HANDLER, /* 1681 */
    ZEND_NULL_HANDLER, /* 1682 */
    ZEND_NULL_HANDLER, /* 1683 */
    ZEND_NULL_HANDLER, /* 1684 */
    ZEND_SEND_REF_SPEC_VAR_HANDLER, /* 1685 */
    ZEND_SEND_REF_SPEC_VAR_HANDLER, /* 1686 */
    ZEND_SEND_REF_SPEC_VAR_HANDLER, /* 1687 */
    ZEND_SEND_REF_SPEC_VAR_HANDLER, /* 1688 */
    ZEND_SEND_REF_SPEC_VAR_HANDLER, /* 1689 */
    ZEND_NULL_HANDLER, /* 1690 */
    ZEND_NULL_HANDLER, /* 1691 */
    ZEND_NULL_HANDLER, /* 1692 */
    ZEND_NULL_HANDLER, /* 1693 */
    ZEND_NULL_HANDLER, /* 1694 */
    ZEND_SEND_REF_SPEC_CV_HANDLER, /* 1695 */
    ZEND_SEND_REF_SPEC_CV_HANDLER, /* 1696 */
    ZEND_SEND_REF_SPEC_CV_HANDLER, /* 1697 */
    ZEND_SEND_REF_SPEC_CV_HANDLER, /* 1698 */
    ZEND_SEND_REF_SPEC_CV_HANDLER, /* 1699 */
    ZEND_NEW_SPEC_HANDLER, /* 1700 */
    ZEND_NEW_SPEC_HANDLER, /* 1701 */
    ZEND_NEW_SPEC_HANDLER, /* 1702 */
    ZEND_NEW_SPEC_HANDLER, /* 1703 */
    ZEND_NEW_SPEC_HANDLER, /* 1704 */
    ZEND_NEW_SPEC_HANDLER, /* 1705 */
    ZEND_NEW_SPEC_HANDLER, /* 1706 */
    ZEND_NEW_SPEC_HANDLER, /* 1707 */
    ZEND_NEW_SPEC_HANDLER, /* 1708 */
    ZEND_NEW_SPEC_HANDLER, /* 1709 */
    ZEND_NEW_SPEC_HANDLER, /* 1710 */
    ZEND_NEW_SPEC_HANDLER, /* 1711 */
    ZEND_NEW_SPEC_HANDLER, /* 1712 */
    ZEND_NEW_SPEC_HANDLER, /* 1713 */
    ZEND_NEW_SPEC_HANDLER, /* 1714 */
    ZEND_NEW_SPEC_HANDLER, /* 1715 */
    ZEND_NEW_SPEC_HANDLER, /* 1716 */
    ZEND_NEW_SPEC_HANDLER, /* 1717 */
    ZEND_NEW_SPEC_HANDLER, /* 1718 */
    ZEND_NEW_SPEC_HANDLER, /* 1719 */
    ZEND_NEW_SPEC_HANDLER, /* 1720 */
    ZEND_NEW_SPEC_HANDLER, /* 1721 */
    ZEND_NEW_SPEC_HANDLER, /* 1722 */
    ZEND_NEW_SPEC_HANDLER, /* 1723 */
    ZEND_NEW_SPEC_HANDLER, /* 1724 */
    ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER, /* 1725 */
    ZEND_NULL_HANDLER, /* 1726 */
    ZEND_NULL_HANDLER, /* 1727 */
    ZEND_NULL_HANDLER, /* 1728 */
    ZEND_NULL_HANDLER, /* 1729 */
    ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER, /* 1730 */
    ZEND_NULL_HANDLER, /* 1731 */
    ZEND_NULL_HANDLER, /* 1732 */
    ZEND_NULL_HANDLER, /* 1733 */
    ZEND_NULL_HANDLER, /* 1734 */
    ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER, /* 1735 */
    ZEND_NULL_HANDLER, /* 1736 */
    ZEND_NULL_HANDLER, /* 1737 */
    ZEND_NULL_HANDLER, /* 1738 */
    ZEND_NULL_HANDLER, /* 1739 */
    ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER, /* 1740 */
    ZEND_NULL_HANDLER, /* 1741 */
    ZEND_NULL_HANDLER, /* 1742 */
    ZEND_NULL_HANDLER, /* 1743 */
    ZEND_NULL_HANDLER, /* 1744 */
    ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER, /* 1745 */
    ZEND_NULL_HANDLER, /* 1746 */
    ZEND_NULL_HANDLER, /* 1747 */
    ZEND_NULL_HANDLER, /* 1748 */
    ZEND_NULL_HANDLER, /* 1749 */
    ZEND_NULL_HANDLER, /* 1750 */
    ZEND_NULL_HANDLER, /* 1751 */
    ZEND_NULL_HANDLER, /* 1752 */
    ZEND_NULL_HANDLER, /* 1753 */
    ZEND_NULL_HANDLER, /* 1754 */
    ZEND_FREE_SPEC_TMP_HANDLER, /* 1755 */
    ZEND_FREE_SPEC_TMP_HANDLER, /* 1756 */
    ZEND_FREE_SPEC_TMP_HANDLER, /* 1757 */
    ZEND_FREE_SPEC_TMP_HANDLER, /* 1758 */
    ZEND_FREE_SPEC_TMP_HANDLER, /* 1759 */
    ZEND_FREE_SPEC_VAR_HANDLER, /* 1760 */
    ZEND_FREE_SPEC_VAR_HANDLER, /* 1761 */
    ZEND_FREE_SPEC_VAR_HANDLER, /* 1762 */
    ZEND_FREE_SPEC_VAR_HANDLER, /* 1763 */
    ZEND_FREE_SPEC_VAR_HANDLER, /* 1764 */
    ZEND_NULL_HANDLER, /* 1765 */
    ZEND_NULL_HANDLER, /* 1766 */
    ZEND_NULL_HANDLER, /* 1767 */
    ZEND_NULL_HANDLER, /* 1768 */
    ZEND_NULL_HANDLER, /* 1769 */
    ZEND_NULL_HANDLER, /* 1770 */
    ZEND_NULL_HANDLER, /* 1771 */
    ZEND_NULL_HANDLER, /* 1772 */
    ZEND_NULL_HANDLER, /* 1773 */
    ZEND_NULL_HANDLER, /* 1774 */
    ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER, /* 1775 */
    ZEND_INIT_ARRAY_SPEC_CONST_TMP_HANDLER, /* 1776 */
    ZEND_INIT_ARRAY_SPEC_CONST_VAR_HANDLER, /* 1777 */
    ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER, /* 1778 */
    ZEND_INIT_ARRAY_SPEC_CONST_CV_HANDLER, /* 1779 */
    ZEND_INIT_ARRAY_SPEC_TMP_CONST_HANDLER, /* 1780 */
    ZEND_INIT_ARRAY_SPEC_TMP_TMP_HANDLER, /* 1781 */
    ZEND_INIT_ARRAY_SPEC_TMP_VAR_HANDLER, /* 1782 */
    ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER, /* 1783 */
    ZEND_INIT_ARRAY_SPEC_TMP_CV_HANDLER, /* 1784 */
    ZEND_INIT_ARRAY_SPEC_VAR_CONST_HANDLER, /* 1785 */
    ZEND_INIT_ARRAY_SPEC_VAR_TMP_HANDLER, /* 1786 */
    ZEND_INIT_ARRAY_SPEC_VAR_VAR_HANDLER, /* 1787 */
    ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER, /* 1788 */
    ZEND_INIT_ARRAY_SPEC_VAR_CV_HANDLER, /* 1789 */
    ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER, /* 1790 */
    ZEND_INIT_ARRAY_SPEC_UNUSED_TMP_HANDLER, /* 1791 */
    ZEND_INIT_ARRAY_SPEC_UNUSED_VAR_HANDLER, /* 1792 */
    ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER, /* 1793 */
    ZEND_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER, /* 1794 */
    ZEND_INIT_ARRAY_SPEC_CV_CONST_HANDLER, /* 1795 */
    ZEND_INIT_ARRAY_SPEC_CV_TMP_HANDLER, /* 1796 */
    ZEND_INIT_ARRAY_SPEC_CV_VAR_HANDLER, /* 1797 */
    ZEND_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER, /* 1798 */
    ZEND_INIT_ARRAY_SPEC_CV_CV_HANDLER, /* 1799 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER, /* 1800 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_HANDLER, /* 1801 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_HANDLER, /* 1802 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER, /* 1803 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER, /* 1804 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER, /* 1805 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_HANDLER, /* 1806 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_HANDLER, /* 1807 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER, /* 1808 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER, /* 1809 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER, /* 1810 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_HANDLER, /* 1811 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_HANDLER, /* 1812 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER, /* 1813 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER, /* 1814 */
    ZEND_NULL_HANDLER, /* 1815 */
    ZEND_NULL_HANDLER, /* 1816 */
    ZEND_NULL_HANDLER, /* 1817 */
    ZEND_NULL_HANDLER, /* 1818 */
    ZEND_NULL_HANDLER, /* 1819 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER, /* 1820 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_HANDLER, /* 1821 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_HANDLER, /* 1822 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER, /* 1823 */
    ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER, /* 1824 */
    ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER, /* 1825 */
    ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER, /* 1826 */
    ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER, /* 1827 */
    ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER, /* 1828 */
    ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER, /* 1829 */
    ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER, /* 1830 */
    ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER, /* 1831 */
    ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER, /* 1832 */
    ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER, /* 1833 */
    ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER, /* 1834 */
    ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER, /* 1835 */
    ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER, /* 1836 */
    ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER, /* 1837 */
    ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER, /* 1838 */
    ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER, /* 1839 */
    ZEND_NULL_HANDLER, /* 1840 */
    ZEND_NULL_HANDLER, /* 1841 */
    ZEND_NULL_HANDLER, /* 1842 */
    ZEND_NULL_HANDLER, /* 1843 */
    ZEND_NULL_HANDLER, /* 1844 */
    ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER, /* 1845 */
    ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER, /* 1846 */
    ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER, /* 1847 */
    ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER, /* 1848 */
    ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER, /* 1849 */
    ZEND_UNSET_VAR_SPEC_CONST_CONST_HANDLER, /* 1850 */
    ZEND_NULL_HANDLER, /* 1851 */
    ZEND_UNSET_VAR_SPEC_CONST_VAR_HANDLER, /* 1852 */
    ZEND_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER, /* 1853 */
    ZEND_NULL_HANDLER, /* 1854 */
    ZEND_UNSET_VAR_SPEC_TMP_CONST_HANDLER, /* 1855 */
    ZEND_NULL_HANDLER, /* 1856 */
    ZEND_UNSET_VAR_SPEC_TMP_VAR_HANDLER, /* 1857 */
    ZEND_UNSET_VAR_SPEC_TMP_UNUSED_HANDLER, /* 1858 */
    ZEND_NULL_HANDLER, /* 1859 */
    ZEND_UNSET_VAR_SPEC_VAR_CONST_HANDLER, /* 1860 */
    ZEND_NULL_HANDLER, /* 1861 */
    ZEND_UNSET_VAR_SPEC_VAR_VAR_HANDLER, /* 1862 */
    ZEND_UNSET_VAR_SPEC_VAR_UNUSED_HANDLER, /* 1863 */
    ZEND_NULL_HANDLER, /* 1864 */
    ZEND_NULL_HANDLER, /* 1865 */
    ZEND_NULL_HANDLER, /* 1866 */
    ZEND_NULL_HANDLER, /* 1867 */
    ZEND_NULL_HANDLER, /* 1868 */
    ZEND_NULL_HANDLER, /* 1869 */
    ZEND_UNSET_VAR_SPEC_CV_CONST_HANDLER, /* 1870 */
    ZEND_NULL_HANDLER, /* 1871 */
    ZEND_UNSET_VAR_SPEC_CV_VAR_HANDLER, /* 1872 */
    ZEND_UNSET_VAR_SPEC_CV_UNUSED_HANDLER, /* 1873 */
    ZEND_NULL_HANDLER, /* 1874 */
    ZEND_NULL_HANDLER, /* 1875 */
    ZEND_NULL_HANDLER, /* 1876 */
    ZEND_NULL_HANDLER, /* 1877 */
    ZEND_NULL_HANDLER, /* 1878 */
    ZEND_NULL_HANDLER, /* 1879 */
    ZEND_NULL_HANDLER, /* 1880 */
    ZEND_NULL_HANDLER, /* 1881 */
    ZEND_NULL_HANDLER, /* 1882 */
    ZEND_NULL_HANDLER, /* 1883 */
    ZEND_NULL_HANDLER, /* 1884 */
    ZEND_UNSET_DIM_SPEC_VAR_CONST_HANDLER, /* 1885 */
    ZEND_UNSET_DIM_SPEC_VAR_TMP_HANDLER, /* 1886 */
    ZEND_UNSET_DIM_SPEC_VAR_VAR_HANDLER, /* 1887 */
    ZEND_NULL_HANDLER, /* 1888 */
    ZEND_UNSET_DIM_SPEC_VAR_CV_HANDLER, /* 1889 */
    ZEND_UNSET_DIM_SPEC_UNUSED_CONST_HANDLER, /* 1890 */
    ZEND_UNSET_DIM_SPEC_UNUSED_TMP_HANDLER, /* 1891 */
    ZEND_UNSET_DIM_SPEC_UNUSED_VAR_HANDLER, /* 1892 */
    ZEND_NULL_HANDLER, /* 1893 */
    ZEND_UNSET_DIM_SPEC_UNUSED_CV_HANDLER, /* 1894 */
    ZEND_UNSET_DIM_SPEC_CV_CONST_HANDLER, /* 1895 */
    ZEND_UNSET_DIM_SPEC_CV_TMP_HANDLER, /* 1896 */
    ZEND_UNSET_DIM_SPEC_CV_VAR_HANDLER, /* 1897 */
    ZEND_NULL_HANDLER, /* 1898 */
    ZEND_UNSET_DIM_SPEC_CV_CV_HANDLER, /* 1899 */
    ZEND_NULL_HANDLER, /* 1900 */
    ZEND_NULL_HANDLER, /* 1901 */
    ZEND_NULL_HANDLER, /* 1902 */
    ZEND_NULL_HANDLER, /* 1903 */
    ZEND_NULL_HANDLER, /* 1904 */
    ZEND_NULL_HANDLER, /* 1905 */
    ZEND_NULL_HANDLER, /* 1906 */
    ZEND_NULL_HANDLER, /* 1907 */
    ZEND_NULL_HANDLER, /* 1908 */
    ZEND_NULL_HANDLER, /* 1909 */
    ZEND_UNSET_OBJ_SPEC_VAR_CONST_HANDLER, /* 1910 */
    ZEND_UNSET_OBJ_SPEC_VAR_TMP_HANDLER, /* 1911 */
    ZEND_UNSET_OBJ_SPEC_VAR_VAR_HANDLER, /* 1912 */
    ZEND_NULL_HANDLER, /* 1913 */
    ZEND_UNSET_OBJ_SPEC_VAR_CV_HANDLER, /* 1914 */
    ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER, /* 1915 */
    ZEND_UNSET_OBJ_SPEC_UNUSED_TMP_HANDLER, /* 1916 */
    ZEND_UNSET_OBJ_SPEC_UNUSED_VAR_HANDLER, /* 1917 */
    ZEND_NULL_HANDLER, /* 1918 */
    ZEND_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER, /* 1919 */
    ZEND_UNSET_OBJ_SPEC_CV_CONST_HANDLER, /* 1920 */
    ZEND_UNSET_OBJ_SPEC_CV_TMP_HANDLER, /* 1921 */
    ZEND_UNSET_OBJ_SPEC_CV_VAR_HANDLER, /* 1922 */
    ZEND_NULL_HANDLER, /* 1923 */
    ZEND_UNSET_OBJ_SPEC_CV_CV_HANDLER, /* 1924 */
    ZEND_FE_RESET_SPEC_CONST_HANDLER, /* 1925 */
    ZEND_FE_RESET_SPEC_CONST_HANDLER, /* 1926 */
    ZEND_FE_RESET_SPEC_CONST_HANDLER, /* 1927 */
    ZEND_FE_RESET_SPEC_CONST_HANDLER, /* 1928 */
    ZEND_FE_RESET_SPEC_CONST_HANDLER, /* 1929 */
    ZEND_FE_RESET_SPEC_TMP_HANDLER, /* 1930 */
    ZEND_FE_RESET_SPEC_TMP_HANDLER, /* 1931 */
    ZEND_FE_RESET_SPEC_TMP_HANDLER, /* 1932 */
    ZEND_FE_RESET_SPEC_TMP_HANDLER, /* 1933 */
    ZEND_FE_RESET_SPEC_TMP_HANDLER, /* 1934 */
    ZEND_FE_RESET_SPEC_VAR_HANDLER, /* 1935 */
    ZEND_FE_RESET_SPEC_VAR_HANDLER, /* 1936 */
    ZEND_FE_RESET_SPEC_VAR_HANDLER, /* 1937 */
    ZEND_FE_RESET_SPEC_VAR_HANDLER, /* 1938 */
    ZEND_FE_RESET_SPEC_VAR_HANDLER, /* 1939 */
    ZEND_NULL_HANDLER, /* 1940 */
    ZEND_NULL_HANDLER, /* 1941 */
    ZEND_NULL_HANDLER, /* 1942 */
    ZEND_NULL_HANDLER, /* 1943 */
    ZEND_NULL_HANDLER, /* 1944 */
    ZEND_FE_RESET_SPEC_CV_HANDLER, /* 1945 */
    ZEND_FE_RESET_SPEC_CV_HANDLER, /* 1946 */
    ZEND_FE_RESET_SPEC_CV_HANDLER, /* 1947 */
    ZEND_FE_RESET_SPEC_CV_HANDLER, /* 1948 */
    ZEND_FE_RESET_SPEC_CV_HANDLER, /* 1949 */
    ZEND_NULL_HANDLER, /* 1950 */
    ZEND_NULL_HANDLER, /* 1951 */
    ZEND_NULL_HANDLER, /* 1952 */
    ZEND_NULL_HANDLER, /* 1953 */
    ZEND_NULL_HANDLER, /* 1954 */
    ZEND_NULL_HANDLER, /* 1955 */
    ZEND_NULL_HANDLER, /* 1956 */
    ZEND_NULL_HANDLER, /* 1957 */
    ZEND_NULL_HANDLER, /* 1958 */
    ZEND_NULL_HANDLER, /* 1959 */
    ZEND_FE_FETCH_SPEC_VAR_HANDLER, /* 1960 */
    ZEND_FE_FETCH_SPEC_VAR_HANDLER, /* 1961 */
    ZEND_FE_FETCH_SPEC_VAR_HANDLER, /* 1962 */
    ZEND_FE_FETCH_SPEC_VAR_HANDLER, /* 1963 */
    ZEND_FE_FETCH_SPEC_VAR_HANDLER, /* 1964 */
    ZEND_NULL_HANDLER, /* 1965 */
    ZEND_NULL_HANDLER, /* 1966 */
    ZEND_NULL_HANDLER, /* 1967 */
    ZEND_NULL_HANDLER, /* 1968 */
    ZEND_NULL_HANDLER, /* 1969 */
    ZEND_NULL_HANDLER, /* 1970 */
    ZEND_NULL_HANDLER, /* 1971 */
    ZEND_NULL_HANDLER, /* 1972 */
    ZEND_NULL_HANDLER, /* 1973 */
    ZEND_NULL_HANDLER, /* 1974 */
    ZEND_EXIT_SPEC_CONST_HANDLER, /* 1975 */
    ZEND_EXIT_SPEC_CONST_HANDLER, /* 1976 */
    ZEND_EXIT_SPEC_CONST_HANDLER, /* 1977 */
    ZEND_EXIT_SPEC_CONST_HANDLER, /* 1978 */
    ZEND_EXIT_SPEC_CONST_HANDLER, /* 1979 */
    ZEND_EXIT_SPEC_TMP_HANDLER, /* 1980 */
    ZEND_EXIT_SPEC_TMP_HANDLER, /* 1981 */
    ZEND_EXIT_SPEC_TMP_HANDLER, /* 1982 */
    ZEND_EXIT_SPEC_TMP_HANDLER, /* 1983 */
    ZEND_EXIT_SPEC_TMP_HANDLER, /* 1984 */
    ZEND_EXIT_SPEC_VAR_HANDLER, /* 1985 */
    ZEND_EXIT_SPEC_VAR_HANDLER, /* 1986 */
    ZEND_EXIT_SPEC_VAR_HANDLER, /* 1987 */
    ZEND_EXIT_SPEC_VAR_HANDLER, /* 1988 */
    ZEND_EXIT_SPEC_VAR_HANDLER, /* 1989 */
    ZEND_EXIT_SPEC_UNUSED_HANDLER, /* 1990 */
    ZEND_EXIT_SPEC_UNUSED_HANDLER, /* 1991 */
    ZEND_EXIT_SPEC_UNUSED_HANDLER, /* 1992 */
    ZEND_EXIT_SPEC_UNUSED_HANDLER, /* 1993 */
    ZEND_EXIT_SPEC_UNUSED_HANDLER, /* 1994 */
    ZEND_EXIT_SPEC_CV_HANDLER, /* 1995 */
    ZEND_EXIT_SPEC_CV_HANDLER, /* 1996 */
    ZEND_EXIT_SPEC_CV_HANDLER, /* 1997 */
    ZEND_EXIT_SPEC_CV_HANDLER, /* 1998 */
    ZEND_EXIT_SPEC_CV_HANDLER, /* 1999 */
    ZEND_FETCH_R_SPEC_CONST_CONST_HANDLER, /* 2000 */
    ZEND_NULL_HANDLER, /* 2001 */
    ZEND_FETCH_R_SPEC_CONST_VAR_HANDLER, /* 2002 */
    ZEND_FETCH_R_SPEC_CONST_UNUSED_HANDLER, /* 2003 */
    ZEND_NULL_HANDLER, /* 2004 */
    ZEND_FETCH_R_SPEC_TMP_CONST_HANDLER, /* 2005 */
    ZEND_NULL_HANDLER, /* 2006 */
    ZEND_FETCH_R_SPEC_TMP_VAR_HANDLER, /* 2007 */
    ZEND_FETCH_R_SPEC_TMP_UNUSED_HANDLER, /* 2008 */
    ZEND_NULL_HANDLER, /* 2009 */
    ZEND_FETCH_R_SPEC_VAR_CONST_HANDLER, /* 2010 */
    ZEND_NULL_HANDLER, /* 2011 */
    ZEND_FETCH_R_SPEC_VAR_VAR_HANDLER, /* 2012 */
    ZEND_FETCH_R_SPEC_VAR_UNUSED_HANDLER, /* 2013 */
    ZEND_NULL_HANDLER, /* 2014 */
    ZEND_NULL_HANDLER, /* 2015 */
    ZEND_NULL_HANDLER, /* 2016 */
    ZEND_NULL_HANDLER, /* 2017 */
    ZEND_NULL_HANDLER, /* 2018 */
    ZEND_NULL_HANDLER, /* 2019 */
    ZEND_FETCH_R_SPEC_CV_CONST_HANDLER, /* 2020 */
    ZEND_NULL_HANDLER, /* 2021 */
    ZEND_FETCH_R_SPEC_CV_VAR_HANDLER, /* 2022 */
    ZEND_FETCH_R_SPEC_CV_UNUSED_HANDLER, /* 2023 */
    ZEND_NULL_HANDLER, /* 2024 */
    ZEND_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER, /* 2025 */
    ZEND_FETCH_DIM_R_SPEC_CONST_TMP_HANDLER, /* 2026 */
    ZEND_FETCH_DIM_R_SPEC_CONST_VAR_HANDLER, /* 2027 */
    ZEND_NULL_HANDLER, /* 2028 */
    ZEND_FETCH_DIM_R_SPEC_CONST_CV_HANDLER, /* 2029 */
    ZEND_FETCH_DIM_R_SPEC_TMP_CONST_HANDLER, /* 2030 */
    ZEND_FETCH_DIM_R_SPEC_TMP_TMP_HANDLER, /* 2031 */
    ZEND_FETCH_DIM_R_SPEC_TMP_VAR_HANDLER, /* 2032 */
    ZEND_NULL_HANDLER, /* 2033 */
    ZEND_FETCH_DIM_R_SPEC_TMP_CV_HANDLER, /* 2034 */
    ZEND_FETCH_DIM_R_SPEC_VAR_CONST_HANDLER, /* 2035 */
    ZEND_FETCH_DIM_R_SPEC_VAR_TMP_HANDLER, /* 2036 */
    ZEND_FETCH_DIM_R_SPEC_VAR_VAR_HANDLER, /* 2037 */
    ZEND_NULL_HANDLER, /* 2038 */
    ZEND_FETCH_DIM_R_SPEC_VAR_CV_HANDLER, /* 2039 */
    ZEND_NULL_HANDLER, /* 2040 */
    ZEND_NULL_HANDLER, /* 2041 */
    ZEND_NULL_HANDLER, /* 2042 */
    ZEND_NULL_HANDLER, /* 2043 */
    ZEND_NULL_HANDLER, /* 2044 */
    ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER, /* 2045 */
    ZEND_FETCH_DIM_R_SPEC_CV_TMP_HANDLER, /* 2046 */
    ZEND_FETCH_DIM_R_SPEC_CV_VAR_HANDLER, /* 2047 */
    ZEND_NULL_HANDLER, /* 2048 */
    ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER, /* 2049 */
    ZEND_NULL_HANDLER, /* 2050 */
    ZEND_NULL_HANDLER, /* 2051 */
    ZEND_NULL_HANDLER, /* 2052 */
    ZEND_NULL_HANDLER, /* 2053 */
    ZEND_NULL_HANDLER, /* 2054 */
    ZEND_NULL_HANDLER, /* 2055 */
    ZEND_NULL_HANDLER, /* 2056 */
    ZEND_NULL_HANDLER, /* 2057 */
    ZEND_NULL_HANDLER, /* 2058 */
    ZEND_NULL_HANDLER, /* 2059 */
    ZEND_FETCH_OBJ_R_SPEC_VAR_CONST_HANDLER, /* 2060 */
    ZEND_FETCH_OBJ_R_SPEC_VAR_TMP_HANDLER, /* 2061 */
    ZEND_FETCH_OBJ_R_SPEC_VAR_VAR_HANDLER, /* 2062 */
    ZEND_NULL_HANDLER, /* 2063 */
    ZEND_FETCH_OBJ_R_SPEC_VAR_CV_HANDLER, /* 2064 */
    ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER, /* 2065 */
    ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMP_HANDLER, /* 2066 */
    ZEND_FETCH_OBJ_R_SPEC_UNUSED_VAR_HANDLER, /* 2067 */
    ZEND_NULL_HANDLER, /* 2068 */
    ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER, /* 2069 */
    ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER, /* 2070 */
    ZEND_FETCH_OBJ_R_SPEC_CV_TMP_HANDLER, /* 2071 */
    ZEND_FETCH_OBJ_R_SPEC_CV_VAR_HANDLER, /* 2072 */
    ZEND_NULL_HANDLER, /* 2073 */
    ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER, /* 2074 */
    ZEND_FETCH_W_SPEC_CONST_CONST_HANDLER, /* 2075 */
    ZEND_NULL_HANDLER, /* 2076 */
    ZEND_FETCH_W_SPEC_CONST_VAR_HANDLER, /* 2077 */
    ZEND_FETCH_W_SPEC_CONST_UNUSED_HANDLER, /* 2078 */
    ZEND_NULL_HANDLER, /* 2079 */
    ZEND_FETCH_W_SPEC_TMP_CONST_HANDLER, /* 2080 */
    ZEND_NULL_HANDLER, /* 2081 */
    ZEND_FETCH_W_SPEC_TMP_VAR_HANDLER, /* 2082 */
    ZEND_FETCH_W_SPEC_TMP_UNUSED_HANDLER, /* 2083 */
    ZEND_NULL_HANDLER, /* 2084 */
    ZEND_FETCH_W_SPEC_VAR_CONST_HANDLER, /* 2085 */
    ZEND_NULL_HANDLER, /* 2086 */
    ZEND_FETCH_W_SPEC_VAR_VAR_HANDLER, /* 2087 */
    ZEND_FETCH_W_SPEC_VAR_UNUSED_HANDLER, /* 2088 */
    ZEND_NULL_HANDLER, /* 2089 */
    ZEND_NULL_HANDLER, /* 2090 */
    ZEND_NULL_HANDLER, /* 2091 */
    ZEND_NULL_HANDLER, /* 2092 */
    ZEND_NULL_HANDLER, /* 2093 */
    ZEND_NULL_HANDLER, /* 2094 */
    ZEND_FETCH_W_SPEC_CV_CONST_HANDLER, /* 2095 */
    ZEND_NULL_HANDLER, /* 2096 */
    ZEND_FETCH_W_SPEC_CV_VAR_HANDLER, /* 2097 */
    ZEND_FETCH_W_SPEC_CV_UNUSED_HANDLER, /* 2098 */
    ZEND_NULL_HANDLER, /* 2099 */
    ZEND_NULL_HANDLER, /* 2100 */
    ZEND_NULL_HANDLER, /* 2101 */
    ZEND_NULL_HANDLER, /* 2102 */
    ZEND_NULL_HANDLER, /* 2103 */
    ZEND_NULL_HANDLER, /* 2104 */
    ZEND_NULL_HANDLER, /* 2105 */
    ZEND_NULL_HANDLER, /* 2106 */
    ZEND_NULL_HANDLER, /* 2107 */
    ZEND_NULL_HANDLER, /* 2108 */
    ZEND_NULL_HANDLER, /* 2109 */
    ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER, /* 2110 */
    ZEND_FETCH_DIM_W_SPEC_VAR_TMP_HANDLER, /* 2111 */
    ZEND_FETCH_DIM_W_SPEC_VAR_VAR_HANDLER, /* 2112 */
    ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER, /* 2113 */
    ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER, /* 2114 */
    ZEND_NULL_HANDLER, /* 2115 */
    ZEND_NULL_HANDLER, /* 2116 */
    ZEND_NULL_HANDLER, /* 2117 */
    ZEND_NULL_HANDLER, /* 2118 */
    ZEND_NULL_HANDLER, /* 2119 */
    ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER, /* 2120 */
    ZEND_FETCH_DIM_W_SPEC_CV_TMP_HANDLER, /* 2121 */
    ZEND_FETCH_DIM_W_SPEC_CV_VAR_HANDLER, /* 2122 */
    ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER, /* 2123 */
    ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER, /* 2124 */
    ZEND_NULL_HANDLER, /* 2125 */
    ZEND_NULL_HANDLER, /* 2126 */
    ZEND_NULL_HANDLER, /* 2127 */
    ZEND_NULL_HANDLER, /* 2128 */
    ZEND_NULL_HANDLER, /* 2129 */
    ZEND_NULL_HANDLER, /* 2130 */
    ZEND_NULL_HANDLER, /* 2131 */
    ZEND_NULL_HANDLER, /* 2132 */
    ZEND_NULL_HANDLER, /* 2133 */
    ZEND_NULL_HANDLER, /* 2134 */
    ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER, /* 2135 */
    ZEND_FETCH_OBJ_W_SPEC_VAR_TMP_HANDLER, /* 2136 */
    ZEND_FETCH_OBJ_W_SPEC_VAR_VAR_HANDLER, /* 2137 */
    ZEND_NULL_HANDLER, /* 2138 */
    ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER, /* 2139 */
    ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER, /* 2140 */
    ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMP_HANDLER, /* 2141 */
    ZEND_FETCH_OBJ_W_SPEC_UNUSED_VAR_HANDLER, /* 2142 */
    ZEND_NULL_HANDLER, /* 2143 */
    ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER, /* 2144 */
    ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER, /* 2145 */
    ZEND_FETCH_OBJ_W_SPEC_CV_TMP_HANDLER, /* 2146 */
    ZEND_FETCH_OBJ_W_SPEC_CV_VAR_HANDLER, /* 2147 */
    ZEND_NULL_HANDLER, /* 2148 */
    ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER, /* 2149 */
    ZEND_FETCH_RW_SPEC_CONST_CONST_HANDLER, /* 2150 */
    ZEND_NULL_HANDLER, /* 2151 */
    ZEND_FETCH_RW_SPEC_CONST_VAR_HANDLER, /* 2152 */
    ZEND_FETCH_RW_SPEC_CONST_UNUSED_HANDLER, /* 2153 */
    ZEND_NULL_HANDLER, /* 2154 */
    ZEND_FETCH_RW_SPEC_TMP_CONST_HANDLER, /* 2155 */
    ZEND_NULL_HANDLER, /* 2156 */
    ZEND_FETCH_RW_SPEC_TMP_VAR_HANDLER, /* 2157 */
    ZEND_FETCH_RW_SPEC_TMP_UNUSED_HANDLER, /* 2158 */
    ZEND_NULL_HANDLER, /* 2159 */
    ZEND_FETCH_RW_SPEC_VAR_CONST_HANDLER, /* 2160 */
    ZEND_NULL_HANDLER, /* 2161 */
    ZEND_FETCH_RW_SPEC_VAR_VAR_HANDLER, /* 2162 */
    ZEND_FETCH_RW_SPEC_VAR_UNUSED_HANDLER, /* 2163 */
    ZEND_NULL_HANDLER, /* 2164 */
    ZEND_NULL_HANDLER, /* 2165 */
    ZEND_NULL_HANDLER, /* 2166 */
    ZEND_NULL_HANDLER, /* 2167 */
    ZEND_NULL_HANDLER, /* 2168 */
    ZEND_NULL_HANDLER, /* 2169 */
    ZEND_FETCH_RW_SPEC_CV_CONST_HANDLER, /* 2170 */
    ZEND_NULL_HANDLER, /* 2171 */
    ZEND_FETCH_RW_SPEC_CV_VAR_HANDLER, /* 2172 */
    ZEND_FETCH_RW_SPEC_CV_UNUSED_HANDLER, /* 2173 */
    ZEND_NULL_HANDLER, /* 2174 */
    ZEND_NULL_HANDLER, /* 2175 */
    ZEND_NULL_HANDLER, /* 2176 */
    ZEND_NULL_HANDLER, /* 2177 */
    ZEND_NULL_HANDLER, /* 2178 */
    ZEND_NULL_HANDLER, /* 2179 */
    ZEND_NULL_HANDLER, /* 2180 */
    ZEND_NULL_HANDLER, /* 2181 */
    ZEND_NULL_HANDLER, /* 2182 */
    ZEND_NULL_HANDLER, /* 2183 */
    ZEND_NULL_HANDLER, /* 2184 */
    ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER, /* 2185 */
    ZEND_FETCH_DIM_RW_SPEC_VAR_TMP_HANDLER, /* 2186 */
    ZEND_FETCH_DIM_RW_SPEC_VAR_VAR_HANDLER, /* 2187 */
    ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER, /* 2188 */
    ZEND_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER, /* 2189 */
    ZEND_NULL_HANDLER, /* 2190 */
    ZEND_NULL_HANDLER, /* 2191 */
    ZEND_NULL_HANDLER, /* 2192 */
    ZEND_NULL_HANDLER, /* 2193 */
    ZEND_NULL_HANDLER, /* 2194 */
    ZEND_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER, /* 2195 */
    ZEND_FETCH_DIM_RW_SPEC_CV_TMP_HANDLER, /* 2196 */
    ZEND_FETCH_DIM_RW_SPEC_CV_VAR_HANDLER, /* 2197 */
    ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER, /* 2198 */
    ZEND_FETCH_DIM_RW_SPEC_CV_CV_HANDLER, /* 2199 */
    ZEND_NULL_HANDLER, /* 2200 */
    ZEND_NULL_HANDLER, /* 2201 */
    ZEND_NULL_HANDLER, /* 2202 */
    ZEND_NULL_HANDLER, /* 2203 */
    ZEND_NULL_HANDLER, /* 2204 */
    ZEND_NULL_HANDLER, /* 2205 */
    ZEND_NULL_HANDLER, /* 2206 */
    ZEND_NULL_HANDLER, /* 2207 */
    ZEND_NULL_HANDLER, /* 2208 */
    ZEND_NULL_HANDLER, /* 2209 */
    ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER, /* 2210 */
    ZEND_FETCH_OBJ_RW_SPEC_VAR_TMP_HANDLER, /* 2211 */
    ZEND_FETCH_OBJ_RW_SPEC_VAR_VAR_HANDLER, /* 2212 */
    ZEND_NULL_HANDLER, /* 2213 */
    ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER, /* 2214 */
    ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER, /* 2215 */
    ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMP_HANDLER, /* 2216 */
    ZEND_FETCH_OBJ_RW_SPEC_UNUSED_VAR_HANDLER, /* 2217 */
    ZEND_NULL_HANDLER, /* 2218 */
    ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER, /* 2219 */
    ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER, /* 2220 */
    ZEND_FETCH_OBJ_RW_SPEC_CV_TMP_HANDLER, /* 2221 */
    ZEND_FETCH_OBJ_RW_SPEC_CV_VAR_HANDLER, /* 2222 */
    ZEND_NULL_HANDLER, /* 2223 */
    ZEND_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER, /* 2224 */
    ZEND_FETCH_IS_SPEC_CONST_CONST_HANDLER, /* 2225 */
    ZEND_NULL_HANDLER, /* 2226 */
    ZEND_FETCH_IS_SPEC_CONST_VAR_HANDLER, /* 2227 */
    ZEND_FETCH_IS_SPEC_CONST_UNUSED_HANDLER, /* 2228 */
    ZEND_NULL_HANDLER, /* 2229 */
    ZEND_FETCH_IS_SPEC_TMP_CONST_HANDLER, /* 2230 */
    ZEND_NULL_HANDLER, /* 2231 */
    ZEND_FETCH_IS_SPEC_TMP_VAR_HANDLER, /* 2232 */
    ZEND_FETCH_IS_SPEC_TMP_UNUSED_HANDLER, /* 2233 */
    ZEND_NULL_HANDLER, /* 2234 */
    ZEND_FETCH_IS_SPEC_VAR_CONST_HANDLER, /* 2235 */
    ZEND_NULL_HANDLER, /* 2236 */
    ZEND_FETCH_IS_SPEC_VAR_VAR_HANDLER, /* 2237 */
    ZEND_FETCH_IS_SPEC_VAR_UNUSED_HANDLER, /* 2238 */
    ZEND_NULL_HANDLER, /* 2239 */
    ZEND_NULL_HANDLER, /* 2240 */
    ZEND_NULL_HANDLER, /* 2241 */
    ZEND_NULL_HANDLER, /* 2242 */
    ZEND_NULL_HANDLER, /* 2243 */
    ZEND_NULL_HANDLER, /* 2244 */
    ZEND_FETCH_IS_SPEC_CV_CONST_HANDLER, /* 2245 */
    ZEND_NULL_HANDLER, /* 2246 */
    ZEND_FETCH_IS_SPEC_CV_VAR_HANDLER, /* 2247 */
    ZEND_FETCH_IS_SPEC_CV_UNUSED_HANDLER, /* 2248 */
    ZEND_NULL_HANDLER, /* 2249 */
    ZEND_NULL_HANDLER, /* 2250 */
    ZEND_NULL_HANDLER, /* 2251 */
    ZEND_NULL_HANDLER, /* 2252 */
    ZEND_NULL_HANDLER, /* 2253 */
    ZEND_NULL_HANDLER, /* 2254 */
    ZEND_NULL_HANDLER, /* 2255 */
    ZEND_NULL_HANDLER, /* 2256 */
    ZEND_NULL_HANDLER, /* 2257 */
    ZEND_NULL_HANDLER, /* 2258 */
    ZEND_NULL_HANDLER, /* 2259 */
    ZEND_FETCH_DIM_IS_SPEC_VAR_CONST_HANDLER, /* 2260 */
    ZEND_FETCH_DIM_IS_SPEC_VAR_TMP_HANDLER, /* 2261 */
    ZEND_FETCH_DIM_IS_SPEC_VAR_VAR_HANDLER, /* 2262 */
    ZEND_NULL_HANDLER, /* 2263 */
    ZEND_FETCH_DIM_IS_SPEC_VAR_CV_HANDLER, /* 2264 */
    ZEND_NULL_HANDLER, /* 2265 */
    ZEND_NULL_HANDLER, /* 2266 */
    ZEND_NULL_HANDLER, /* 2267 */
    ZEND_NULL_HANDLER, /* 2268 */
    ZEND_NULL_HANDLER, /* 2269 */
    ZEND_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER, /* 2270 */
    ZEND_FETCH_DIM_IS_SPEC_CV_TMP_HANDLER, /* 2271 */
    ZEND_FETCH_DIM_IS_SPEC_CV_VAR_HANDLER, /* 2272 */
    ZEND_NULL_HANDLER, /* 2273 */
    ZEND_FETCH_DIM_IS_SPEC_CV_CV_HANDLER, /* 2274 */
    ZEND_NULL_HANDLER, /* 2275 */
    ZEND_NULL_HANDLER, /* 2276 */
    ZEND_NULL_HANDLER, /* 2277 */
    ZEND_NULL_HANDLER, /* 2278 */
    ZEND_NULL_HANDLER, /* 2279 */
    ZEND_NULL_HANDLER, /* 2280 */
    ZEND_NULL_HANDLER, /* 2281 */
    ZEND_NULL_HANDLER, /* 2282 */
    ZEND_NULL_HANDLER, /* 2283 */
    ZEND_NULL_HANDLER, /* 2284 */
    ZEND_FETCH_OBJ_IS_SPEC_VAR_CONST_HANDLER, /* 2285 */
    ZEND_FETCH_OBJ_IS_SPEC_VAR_TMP_HANDLER, /* 2286 */
    ZEND_FETCH_OBJ_IS_SPEC_VAR_VAR_HANDLER, /* 2287 */
    ZEND_NULL_HANDLER, /* 2288 */
    ZEND_FETCH_OBJ_IS_SPEC_VAR_CV_HANDLER, /* 2289 */
    ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER, /* 2290 */
    ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMP_HANDLER, /* 2291 */
    ZEND_FETCH_OBJ_IS_SPEC_UNUSED_VAR_HANDLER, /* 2292 */
    ZEND_NULL_HANDLER, /* 2293 */
    ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER, /* 2294 */
    ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER, /* 2295 */
    ZEND_FETCH_OBJ_IS_SPEC_CV_TMP_HANDLER, /* 2296 */
    ZEND_FETCH_OBJ_IS_SPEC_CV_VAR_HANDLER, /* 2297 */
    ZEND_NULL_HANDLER, /* 2298 */
    ZEND_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER, /* 2299 */
    ZEND_FETCH_FUNC_ARG_SPEC_CONST_CONST_HANDLER, /* 2300 */
    ZEND_NULL_HANDLER, /* 2301 */
    ZEND_FETCH_FUNC_ARG_SPEC_CONST_VAR_HANDLER, /* 2302 */
    ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER, /* 2303 */
    ZEND_NULL_HANDLER, /* 2304 */
    ZEND_FETCH_FUNC_ARG_SPEC_TMP_CONST_HANDLER, /* 2305 */
    ZEND_NULL_HANDLER, /* 2306 */
    ZEND_FETCH_FUNC_ARG_SPEC_TMP_VAR_HANDLER, /* 2307 */
    ZEND_FETCH_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER, /* 2308 */
    ZEND_NULL_HANDLER, /* 2309 */
    ZEND_FETCH_FUNC_ARG_SPEC_VAR_CONST_HANDLER, /* 2310 */
    ZEND_NULL_HANDLER, /* 2311 */
    ZEND_FETCH_FUNC_ARG_SPEC_VAR_VAR_HANDLER, /* 2312 */
    ZEND_FETCH_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER, /* 2313 */
    ZEND_NULL_HANDLER, /* 2314 */
    ZEND_NULL_HANDLER, /* 2315 */
    ZEND_NULL_HANDLER, /* 2316 */
    ZEND_NULL_HANDLER, /* 2317 */
    ZEND_NULL_HANDLER, /* 2318 */
    ZEND_NULL_HANDLER, /* 2319 */
    ZEND_FETCH_FUNC_ARG_SPEC_CV_CONST_HANDLER, /* 2320 */
    ZEND_NULL_HANDLER, /* 2321 */
    ZEND_FETCH_FUNC_ARG_SPEC_CV_VAR_HANDLER, /* 2322 */
    ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER, /* 2323 */
    ZEND_NULL_HANDLER, /* 2324 */
    ZEND_NULL_HANDLER, /* 2325 */
    ZEND_NULL_HANDLER, /* 2326 */
    ZEND_NULL_HANDLER, /* 2327 */
    ZEND_NULL_HANDLER, /* 2328 */
    ZEND_NULL_HANDLER, /* 2329 */
    ZEND_NULL_HANDLER, /* 2330 */
    ZEND_NULL_HANDLER, /* 2331 */
    ZEND_NULL_HANDLER, /* 2332 */
    ZEND_NULL_HANDLER, /* 2333 */
    ZEND_NULL_HANDLER, /* 2334 */
    ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER, /* 2335 */
    ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMP_HANDLER, /* 2336 */
    ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_VAR_HANDLER, /* 2337 */
    ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER, /* 2338 */
    ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER, /* 2339 */
    ZEND_NULL_HANDLER, /* 2340 */
    ZEND_NULL_HANDLER, /* 2341 */
    ZEND_NULL_HANDLER, /* 2342 */
    ZEND_NULL_HANDLER, /* 2343 */
    ZEND_NULL_HANDLER, /* 2344 */
    ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER, /* 2345 */
    ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMP_HANDLER, /* 2346 */
    ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_VAR_HANDLER, /* 2347 */
    ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER, /* 2348 */
    ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER, /* 2349 */
    ZEND_NULL_HANDLER, /* 2350 */
    ZEND_NULL_HANDLER, /* 2351 */
    ZEND_NULL_HANDLER, /* 2352 */
    ZEND_NULL_HANDLER, /* 2353 */
    ZEND_NULL_HANDLER, /* 2354 */
    ZEND_NULL_HANDLER, /* 2355 */
    ZEND_NULL_HANDLER, /* 2356 */
    ZEND_NULL_HANDLER, /* 2357 */
    ZEND_NULL_HANDLER, /* 2358 */
    ZEND_NULL_HANDLER, /* 2359 */
    ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER, /* 2360 */
    ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMP_HANDLER, /* 2361 */
    ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_VAR_HANDLER, /* 2362 */
    ZEND_NULL_HANDLER, /* 2363 */
    ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER, /* 2364 */
    ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER, /* 2365 */
    ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMP_HANDLER, /* 2366 */
    ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_VAR_HANDLER, /* 2367 */
    ZEND_NULL_HANDLER, /* 2368 */
    ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER, /* 2369 */
    ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER, /* 2370 */
    ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMP_HANDLER, /* 2371 */
    ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_VAR_HANDLER, /* 2372 */
    ZEND_NULL_HANDLER, /* 2373 */
    ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER, /* 2374 */
    ZEND_FETCH_UNSET_SPEC_CONST_CONST_HANDLER, /* 2375 */
    ZEND_NULL_HANDLER, /* 2376 */
    ZEND_FETCH_UNSET_SPEC_CONST_VAR_HANDLER, /* 2377 */
    ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER, /* 2378 */
    ZEND_NULL_HANDLER, /* 2379 */
    ZEND_FETCH_UNSET_SPEC_TMP_CONST_HANDLER, /* 2380 */
    ZEND_NULL_HANDLER, /* 2381 */
    ZEND_FETCH_UNSET_SPEC_TMP_VAR_HANDLER, /* 2382 */
    ZEND_FETCH_UNSET_SPEC_TMP_UNUSED_HANDLER, /* 2383 */
    ZEND_NULL_HANDLER, /* 2384 */
    ZEND_FETCH_UNSET_SPEC_VAR_CONST_HANDLER, /* 2385 */
    ZEND_NULL_HANDLER, /* 2386 */
    ZEND_FETCH_UNSET_SPEC_VAR_VAR_HANDLER, /* 2387 */
    ZEND_FETCH_UNSET_SPEC_VAR_UNUSED_HANDLER, /* 2388 */
    ZEND_NULL_HANDLER, /* 2389 */
    ZEND_NULL_HANDLER, /* 2390 */
    ZEND_NULL_HANDLER, /* 2391 */
    ZEND_NULL_HANDLER, /* 2392 */
    ZEND_NULL_HANDLER, /* 2393 */
    ZEND_NULL_HANDLER, /* 2394 */
    ZEND_FETCH_UNSET_SPEC_CV_CONST_HANDLER, /* 2395 */
    ZEND_NULL_HANDLER, /* 2396 */
    ZEND_FETCH_UNSET_SPEC_CV_VAR_HANDLER, /* 2397 */
    ZEND_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER, /* 2398 */
    ZEND_NULL_HANDLER, /* 2399 */
    ZEND_NULL_HANDLER, /* 2400 */
    ZEND_NULL_HANDLER, /* 2401 */
    ZEND_NULL_HANDLER, /* 2402 */
    ZEND_NULL_HANDLER, /* 2403 */
    ZEND_NULL_HANDLER, /* 2404 */
    ZEND_NULL_HANDLER, /* 2405 */
    ZEND_NULL_HANDLER, /* 2406 */
    ZEND_NULL_HANDLER, /* 2407 */
    ZEND_NULL_HANDLER, /* 2408 */
    ZEND_NULL_HANDLER, /* 2409 */
    ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER, /* 2410 */
    ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMP_HANDLER, /* 2411 */
    ZEND_FETCH_DIM_UNSET_SPEC_VAR_VAR_HANDLER, /* 2412 */
    ZEND_NULL_HANDLER, /* 2413 */
    ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER, /* 2414 */
    ZEND_NULL_HANDLER, /* 2415 */
    ZEND_NULL_HANDLER, /* 2416 */
    ZEND_NULL_HANDLER, /* 2417 */
    ZEND_NULL_HANDLER, /* 2418 */
    ZEND_NULL_HANDLER, /* 2419 */
    ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER, /* 2420 */
    ZEND_FETCH_DIM_UNSET_SPEC_CV_TMP_HANDLER, /* 2421 */
    ZEND_FETCH_DIM_UNSET_SPEC_CV_VAR_HANDLER, /* 2422 */
    ZEND_NULL_HANDLER, /* 2423 */
    ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER, /* 2424 */
    ZEND_NULL_HANDLER, /* 2425 */
    ZEND_NULL_HANDLER, /* 2426 */
    ZEND_NULL_HANDLER, /* 2427 */
    ZEND_NULL_HANDLER, /* 2428 */
    ZEND_NULL_HANDLER, /* 2429 */
    ZEND_NULL_HANDLER, /* 2430 */
    ZEND_NULL_HANDLER, /* 2431 */
    ZEND_NULL_HANDLER, /* 2432 */
    ZEND_NULL_HANDLER, /* 2433 */
    ZEND_NULL_HANDLER, /* 2434 */
    ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER, /* 2435 */
    ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMP_HANDLER, /* 2436 */
    ZEND_FETCH_OBJ_UNSET_SPEC_VAR_VAR_HANDLER, /* 2437 */
    ZEND_NULL_HANDLER, /* 2438 */
    ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER, /* 2439 */
    ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER, /* 2440 */
    ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMP_HANDLER, /* 2441 */
    ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_VAR_HANDLER, /* 2442 */
    ZEND_NULL_HANDLER, /* 2443 */
    ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER, /* 2444 */
    ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER, /* 2445 */
    ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMP_HANDLER, /* 2446 */
    ZEND_FETCH_OBJ_UNSET_SPEC_CV_VAR_HANDLER, /* 2447 */
    ZEND_NULL_HANDLER, /* 2448 */
    ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER, /* 2449 */
    ZEND_FETCH_DIM_TMP_VAR_SPEC_CONST_CONST_HANDLER, /* 2450 */
    ZEND_NULL_HANDLER, /* 2451 */
    ZEND_NULL_HANDLER, /* 2452 */
    ZEND_NULL_HANDLER, /* 2453 */
    ZEND_NULL_HANDLER, /* 2454 */
    ZEND_FETCH_DIM_TMP_VAR_SPEC_TMP_CONST_HANDLER, /* 2455 */
    ZEND_NULL_HANDLER, /* 2456 */
    ZEND_NULL_HANDLER, /* 2457 */
    ZEND_NULL_HANDLER, /* 2458 */
    ZEND_NULL_HANDLER, /* 2459 */
    ZEND_NULL_HANDLER, /* 2460 */
    ZEND_NULL_HANDLER, /* 2461 */
    ZEND_NULL_HANDLER, /* 2462 */
    ZEND_NULL_HANDLER, /* 2463 */
    ZEND_NULL_HANDLER, /* 2464 */
    ZEND_NULL_HANDLER, /* 2465 */
    ZEND_NULL_HANDLER, /* 2466 */
    ZEND_NULL_HANDLER, /* 2467 */
    ZEND_NULL_HANDLER, /* 2468 */
    ZEND_NULL_HANDLER, /* 2469 */
    ZEND_NULL_HANDLER, /* 2470 */
    ZEND_NULL_HANDLER, /* 2471 */
    ZEND_NULL_HANDLER, /* 2472 */
    ZEND_NULL_HANDLER, /* 2473 */
    ZEND_NULL_HANDLER, /* 2474 */
    ZEND_FETCH_CONSTANT_SPEC_CONST_CONST_HANDLER, /* 2475 */
    ZEND_NULL_HANDLER, /* 2476 */
    ZEND_NULL_HANDLER, /* 2477 */
    ZEND_NULL_HANDLER, /* 2478 */
    ZEND_NULL_HANDLER, /* 2479 */
    ZEND_NULL_HANDLER, /* 2480 */
    ZEND_NULL_HANDLER, /* 2481 */
    ZEND_NULL_HANDLER, /* 2482 */
    ZEND_NULL_HANDLER, /* 2483 */
    ZEND_NULL_HANDLER, /* 2484 */
    ZEND_FETCH_CONSTANT_SPEC_VAR_CONST_HANDLER, /* 2485 */
    ZEND_NULL_HANDLER, /* 2486 */
    ZEND_NULL_HANDLER, /* 2487 */
    ZEND_NULL_HANDLER, /* 2488 */
    ZEND_NULL_HANDLER, /* 2489 */
    ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER, /* 2490 */
    ZEND_NULL_HANDLER, /* 2491 */
    ZEND_NULL_HANDLER, /* 2492 */
    ZEND_NULL_HANDLER, /* 2493 */
    ZEND_NULL_HANDLER, /* 2494 */
    ZEND_NULL_HANDLER, /* 2495 */
    ZEND_NULL_HANDLER, /* 2496 */
    ZEND_NULL_HANDLER, /* 2497 */
    ZEND_NULL_HANDLER, /* 2498 */
    ZEND_NULL_HANDLER, /* 2499 */
    ZEND_GOTO_SPEC_CONST_HANDLER, /* 2500 */
    ZEND_NULL_HANDLER, /* 2501 */
    ZEND_NULL_HANDLER, /* 2502 */
    ZEND_NULL_HANDLER, /* 2503 */
    ZEND_NULL_HANDLER, /* 2504 */
    ZEND_GOTO_SPEC_CONST_HANDLER, /* 2505 */
    ZEND_NULL_HANDLER, /* 2506 */
    ZEND_NULL_HANDLER, /* 2507 */
    ZEND_NULL_HANDLER, /* 2508 */
    ZEND_NULL_HANDLER, /* 2509 */
    ZEND_GOTO_SPEC_CONST_HANDLER, /* 2510 */
    ZEND_NULL_HANDLER, /* 2511 */
    ZEND_NULL_HANDLER, /* 2512 */
    ZEND_NULL_HANDLER, /* 2513 */
    ZEND_NULL_HANDLER, /* 2514 */
    ZEND_GOTO_SPEC_CONST_HANDLER, /* 2515 */
    ZEND_NULL_HANDLER, /* 2516 */
    ZEND_NULL_HANDLER, /* 2517 */
    ZEND_NULL_HANDLER, /* 2518 */
    ZEND_NULL_HANDLER, /* 2519 */
    ZEND_GOTO_SPEC_CONST_HANDLER, /* 2520 */
    ZEND_NULL_HANDLER, /* 2521 */
    ZEND_NULL_HANDLER, /* 2522 */
    ZEND_NULL_HANDLER, /* 2523 */
    ZEND_NULL_HANDLER, /* 2524 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2525 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2526 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2527 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2528 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2529 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2530 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2531 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2532 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2533 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2534 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2535 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2536 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2537 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2538 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2539 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2540 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2541 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2542 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2543 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2544 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2545 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2546 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2547 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2548 */
    ZEND_EXT_STMT_SPEC_HANDLER, /* 2549 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2550 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2551 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2552 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2553 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2554 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2555 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2556 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2557 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2558 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2559 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2560 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2561 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2562 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2563 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2564 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2565 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2566 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2567 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2568 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2569 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2570 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2571 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2572 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2573 */
    ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER, /* 2574 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2575 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2576 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2577 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2578 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2579 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2580 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2581 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2582 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2583 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2584 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2585 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2586 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2587 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2588 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2589 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2590 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2591 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2592 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2593 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2594 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2595 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2596 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2597 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2598 */
    ZEND_EXT_FCALL_END_SPEC_HANDLER, /* 2599 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2600 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2601 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2602 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2603 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2604 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2605 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2606 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2607 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2608 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2609 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2610 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2611 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2612 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2613 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2614 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2615 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2616 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2617 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2618 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2619 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2620 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2621 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2622 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2623 */
    ZEND_EXT_NOP_SPEC_HANDLER, /* 2624 */
    ZEND_TICKS_SPEC_HANDLER, /* 2625 */
    ZEND_TICKS_SPEC_HANDLER, /* 2626 */
    ZEND_TICKS_SPEC_HANDLER, /* 2627 */
    ZEND_TICKS_SPEC_HANDLER, /* 2628 */
    ZEND_TICKS_SPEC_HANDLER, /* 2629 */
    ZEND_TICKS_SPEC_HANDLER, /* 2630 */
    ZEND_TICKS_SPEC_HANDLER, /* 2631 */
    ZEND_TICKS_SPEC_HANDLER, /* 2632 */
    ZEND_TICKS_SPEC_HANDLER, /* 2633 */
    ZEND_TICKS_SPEC_HANDLER, /* 2634 */
    ZEND_TICKS_SPEC_HANDLER, /* 2635 */
    ZEND_TICKS_SPEC_HANDLER, /* 2636 */
    ZEND_TICKS_SPEC_HANDLER, /* 2637 */
    ZEND_TICKS_SPEC_HANDLER, /* 2638 */
    ZEND_TICKS_SPEC_HANDLER, /* 2639 */
    ZEND_TICKS_SPEC_HANDLER, /* 2640 */
    ZEND_TICKS_SPEC_HANDLER, /* 2641 */
    ZEND_TICKS_SPEC_HANDLER, /* 2642 */
    ZEND_TICKS_SPEC_HANDLER, /* 2643 */
    ZEND_TICKS_SPEC_HANDLER, /* 2644 */
    ZEND_TICKS_SPEC_HANDLER, /* 2645 */
    ZEND_TICKS_SPEC_HANDLER, /* 2646 */
    ZEND_TICKS_SPEC_HANDLER, /* 2647 */
    ZEND_TICKS_SPEC_HANDLER, /* 2648 */
    ZEND_TICKS_SPEC_HANDLER, /* 2649 */
    ZEND_NULL_HANDLER, /* 2650 */
    ZEND_NULL_HANDLER, /* 2651 */
    ZEND_NULL_HANDLER, /* 2652 */
    ZEND_NULL_HANDLER, /* 2653 */
    ZEND_NULL_HANDLER, /* 2654 */
    ZEND_NULL_HANDLER, /* 2655 */
    ZEND_NULL_HANDLER, /* 2656 */
    ZEND_NULL_HANDLER, /* 2657 */
    ZEND_NULL_HANDLER, /* 2658 */
    ZEND_NULL_HANDLER, /* 2659 */
    ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER, /* 2660 */
    ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER, /* 2661 */
    ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER, /* 2662 */
    ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER, /* 2663 */
    ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER, /* 2664 */
    ZEND_NULL_HANDLER, /* 2665 */
    ZEND_NULL_HANDLER, /* 2666 */
    ZEND_NULL_HANDLER, /* 2667 */
    ZEND_NULL_HANDLER, /* 2668 */
    ZEND_NULL_HANDLER, /* 2669 */
    ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER, /* 2670 */
    ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER, /* 2671 */
    ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER, /* 2672 */
    ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER, /* 2673 */
    ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER, /* 2674 */
    ZEND_NULL_HANDLER, /* 2675 */
    ZEND_NULL_HANDLER, /* 2676 */
    ZEND_NULL_HANDLER, /* 2677 */
    ZEND_NULL_HANDLER, /* 2678 */
    ZEND_CATCH_SPEC_CONST_CV_HANDLER, /* 2679 */
    ZEND_NULL_HANDLER, /* 2680 */
    ZEND_NULL_HANDLER, /* 2681 */
    ZEND_NULL_HANDLER, /* 2682 */
    ZEND_NULL_HANDLER, /* 2683 */
    ZEND_NULL_HANDLER, /* 2684 */
    ZEND_NULL_HANDLER, /* 2685 */
    ZEND_NULL_HANDLER, /* 2686 */
    ZEND_NULL_HANDLER, /* 2687 */
    ZEND_NULL_HANDLER, /* 2688 */
    ZEND_NULL_HANDLER, /* 2689 */
    ZEND_NULL_HANDLER, /* 2690 */
    ZEND_NULL_HANDLER, /* 2691 */
    ZEND_NULL_HANDLER, /* 2692 */
    ZEND_NULL_HANDLER, /* 2693 */
    ZEND_NULL_HANDLER, /* 2694 */
    ZEND_NULL_HANDLER, /* 2695 */
    ZEND_NULL_HANDLER, /* 2696 */
    ZEND_NULL_HANDLER, /* 2697 */
    ZEND_NULL_HANDLER, /* 2698 */
    ZEND_NULL_HANDLER, /* 2699 */
    ZEND_THROW_SPEC_CONST_HANDLER, /* 2700 */
    ZEND_THROW_SPEC_CONST_HANDLER, /* 2701 */
    ZEND_THROW_SPEC_CONST_HANDLER, /* 2702 */
    ZEND_THROW_SPEC_CONST_HANDLER, /* 2703 */
    ZEND_THROW_SPEC_CONST_HANDLER, /* 2704 */
    ZEND_THROW_SPEC_TMP_HANDLER, /* 2705 */
    ZEND_THROW_SPEC_TMP_HANDLER, /* 2706 */
    ZEND_THROW_SPEC_TMP_HANDLER, /* 2707 */
    ZEND_THROW_SPEC_TMP_HANDLER, /* 2708 */
    ZEND_THROW_SPEC_TMP_HANDLER, /* 2709 */
    ZEND_THROW_SPEC_VAR_HANDLER, /* 2710 */
    ZEND_THROW_SPEC_VAR_HANDLER, /* 2711 */
    ZEND_THROW_SPEC_VAR_HANDLER, /* 2712 */
    ZEND_THROW_SPEC_VAR_HANDLER, /* 2713 */
    ZEND_THROW_SPEC_VAR_HANDLER, /* 2714 */
    ZEND_NULL_HANDLER, /* 2715 */
    ZEND_NULL_HANDLER, /* 2716 */
    ZEND_NULL_HANDLER, /* 2717 */
    ZEND_NULL_HANDLER, /* 2718 */
    ZEND_NULL_HANDLER, /* 2719 */
    ZEND_THROW_SPEC_CV_HANDLER, /* 2720 */
    ZEND_THROW_SPEC_CV_HANDLER, /* 2721 */
    ZEND_THROW_SPEC_CV_HANDLER, /* 2722 */
    ZEND_THROW_SPEC_CV_HANDLER, /* 2723 */
    ZEND_THROW_SPEC_CV_HANDLER, /* 2724 */
    ZEND_FETCH_CLASS_SPEC_CONST_HANDLER, /* 2725 */
    ZEND_FETCH_CLASS_SPEC_TMP_HANDLER, /* 2726 */
    ZEND_FETCH_CLASS_SPEC_VAR_HANDLER, /* 2727 */
    ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER, /* 2728 */
    ZEND_FETCH_CLASS_SPEC_CV_HANDLER, /* 2729 */
    ZEND_FETCH_CLASS_SPEC_CONST_HANDLER, /* 2730 */
    ZEND_FETCH_CLASS_SPEC_TMP_HANDLER, /* 2731 */
    ZEND_FETCH_CLASS_SPEC_VAR_HANDLER, /* 2732 */
    ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER, /* 2733 */
    ZEND_FETCH_CLASS_SPEC_CV_HANDLER, /* 2734 */
    ZEND_FETCH_CLASS_SPEC_CONST_HANDLER, /* 2735 */
    ZEND_FETCH_CLASS_SPEC_TMP_HANDLER, /* 2736 */
    ZEND_FETCH_CLASS_SPEC_VAR_HANDLER, /* 2737 */
    ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER, /* 2738 */
    ZEND_FETCH_CLASS_SPEC_CV_HANDLER, /* 2739 */
    ZEND_FETCH_CLASS_SPEC_CONST_HANDLER, /* 2740 */
    ZEND_FETCH_CLASS_SPEC_TMP_HANDLER, /* 2741 */
    ZEND_FETCH_CLASS_SPEC_VAR_HANDLER, /* 2742 */
    ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER, /* 2743 */
    ZEND_FETCH_CLASS_SPEC_CV_HANDLER, /* 2744 */
    ZEND_FETCH_CLASS_SPEC_CONST_HANDLER, /* 2745 */
    ZEND_FETCH_CLASS_SPEC_TMP_HANDLER, /* 2746 */
    ZEND_FETCH_CLASS_SPEC_VAR_HANDLER, /* 2747 */
    ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER, /* 2748 */
    ZEND_FETCH_CLASS_SPEC_CV_HANDLER, /* 2749 */
    ZEND_CLONE_SPEC_CONST_HANDLER, /* 2750 */
    ZEND_CLONE_SPEC_CONST_HANDLER, /* 2751 */
    ZEND_CLONE_SPEC_CONST_HANDLER, /* 2752 */
    ZEND_CLONE_SPEC_CONST_HANDLER, /* 2753 */
    ZEND_CLONE_SPEC_CONST_HANDLER, /* 2754 */
    ZEND_CLONE_SPEC_TMP_HANDLER, /* 2755 */
    ZEND_CLONE_SPEC_TMP_HANDLER, /* 2756 */
    ZEND_CLONE_SPEC_TMP_HANDLER, /* 2757 */
    ZEND_CLONE_SPEC_TMP_HANDLER, /* 2758 */
    ZEND_CLONE_SPEC_TMP_HANDLER, /* 2759 */
    ZEND_CLONE_SPEC_VAR_HANDLER, /* 2760 */
    ZEND_CLONE_SPEC_VAR_HANDLER, /* 2761 */
    ZEND_CLONE_SPEC_VAR_HANDLER, /* 2762 */
    ZEND_CLONE_SPEC_VAR_HANDLER, /* 2763 */
    ZEND_CLONE_SPEC_VAR_HANDLER, /* 2764 */
    ZEND_CLONE_SPEC_UNUSED_HANDLER, /* 2765 */
    ZEND_CLONE_SPEC_UNUSED_HANDLER, /* 2766 */
    ZEND_CLONE_SPEC_UNUSED_HANDLER, /* 2767 */
    ZEND_CLONE_SPEC_UNUSED_HANDLER, /* 2768 */
    ZEND_CLONE_SPEC_UNUSED_HANDLER, /* 2769 */
    ZEND_CLONE_SPEC_CV_HANDLER, /* 2770 */
    ZEND_CLONE_SPEC_CV_HANDLER, /* 2771 */
    ZEND_CLONE_SPEC_CV_HANDLER, /* 2772 */
    ZEND_CLONE_SPEC_CV_HANDLER, /* 2773 */
    ZEND_CLONE_SPEC_CV_HANDLER, /* 2774 */
    ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER, /* 2775 */
    ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER, /* 2776 */
    ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER, /* 2777 */
    ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER, /* 2778 */
    ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER, /* 2779 */
    ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER, /* 2780 */
    ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER, /* 2781 */
    ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER, /* 2782 */
    ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER, /* 2783 */
    ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER, /* 2784 */
    ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER, /* 2785 */
    ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER, /* 2786 */
    ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER, /* 2787 */
    ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER, /* 2788 */
    ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER, /* 2789 */
    ZEND_NULL_HANDLER, /* 2790 */
    ZEND_NULL_HANDLER, /* 2791 */
    ZEND_NULL_HANDLER, /* 2792 */
    ZEND_NULL_HANDLER, /* 2793 */
    ZEND_NULL_HANDLER, /* 2794 */
    ZEND_RETURN_BY_REF_SPEC_CV_HANDLER, /* 2795 */
    ZEND_RETURN_BY_REF_SPEC_CV_HANDLER, /* 2796 */
    ZEND_RETURN_BY_REF_SPEC_CV_HANDLER, /* 2797 */
    ZEND_RETURN_BY_REF_SPEC_CV_HANDLER, /* 2798 */
    ZEND_RETURN_BY_REF_SPEC_CV_HANDLER, /* 2799 */
    ZEND_NULL_HANDLER, /* 2800 */
    ZEND_NULL_HANDLER, /* 2801 */
    ZEND_NULL_HANDLER, /* 2802 */
    ZEND_NULL_HANDLER, /* 2803 */
    ZEND_NULL_HANDLER, /* 2804 */
    ZEND_INIT_METHOD_CALL_SPEC_TMP_CONST_HANDLER, /* 2805 */
    ZEND_INIT_METHOD_CALL_SPEC_TMP_TMP_HANDLER, /* 2806 */
    ZEND_INIT_METHOD_CALL_SPEC_TMP_VAR_HANDLER, /* 2807 */
    ZEND_NULL_HANDLER, /* 2808 */
    ZEND_INIT_METHOD_CALL_SPEC_TMP_CV_HANDLER, /* 2809 */
    ZEND_INIT_METHOD_CALL_SPEC_VAR_CONST_HANDLER, /* 2810 */
    ZEND_INIT_METHOD_CALL_SPEC_VAR_TMP_HANDLER, /* 2811 */
    ZEND_INIT_METHOD_CALL_SPEC_VAR_VAR_HANDLER, /* 2812 */
    ZEND_NULL_HANDLER, /* 2813 */
    ZEND_INIT_METHOD_CALL_SPEC_VAR_CV_HANDLER, /* 2814 */
    ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER, /* 2815 */
    ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMP_HANDLER, /* 2816 */
    ZEND_INIT_METHOD_CALL_SPEC_UNUSED_VAR_HANDLER, /* 2817 */
    ZEND_NULL_HANDLER, /* 2818 */
    ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER, /* 2819 */
    ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER, /* 2820 */
    ZEND_INIT_METHOD_CALL_SPEC_CV_TMP_HANDLER, /* 2821 */
    ZEND_INIT_METHOD_CALL_SPEC_CV_VAR_HANDLER, /* 2822 */
    ZEND_NULL_HANDLER, /* 2823 */
    ZEND_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER, /* 2824 */
    ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER, /* 2825 */
    ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMP_HANDLER, /* 2826 */
    ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_VAR_HANDLER, /* 2827 */
    ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER, /* 2828 */
    ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER, /* 2829 */
    ZEND_NULL_HANDLER, /* 2830 */
    ZEND_NULL_HANDLER, /* 2831 */
    ZEND_NULL_HANDLER, /* 2832 */
    ZEND_NULL_HANDLER, /* 2833 */
    ZEND_NULL_HANDLER, /* 2834 */
    ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER, /* 2835 */
    ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMP_HANDLER, /* 2836 */
    ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_VAR_HANDLER, /* 2837 */
    ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER, /* 2838 */
    ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER, /* 2839 */
    ZEND_NULL_HANDLER, /* 2840 */
    ZEND_NULL_HANDLER, /* 2841 */
    ZEND_NULL_HANDLER, /* 2842 */
    ZEND_NULL_HANDLER, /* 2843 */
    ZEND_NULL_HANDLER, /* 2844 */
    ZEND_NULL_HANDLER, /* 2845 */
    ZEND_NULL_HANDLER, /* 2846 */
    ZEND_NULL_HANDLER, /* 2847 */
    ZEND_NULL_HANDLER, /* 2848 */
    ZEND_NULL_HANDLER, /* 2849 */
    ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_CONST_HANDLER, /* 2850 */
    ZEND_NULL_HANDLER, /* 2851 */
    ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_VAR_HANDLER, /* 2852 */
    ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER, /* 2853 */
    ZEND_NULL_HANDLER, /* 2854 */
    ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_CONST_HANDLER, /* 2855 */
    ZEND_NULL_HANDLER, /* 2856 */
    ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_VAR_HANDLER, /* 2857 */
    ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_UNUSED_HANDLER, /* 2858 */
    ZEND_NULL_HANDLER, /* 2859 */
    ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_CONST_HANDLER, /* 2860 */
    ZEND_NULL_HANDLER, /* 2861 */
    ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_VAR_HANDLER, /* 2862 */
    ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_UNUSED_HANDLER, /* 2863 */
    ZEND_NULL_HANDLER, /* 2864 */
    ZEND_NULL_HANDLER, /* 2865 */
    ZEND_NULL_HANDLER, /* 2866 */
    ZEND_NULL_HANDLER, /* 2867 */
    ZEND_NULL_HANDLER, /* 2868 */
    ZEND_NULL_HANDLER, /* 2869 */
    ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_CONST_HANDLER, /* 2870 */
    ZEND_NULL_HANDLER, /* 2871 */
    ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_VAR_HANDLER, /* 2872 */
    ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER, /* 2873 */
    ZEND_NULL_HANDLER, /* 2874 */
    ZEND_NULL_HANDLER, /* 2875 */
    ZEND_NULL_HANDLER, /* 2876 */
    ZEND_NULL_HANDLER, /* 2877 */
    ZEND_NULL_HANDLER, /* 2878 */
    ZEND_NULL_HANDLER, /* 2879 */
    ZEND_NULL_HANDLER, /* 2880 */
    ZEND_NULL_HANDLER, /* 2881 */
    ZEND_NULL_HANDLER, /* 2882 */
    ZEND_NULL_HANDLER, /* 2883 */
    ZEND_NULL_HANDLER, /* 2884 */
    ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CONST_HANDLER, /* 2885 */
    ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_TMP_HANDLER, /* 2886 */
    ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_VAR_HANDLER, /* 2887 */
    ZEND_NULL_HANDLER, /* 2888 */
    ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CV_HANDLER, /* 2889 */
    ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CONST_HANDLER, /* 2890 */
    ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_TMP_HANDLER, /* 2891 */
    ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_VAR_HANDLER, /* 2892 */
    ZEND_NULL_HANDLER, /* 2893 */
    ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CV_HANDLER, /* 2894 */
    ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER, /* 2895 */
    ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMP_HANDLER, /* 2896 */
    ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_VAR_HANDLER, /* 2897 */
    ZEND_NULL_HANDLER, /* 2898 */
    ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER, /* 2899 */
    ZEND_NULL_HANDLER, /* 2900 */
    ZEND_NULL_HANDLER, /* 2901 */
    ZEND_NULL_HANDLER, /* 2902 */
    ZEND_NULL_HANDLER, /* 2903 */
    ZEND_NULL_HANDLER, /* 2904 */
    ZEND_NULL_HANDLER, /* 2905 */
    ZEND_NULL_HANDLER, /* 2906 */
    ZEND_NULL_HANDLER, /* 2907 */
    ZEND_NULL_HANDLER, /* 2908 */
    ZEND_NULL_HANDLER, /* 2909 */
    ZEND_NULL_HANDLER, /* 2910 */
    ZEND_NULL_HANDLER, /* 2911 */
    ZEND_NULL_HANDLER, /* 2912 */
    ZEND_NULL_HANDLER, /* 2913 */
    ZEND_NULL_HANDLER, /* 2914 */
    ZEND_NULL_HANDLER, /* 2915 */
    ZEND_NULL_HANDLER, /* 2916 */
    ZEND_NULL_HANDLER, /* 2917 */
    ZEND_NULL_HANDLER, /* 2918 */
    ZEND_NULL_HANDLER, /* 2919 */
    ZEND_NULL_HANDLER, /* 2920 */
    ZEND_NULL_HANDLER, /* 2921 */
    ZEND_NULL_HANDLER, /* 2922 */
    ZEND_NULL_HANDLER, /* 2923 */
    ZEND_NULL_HANDLER, /* 2924 */
    ZEND_NULL_HANDLER, /* 2925 */
    ZEND_NULL_HANDLER, /* 2926 */
    ZEND_NULL_HANDLER, /* 2927 */
    ZEND_NULL_HANDLER, /* 2928 */
    ZEND_NULL_HANDLER, /* 2929 */
    ZEND_NULL_HANDLER, /* 2930 */
    ZEND_NULL_HANDLER, /* 2931 */
    ZEND_NULL_HANDLER, /* 2932 */
    ZEND_NULL_HANDLER, /* 2933 */
    ZEND_NULL_HANDLER, /* 2934 */
    ZEND_NULL_HANDLER, /* 2935 */
    ZEND_NULL_HANDLER, /* 2936 */
    ZEND_NULL_HANDLER, /* 2937 */
    ZEND_NULL_HANDLER, /* 2938 */
    ZEND_NULL_HANDLER, /* 2939 */
    ZEND_NULL_HANDLER, /* 2940 */
    ZEND_NULL_HANDLER, /* 2941 */
    ZEND_NULL_HANDLER, /* 2942 */
    ZEND_NULL_HANDLER, /* 2943 */
    ZEND_NULL_HANDLER, /* 2944 */
    ZEND_NULL_HANDLER, /* 2945 */
    ZEND_NULL_HANDLER, /* 2946 */
    ZEND_NULL_HANDLER, /* 2947 */
    ZEND_NULL_HANDLER, /* 2948 */
    ZEND_NULL_HANDLER, /* 2949 */
    ZEND_NULL_HANDLER, /* 2950 */
    ZEND_NULL_HANDLER, /* 2951 */
    ZEND_NULL_HANDLER, /* 2952 */
    ZEND_NULL_HANDLER, /* 2953 */
    ZEND_NULL_HANDLER, /* 2954 */
    ZEND_NULL_HANDLER, /* 2955 */
    ZEND_NULL_HANDLER, /* 2956 */
    ZEND_NULL_HANDLER, /* 2957 */
    ZEND_NULL_HANDLER, /* 2958 */
    ZEND_NULL_HANDLER, /* 2959 */
    ZEND_NULL_HANDLER, /* 2960 */
    ZEND_NULL_HANDLER, /* 2961 */
    ZEND_NULL_HANDLER, /* 2962 */
    ZEND_NULL_HANDLER, /* 2963 */
    ZEND_NULL_HANDLER, /* 2964 */
    ZEND_NULL_HANDLER, /* 2965 */
    ZEND_NULL_HANDLER, /* 2966 */
    ZEND_NULL_HANDLER, /* 2967 */
    ZEND_NULL_HANDLER, /* 2968 */
    ZEND_NULL_HANDLER, /* 2969 */
    ZEND_NULL_HANDLER, /* 2970 */
    ZEND_NULL_HANDLER, /* 2971 */
    ZEND_NULL_HANDLER, /* 2972 */
    ZEND_NULL_HANDLER, /* 2973 */
    ZEND_NULL_HANDLER, /* 2974 */
    ZEND_NULL_HANDLER, /* 2975 */
    ZEND_NULL_HANDLER, /* 2976 */
    ZEND_NULL_HANDLER, /* 2977 */
    ZEND_NULL_HANDLER, /* 2978 */
    ZEND_NULL_HANDLER, /* 2979 */
    ZEND_NULL_HANDLER, /* 2980 */
    ZEND_NULL_HANDLER, /* 2981 */
    ZEND_NULL_HANDLER, /* 2982 */
    ZEND_NULL_HANDLER, /* 2983 */
    ZEND_NULL_HANDLER, /* 2984 */
    ZEND_NULL_HANDLER, /* 2985 */
    ZEND_NULL_HANDLER, /* 2986 */
    ZEND_NULL_HANDLER, /* 2987 */
    ZEND_NULL_HANDLER, /* 2988 */
    ZEND_NULL_HANDLER, /* 2989 */
    ZEND_NULL_HANDLER, /* 2990 */
    ZEND_NULL_HANDLER, /* 2991 */
    ZEND_NULL_HANDLER, /* 2992 */
    ZEND_NULL_HANDLER, /* 2993 */
    ZEND_NULL_HANDLER, /* 2994 */
    ZEND_NULL_HANDLER, /* 2995 */
    ZEND_NULL_HANDLER, /* 2996 */
    ZEND_NULL_HANDLER, /* 2997 */
    ZEND_NULL_HANDLER, /* 2998 */
    ZEND_NULL_HANDLER, /* 2999 */
    ZEND_NULL_HANDLER, /* 3000 */
    ZEND_NULL_HANDLER, /* 3001 */
    ZEND_NULL_HANDLER, /* 3002 */
    ZEND_NULL_HANDLER, /* 3003 */
    ZEND_NULL_HANDLER, /* 3004 */
    ZEND_NULL_HANDLER, /* 3005 */
    ZEND_NULL_HANDLER, /* 3006 */
    ZEND_NULL_HANDLER, /* 3007 */
    ZEND_NULL_HANDLER, /* 3008 */
    ZEND_NULL_HANDLER, /* 3009 */
    ZEND_NULL_HANDLER, /* 3010 */
    ZEND_NULL_HANDLER, /* 3011 */
    ZEND_NULL_HANDLER, /* 3012 */
    ZEND_NULL_HANDLER, /* 3013 */
    ZEND_NULL_HANDLER, /* 3014 */
    ZEND_NULL_HANDLER, /* 3015 */
    ZEND_NULL_HANDLER, /* 3016 */
    ZEND_NULL_HANDLER, /* 3017 */
    ZEND_NULL_HANDLER, /* 3018 */
    ZEND_NULL_HANDLER, /* 3019 */
    ZEND_NULL_HANDLER, /* 3020 */
    ZEND_NULL_HANDLER, /* 3021 */
    ZEND_NULL_HANDLER, /* 3022 */
    ZEND_NULL_HANDLER, /* 3023 */
    ZEND_NULL_HANDLER, /* 3024 */
    ZEND_NULL_HANDLER, /* 3025 */
    ZEND_NULL_HANDLER, /* 3026 */
    ZEND_NULL_HANDLER, /* 3027 */
    ZEND_NULL_HANDLER, /* 3028 */
    ZEND_NULL_HANDLER, /* 3029 */
    ZEND_NULL_HANDLER, /* 3030 */
    ZEND_NULL_HANDLER, /* 3031 */
    ZEND_NULL_HANDLER, /* 3032 */
    ZEND_NULL_HANDLER, /* 3033 */
    ZEND_NULL_HANDLER, /* 3034 */
    ZEND_NULL_HANDLER, /* 3035 */
    ZEND_NULL_HANDLER, /* 3036 */
    ZEND_NULL_HANDLER, /* 3037 */
    ZEND_NULL_HANDLER, /* 3038 */
    ZEND_NULL_HANDLER, /* 3039 */
    ZEND_NULL_HANDLER, /* 3040 */
    ZEND_NULL_HANDLER, /* 3041 */
    ZEND_NULL_HANDLER, /* 3042 */
    ZEND_NULL_HANDLER, /* 3043 */
    ZEND_NULL_HANDLER, /* 3044 */
    ZEND_NULL_HANDLER, /* 3045 */
    ZEND_NULL_HANDLER, /* 3046 */
    ZEND_NULL_HANDLER, /* 3047 */
    ZEND_NULL_HANDLER, /* 3048 */
    ZEND_NULL_HANDLER, /* 3049 */
    ZEND_NULL_HANDLER, /* 3050 */
    ZEND_NULL_HANDLER, /* 3051 */
    ZEND_NULL_HANDLER, /* 3052 */
    ZEND_NULL_HANDLER, /* 3053 */
    ZEND_NULL_HANDLER, /* 3054 */
    ZEND_NULL_HANDLER, /* 3055 */
    ZEND_NULL_HANDLER, /* 3056 */
    ZEND_NULL_HANDLER, /* 3057 */
    ZEND_NULL_HANDLER, /* 3058 */
    ZEND_NULL_HANDLER, /* 3059 */
    ZEND_NULL_HANDLER, /* 3060 */
    ZEND_NULL_HANDLER, /* 3061 */
    ZEND_NULL_HANDLER, /* 3062 */
    ZEND_NULL_HANDLER, /* 3063 */
    ZEND_NULL_HANDLER, /* 3064 */
    ZEND_NULL_HANDLER, /* 3065 */
    ZEND_NULL_HANDLER, /* 3066 */
    ZEND_NULL_HANDLER, /* 3067 */
    ZEND_NULL_HANDLER, /* 3068 */
    ZEND_NULL_HANDLER, /* 3069 */
    ZEND_NULL_HANDLER, /* 3070 */
    ZEND_NULL_HANDLER, /* 3071 */
    ZEND_NULL_HANDLER, /* 3072 */
    ZEND_NULL_HANDLER, /* 3073 */
    ZEND_NULL_HANDLER, /* 3074 */
    ZEND_NULL_HANDLER, /* 3075 */
    ZEND_NULL_HANDLER, /* 3076 */
    ZEND_NULL_HANDLER, /* 3077 */
    ZEND_NULL_HANDLER, /* 3078 */
    ZEND_NULL_HANDLER, /* 3079 */
    ZEND_NULL_HANDLER, /* 3080 */
    ZEND_NULL_HANDLER, /* 3081 */
    ZEND_NULL_HANDLER, /* 3082 */
    ZEND_NULL_HANDLER, /* 3083 */
    ZEND_NULL_HANDLER, /* 3084 */
    ZEND_NULL_HANDLER, /* 3085 */
    ZEND_NULL_HANDLER, /* 3086 */
    ZEND_NULL_HANDLER, /* 3087 */
    ZEND_NULL_HANDLER, /* 3088 */
    ZEND_NULL_HANDLER, /* 3089 */
    ZEND_NULL_HANDLER, /* 3090 */
    ZEND_NULL_HANDLER, /* 3091 */
    ZEND_NULL_HANDLER, /* 3092 */
    ZEND_NULL_HANDLER, /* 3093 */
    ZEND_NULL_HANDLER, /* 3094 */
    ZEND_NULL_HANDLER, /* 3095 */
    ZEND_NULL_HANDLER, /* 3096 */
    ZEND_NULL_HANDLER, /* 3097 */
    ZEND_NULL_HANDLER, /* 3098 */
    ZEND_NULL_HANDLER, /* 3099 */
    ZEND_NULL_HANDLER, /* 3100 */
    ZEND_NULL_HANDLER, /* 3101 */
    ZEND_NULL_HANDLER, /* 3102 */
    ZEND_NULL_HANDLER, /* 3103 */
    ZEND_NULL_HANDLER, /* 3104 */
    ZEND_NULL_HANDLER, /* 3105 */
    ZEND_NULL_HANDLER, /* 3106 */
    ZEND_NULL_HANDLER, /* 3107 */
    ZEND_NULL_HANDLER, /* 3108 */
    ZEND_NULL_HANDLER, /* 3109 */
    ZEND_NULL_HANDLER, /* 3110 */
    ZEND_NULL_HANDLER, /* 3111 */
    ZEND_NULL_HANDLER, /* 3112 */
    ZEND_NULL_HANDLER, /* 3113 */
    ZEND_NULL_HANDLER, /* 3114 */
    ZEND_NULL_HANDLER, /* 3115 */
    ZEND_NULL_HANDLER, /* 3116 */
    ZEND_NULL_HANDLER, /* 3117 */
    ZEND_NULL_HANDLER, /* 3118 */
    ZEND_NULL_HANDLER, /* 3119 */
    ZEND_NULL_HANDLER, /* 3120 */
    ZEND_NULL_HANDLER, /* 3121 */
    ZEND_NULL_HANDLER, /* 3122 */
    ZEND_NULL_HANDLER, /* 3123 */
    ZEND_NULL_HANDLER, /* 3124 */
    ZEND_NULL_HANDLER, /* 3125 */
    ZEND_NULL_HANDLER, /* 3126 */
    ZEND_NULL_HANDLER, /* 3127 */
    ZEND_NULL_HANDLER, /* 3128 */
    ZEND_NULL_HANDLER, /* 3129 */
    ZEND_NULL_HANDLER, /* 3130 */
    ZEND_NULL_HANDLER, /* 3131 */
    ZEND_NULL_HANDLER, /* 3132 */
    ZEND_NULL_HANDLER, /* 3133 */
    ZEND_NULL_HANDLER, /* 3134 */
    ZEND_NULL_HANDLER, /* 3135 */
    ZEND_NULL_HANDLER, /* 3136 */
    ZEND_NULL_HANDLER, /* 3137 */
    ZEND_NULL_HANDLER, /* 3138 */
    ZEND_NULL_HANDLER, /* 3139 */
    ZEND_NULL_HANDLER, /* 3140 */
    ZEND_NULL_HANDLER, /* 3141 */
    ZEND_NULL_HANDLER, /* 3142 */
    ZEND_NULL_HANDLER, /* 3143 */
    ZEND_NULL_HANDLER, /* 3144 */
    ZEND_NULL_HANDLER, /* 3145 */
    ZEND_NULL_HANDLER, /* 3146 */
    ZEND_NULL_HANDLER, /* 3147 */
    ZEND_NULL_HANDLER, /* 3148 */
    ZEND_NULL_HANDLER, /* 3149 */
    ZEND_NULL_HANDLER, /* 3150 */
    ZEND_NULL_HANDLER, /* 3151 */
    ZEND_NULL_HANDLER, /* 3152 */
    ZEND_NULL_HANDLER, /* 3153 */
    ZEND_NULL_HANDLER, /* 3154 */
    ZEND_NULL_HANDLER, /* 3155 */
    ZEND_NULL_HANDLER, /* 3156 */
    ZEND_NULL_HANDLER, /* 3157 */
    ZEND_NULL_HANDLER, /* 3158 */
    ZEND_NULL_HANDLER, /* 3159 */
    ZEND_NULL_HANDLER, /* 3160 */
    ZEND_NULL_HANDLER, /* 3161 */
    ZEND_NULL_HANDLER, /* 3162 */
    ZEND_NULL_HANDLER, /* 3163 */
    ZEND_NULL_HANDLER, /* 3164 */
    ZEND_NULL_HANDLER, /* 3165 */
    ZEND_NULL_HANDLER, /* 3166 */
    ZEND_NULL_HANDLER, /* 3167 */
    ZEND_NULL_HANDLER, /* 3168 */
    ZEND_NULL_HANDLER, /* 3169 */
    ZEND_NULL_HANDLER, /* 3170 */
    ZEND_NULL_HANDLER, /* 3171 */
    ZEND_NULL_HANDLER, /* 3172 */
    ZEND_NULL_HANDLER, /* 3173 */
    ZEND_NULL_HANDLER, /* 3174 */
    ZEND_NULL_HANDLER, /* 3175 */
    ZEND_NULL_HANDLER, /* 3176 */
    ZEND_NULL_HANDLER, /* 3177 */
    ZEND_NULL_HANDLER, /* 3178 */
    ZEND_NULL_HANDLER, /* 3179 */
    ZEND_NULL_HANDLER, /* 3180 */
    ZEND_NULL_HANDLER, /* 3181 */
    ZEND_NULL_HANDLER, /* 3182 */
    ZEND_NULL_HANDLER, /* 3183 */
    ZEND_NULL_HANDLER, /* 3184 */
    ZEND_NULL_HANDLER, /* 3185 */
    ZEND_NULL_HANDLER, /* 3186 */
    ZEND_NULL_HANDLER, /* 3187 */
    ZEND_NULL_HANDLER, /* 3188 */
    ZEND_NULL_HANDLER, /* 3189 */
    ZEND_NULL_HANDLER, /* 3190 */
    ZEND_NULL_HANDLER, /* 3191 */
    ZEND_NULL_HANDLER, /* 3192 */
    ZEND_NULL_HANDLER, /* 3193 */
    ZEND_NULL_HANDLER, /* 3194 */
    ZEND_NULL_HANDLER, /* 3195 */
    ZEND_NULL_HANDLER, /* 3196 */
    ZEND_NULL_HANDLER, /* 3197 */
    ZEND_NULL_HANDLER, /* 3198 */
    ZEND_NULL_HANDLER, /* 3199 */
    ZEND_NULL_HANDLER, /* 3200 */
    ZEND_NULL_HANDLER, /* 3201 */
    ZEND_NULL_HANDLER, /* 3202 */
    ZEND_NULL_HANDLER, /* 3203 */
    ZEND_NULL_HANDLER, /* 3204 */
    ZEND_NULL_HANDLER, /* 3205 */
    ZEND_NULL_HANDLER, /* 3206 */
    ZEND_NULL_HANDLER, /* 3207 */
    ZEND_NULL_HANDLER, /* 3208 */
    ZEND_NULL_HANDLER, /* 3209 */
    ZEND_NULL_HANDLER, /* 3210 */
    ZEND_NULL_HANDLER, /* 3211 */
    ZEND_NULL_HANDLER, /* 3212 */
    ZEND_NULL_HANDLER, /* 3213 */
    ZEND_NULL_HANDLER, /* 3214 */
    ZEND_NULL_HANDLER, /* 3215 */
    ZEND_NULL_HANDLER, /* 3216 */
    ZEND_NULL_HANDLER, /* 3217 */
    ZEND_NULL_HANDLER, /* 3218 */
    ZEND_NULL_HANDLER, /* 3219 */
    ZEND_NULL_HANDLER, /* 3220 */
    ZEND_NULL_HANDLER, /* 3221 */
    ZEND_NULL_HANDLER, /* 3222 */
    ZEND_NULL_HANDLER, /* 3223 */
    ZEND_NULL_HANDLER, /* 3224 */
    ZEND_NULL_HANDLER, /* 3225 */
    ZEND_NULL_HANDLER, /* 3226 */
    ZEND_NULL_HANDLER, /* 3227 */
    ZEND_NULL_HANDLER, /* 3228 */
    ZEND_NULL_HANDLER, /* 3229 */
    ZEND_NULL_HANDLER, /* 3230 */
    ZEND_NULL_HANDLER, /* 3231 */
    ZEND_NULL_HANDLER, /* 3232 */
    ZEND_NULL_HANDLER, /* 3233 */
    ZEND_NULL_HANDLER, /* 3234 */
    ZEND_NULL_HANDLER, /* 3235 */
    ZEND_NULL_HANDLER, /* 3236 */
    ZEND_NULL_HANDLER, /* 3237 */
    ZEND_NULL_HANDLER, /* 3238 */
    ZEND_NULL_HANDLER, /* 3239 */
    ZEND_NULL_HANDLER, /* 3240 */
    ZEND_NULL_HANDLER, /* 3241 */
    ZEND_NULL_HANDLER, /* 3242 */
    ZEND_NULL_HANDLER, /* 3243 */
    ZEND_NULL_HANDLER, /* 3244 */
    ZEND_NULL_HANDLER, /* 3245 */
    ZEND_NULL_HANDLER, /* 3246 */
    ZEND_NULL_HANDLER, /* 3247 */
    ZEND_NULL_HANDLER, /* 3248 */
    ZEND_NULL_HANDLER, /* 3249 */
    ZEND_NULL_HANDLER, /* 3250 */
    ZEND_NULL_HANDLER, /* 3251 */
    ZEND_NULL_HANDLER, /* 3252 */
    ZEND_NULL_HANDLER, /* 3253 */
    ZEND_NULL_HANDLER, /* 3254 */
    ZEND_NULL_HANDLER, /* 3255 */
    ZEND_NULL_HANDLER, /* 3256 */
    ZEND_NULL_HANDLER, /* 3257 */
    ZEND_NULL_HANDLER, /* 3258 */
    ZEND_NULL_HANDLER, /* 3259 */
    ZEND_NULL_HANDLER, /* 3260 */
    ZEND_NULL_HANDLER, /* 3261 */
    ZEND_NULL_HANDLER, /* 3262 */
    ZEND_NULL_HANDLER, /* 3263 */
    ZEND_NULL_HANDLER, /* 3264 */
    ZEND_NULL_HANDLER, /* 3265 */
    ZEND_NULL_HANDLER, /* 3266 */
    ZEND_NULL_HANDLER, /* 3267 */
    ZEND_NULL_HANDLER, /* 3268 */
    ZEND_NULL_HANDLER, /* 3269 */
    ZEND_NULL_HANDLER, /* 3270 */
    ZEND_NULL_HANDLER, /* 3271 */
    ZEND_NULL_HANDLER, /* 3272 */
    ZEND_NULL_HANDLER, /* 3273 */
    ZEND_NULL_HANDLER, /* 3274 */
    ZEND_NULL_HANDLER, /* 3275 */
    ZEND_NULL_HANDLER, /* 3276 */
    ZEND_NULL_HANDLER, /* 3277 */
    ZEND_NULL_HANDLER, /* 3278 */
    ZEND_NULL_HANDLER, /* 3279 */
    ZEND_NULL_HANDLER, /* 3280 */
    ZEND_NULL_HANDLER, /* 3281 */
    ZEND_NULL_HANDLER, /* 3282 */
    ZEND_NULL_HANDLER, /* 3283 */
    ZEND_NULL_HANDLER, /* 3284 */
    ZEND_NULL_HANDLER, /* 3285 */
    ZEND_NULL_HANDLER, /* 3286 */
    ZEND_NULL_HANDLER, /* 3287 */
    ZEND_NULL_HANDLER, /* 3288 */
    ZEND_NULL_HANDLER, /* 3289 */
    ZEND_NULL_HANDLER, /* 3290 */
    ZEND_NULL_HANDLER, /* 3291 */
    ZEND_NULL_HANDLER, /* 3292 */
    ZEND_NULL_HANDLER, /* 3293 */
    ZEND_NULL_HANDLER, /* 3294 */
    ZEND_NULL_HANDLER, /* 3295 */
    ZEND_NULL_HANDLER, /* 3296 */
    ZEND_NULL_HANDLER, /* 3297 */
    ZEND_NULL_HANDLER, /* 3298 */
    ZEND_NULL_HANDLER, /* 3299 */
    ZEND_NULL_HANDLER, /* 3300 */
    ZEND_NULL_HANDLER, /* 3301 */
    ZEND_NULL_HANDLER, /* 3302 */
    ZEND_NULL_HANDLER, /* 3303 */
    ZEND_NULL_HANDLER, /* 3304 */
    ZEND_NULL_HANDLER, /* 3305 */
    ZEND_NULL_HANDLER, /* 3306 */
    ZEND_NULL_HANDLER, /* 3307 */
    ZEND_NULL_HANDLER, /* 3308 */
    ZEND_NULL_HANDLER, /* 3309 */
    ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER, /* 3310 */
    ZEND_PRE_INC_OBJ_SPEC_VAR_TMP_HANDLER, /* 3311 */
    ZEND_PRE_INC_OBJ_SPEC_VAR_VAR_HANDLER, /* 3312 */
    ZEND_NULL_HANDLER, /* 3313 */
    ZEND_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER, /* 3314 */
    ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER, /* 3315 */
    ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMP_HANDLER, /* 3316 */
    ZEND_PRE_INC_OBJ_SPEC_UNUSED_VAR_HANDLER, /* 3317 */
    ZEND_NULL_HANDLER, /* 3318 */
    ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER, /* 3319 */
    ZEND_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER, /* 3320 */
    ZEND_PRE_INC_OBJ_SPEC_CV_TMP_HANDLER, /* 3321 */
    ZEND_PRE_INC_OBJ_SPEC_CV_VAR_HANDLER, /* 3322 */
    ZEND_NULL_HANDLER, /* 3323 */
    ZEND_PRE_INC_OBJ_SPEC_CV_CV_HANDLER, /* 3324 */
    ZEND_NULL_HANDLER, /* 3325 */
    ZEND_NULL_HANDLER, /* 3326 */
    ZEND_NULL_HANDLER, /* 3327 */
    ZEND_NULL_HANDLER, /* 3328 */
    ZEND_NULL_HANDLER, /* 3329 */
    ZEND_NULL_HANDLER, /* 3330 */
    ZEND_NULL_HANDLER, /* 3331 */
    ZEND_NULL_HANDLER, /* 3332 */
    ZEND_NULL_HANDLER, /* 3333 */
    ZEND_NULL_HANDLER, /* 3334 */
    ZEND_PRE_DEC_OBJ_SPEC_VAR_CONST_HANDLER, /* 3335 */
    ZEND_PRE_DEC_OBJ_SPEC_VAR_TMP_HANDLER, /* 3336 */
    ZEND_PRE_DEC_OBJ_SPEC_VAR_VAR_HANDLER, /* 3337 */
    ZEND_NULL_HANDLER, /* 3338 */
    ZEND_PRE_DEC_OBJ_SPEC_VAR_CV_HANDLER, /* 3339 */
    ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER, /* 3340 */
    ZEND_PRE_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER, /* 3341 */
    ZEND_PRE_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER, /* 3342 */
    ZEND_NULL_HANDLER, /* 3343 */
    ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CV_HANDLER, /* 3344 */
    ZEND_PRE_DEC_OBJ_SPEC_CV_CONST_HANDLER, /* 3345 */
    ZEND_PRE_DEC_OBJ_SPEC_CV_TMP_HANDLER, /* 3346 */
    ZEND_PRE_DEC_OBJ_SPEC_CV_VAR_HANDLER, /* 3347 */
    ZEND_NULL_HANDLER, /* 3348 */
    ZEND_PRE_DEC_OBJ_SPEC_CV_CV_HANDLER, /* 3349 */
    ZEND_NULL_HANDLER, /* 3350 */
    ZEND_NULL_HANDLER, /* 3351 */
    ZEND_NULL_HANDLER, /* 3352 */
    ZEND_NULL_HANDLER, /* 3353 */
    ZEND_NULL_HANDLER, /* 3354 */
    ZEND_NULL_HANDLER, /* 3355 */
    ZEND_NULL_HANDLER, /* 3356 */
    ZEND_NULL_HANDLER, /* 3357 */
    ZEND_NULL_HANDLER, /* 3358 */
    ZEND_NULL_HANDLER, /* 3359 */
    ZEND_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER, /* 3360 */
    ZEND_POST_INC_OBJ_SPEC_VAR_TMP_HANDLER, /* 3361 */
    ZEND_POST_INC_OBJ_SPEC_VAR_VAR_HANDLER, /* 3362 */
    ZEND_NULL_HANDLER, /* 3363 */
    ZEND_POST_INC_OBJ_SPEC_VAR_CV_HANDLER, /* 3364 */
    ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER, /* 3365 */
    ZEND_POST_INC_OBJ_SPEC_UNUSED_TMP_HANDLER, /* 3366 */
    ZEND_POST_INC_OBJ_SPEC_UNUSED_VAR_HANDLER, /* 3367 */
    ZEND_NULL_HANDLER, /* 3368 */
    ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER, /* 3369 */
    ZEND_POST_INC_OBJ_SPEC_CV_CONST_HANDLER, /* 3370 */
    ZEND_POST_INC_OBJ_SPEC_CV_TMP_HANDLER, /* 3371 */
    ZEND_POST_INC_OBJ_SPEC_CV_VAR_HANDLER, /* 3372 */
    ZEND_NULL_HANDLER, /* 3373 */
    ZEND_POST_INC_OBJ_SPEC_CV_CV_HANDLER, /* 3374 */
    ZEND_NULL_HANDLER, /* 3375 */
    ZEND_NULL_HANDLER, /* 3376 */
    ZEND_NULL_HANDLER, /* 3377 */
    ZEND_NULL_HANDLER, /* 3378 */
    ZEND_NULL_HANDLER, /* 3379 */
    ZEND_NULL_HANDLER, /* 3380 */
    ZEND_NULL_HANDLER, /* 3381 */
    ZEND_NULL_HANDLER, /* 3382 */
    ZEND_NULL_HANDLER, /* 3383 */
    ZEND_NULL_HANDLER, /* 3384 */
    ZEND_POST_DEC_OBJ_SPEC_VAR_CONST_HANDLER, /* 3385 */
    ZEND_POST_DEC_OBJ_SPEC_VAR_TMP_HANDLER, /* 3386 */
    ZEND_POST_DEC_OBJ_SPEC_VAR_VAR_HANDLER, /* 3387 */
    ZEND_NULL_HANDLER, /* 3388 */
    ZEND_POST_DEC_OBJ_SPEC_VAR_CV_HANDLER, /* 3389 */
    ZEND_POST_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER, /* 3390 */
    ZEND_POST_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER, /* 3391 */
    ZEND_POST_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER, /* 3392 */
    ZEND_NULL_HANDLER, /* 3393 */
    ZEND_POST_DEC_OBJ_SPEC_UNUSED_CV_HANDLER, /* 3394 */
    ZEND_POST_DEC_OBJ_SPEC_CV_CONST_HANDLER, /* 3395 */
    ZEND_POST_DEC_OBJ_SPEC_CV_TMP_HANDLER, /* 3396 */
    ZEND_POST_DEC_OBJ_SPEC_CV_VAR_HANDLER, /* 3397 */
    ZEND_NULL_HANDLER, /* 3398 */
    ZEND_POST_DEC_OBJ_SPEC_CV_CV_HANDLER, /* 3399 */
    ZEND_NULL_HANDLER, /* 3400 */
    ZEND_NULL_HANDLER, /* 3401 */
    ZEND_NULL_HANDLER, /* 3402 */
    ZEND_NULL_HANDLER, /* 3403 */
    ZEND_NULL_HANDLER, /* 3404 */
    ZEND_NULL_HANDLER, /* 3405 */
    ZEND_NULL_HANDLER, /* 3406 */
    ZEND_NULL_HANDLER, /* 3407 */
    ZEND_NULL_HANDLER, /* 3408 */
    ZEND_NULL_HANDLER, /* 3409 */
    ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_HANDLER, /* 3410 */
    ZEND_ASSIGN_OBJ_SPEC_VAR_TMP_HANDLER, /* 3411 */
    ZEND_ASSIGN_OBJ_SPEC_VAR_VAR_HANDLER, /* 3412 */
    ZEND_NULL_HANDLER, /* 3413 */
    ZEND_ASSIGN_OBJ_SPEC_VAR_CV_HANDLER, /* 3414 */
    ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_HANDLER, /* 3415 */
    ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMP_HANDLER, /* 3416 */
    ZEND_ASSIGN_OBJ_SPEC_UNUSED_VAR_HANDLER, /* 3417 */
    ZEND_NULL_HANDLER, /* 3418 */
    ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_HANDLER, /* 3419 */
    ZEND_ASSIGN_OBJ_SPEC_CV_CONST_HANDLER, /* 3420 */
    ZEND_ASSIGN_OBJ_SPEC_CV_TMP_HANDLER, /* 3421 */
    ZEND_ASSIGN_OBJ_SPEC_CV_VAR_HANDLER, /* 3422 */
    ZEND_NULL_HANDLER, /* 3423 */
    ZEND_ASSIGN_OBJ_SPEC_CV_CV_HANDLER, /* 3424 */
    ZEND_NULL_HANDLER, /* 3425 */
    ZEND_NULL_HANDLER, /* 3426 */
    ZEND_NULL_HANDLER, /* 3427 */
    ZEND_NULL_HANDLER, /* 3428 */
    ZEND_NULL_HANDLER, /* 3429 */
    ZEND_NULL_HANDLER, /* 3430 */
    ZEND_NULL_HANDLER, /* 3431 */
    ZEND_NULL_HANDLER, /* 3432 */
    ZEND_NULL_HANDLER, /* 3433 */
    ZEND_NULL_HANDLER, /* 3434 */
    ZEND_NULL_HANDLER, /* 3435 */
    ZEND_NULL_HANDLER, /* 3436 */
    ZEND_NULL_HANDLER, /* 3437 */
    ZEND_NULL_HANDLER, /* 3438 */
    ZEND_NULL_HANDLER, /* 3439 */
    ZEND_NULL_HANDLER, /* 3440 */
    ZEND_NULL_HANDLER, /* 3441 */
    ZEND_NULL_HANDLER, /* 3442 */
    ZEND_NULL_HANDLER, /* 3443 */
    ZEND_NULL_HANDLER, /* 3444 */
    ZEND_NULL_HANDLER, /* 3445 */
    ZEND_NULL_HANDLER, /* 3446 */
    ZEND_NULL_HANDLER, /* 3447 */
    ZEND_NULL_HANDLER, /* 3448 */
    ZEND_NULL_HANDLER, /* 3449 */
    ZEND_NULL_HANDLER, /* 3450 */
    ZEND_NULL_HANDLER, /* 3451 */
    ZEND_NULL_HANDLER, /* 3452 */
    ZEND_NULL_HANDLER, /* 3453 */
    ZEND_NULL_HANDLER, /* 3454 */
    ZEND_INSTANCEOF_SPEC_TMP_HANDLER, /* 3455 */
    ZEND_INSTANCEOF_SPEC_TMP_HANDLER, /* 3456 */
    ZEND_INSTANCEOF_SPEC_TMP_HANDLER, /* 3457 */
    ZEND_INSTANCEOF_SPEC_TMP_HANDLER, /* 3458 */
    ZEND_INSTANCEOF_SPEC_TMP_HANDLER, /* 3459 */
    ZEND_INSTANCEOF_SPEC_VAR_HANDLER, /* 3460 */
    ZEND_INSTANCEOF_SPEC_VAR_HANDLER, /* 3461 */
    ZEND_INSTANCEOF_SPEC_VAR_HANDLER, /* 3462 */
    ZEND_INSTANCEOF_SPEC_VAR_HANDLER, /* 3463 */
    ZEND_INSTANCEOF_SPEC_VAR_HANDLER, /* 3464 */
    ZEND_NULL_HANDLER, /* 3465 */
    ZEND_NULL_HANDLER, /* 3466 */
    ZEND_NULL_HANDLER, /* 3467 */
    ZEND_NULL_HANDLER, /* 3468 */
    ZEND_NULL_HANDLER, /* 3469 */
    ZEND_INSTANCEOF_SPEC_CV_HANDLER, /* 3470 */
    ZEND_INSTANCEOF_SPEC_CV_HANDLER, /* 3471 */
    ZEND_INSTANCEOF_SPEC_CV_HANDLER, /* 3472 */
    ZEND_INSTANCEOF_SPEC_CV_HANDLER, /* 3473 */
    ZEND_INSTANCEOF_SPEC_CV_HANDLER, /* 3474 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3475 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3476 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3477 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3478 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3479 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3480 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3481 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3482 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3483 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3484 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3485 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3486 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3487 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3488 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3489 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3490 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3491 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3492 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3493 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3494 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3495 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3496 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3497 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3498 */
    ZEND_DECLARE_CLASS_SPEC_HANDLER, /* 3499 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3500 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3501 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3502 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3503 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3504 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3505 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3506 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3507 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3508 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3509 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3510 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3511 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3512 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3513 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3514 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3515 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3516 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3517 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3518 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3519 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3520 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3521 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3522 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3523 */
    ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER, /* 3524 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3525 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3526 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3527 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3528 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3529 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3530 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3531 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3532 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3533 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3534 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3535 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3536 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3537 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3538 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3539 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3540 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3541 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3542 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3543 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3544 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3545 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3546 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3547 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3548 */
    ZEND_DECLARE_FUNCTION_SPEC_HANDLER, /* 3549 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3550 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3551 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3552 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3553 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3554 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3555 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3556 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3557 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3558 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3559 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3560 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3561 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3562 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3563 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3564 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3565 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3566 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3567 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3568 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3569 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3570 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3571 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3572 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3573 */
    ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER, /* 3574 */
    ZEND_DECLARE_CONST_SPEC_CONST_CONST_HANDLER, /* 3575 */
    ZEND_NULL_HANDLER, /* 3576 */
    ZEND_NULL_HANDLER, /* 3577 */
    ZEND_NULL_HANDLER, /* 3578 */
    ZEND_NULL_HANDLER, /* 3579 */
    ZEND_NULL_HANDLER, /* 3580 */
    ZEND_NULL_HANDLER, /* 3581 */
    ZEND_NULL_HANDLER, /* 3582 */
    ZEND_NULL_HANDLER, /* 3583 */
    ZEND_NULL_HANDLER, /* 3584 */
    ZEND_NULL_HANDLER, /* 3585 */
    ZEND_NULL_HANDLER, /* 3586 */
    ZEND_NULL_HANDLER, /* 3587 */
    ZEND_NULL_HANDLER, /* 3588 */
    ZEND_NULL_HANDLER, /* 3589 */
    ZEND_NULL_HANDLER, /* 3590 */
    ZEND_NULL_HANDLER, /* 3591 */
    ZEND_NULL_HANDLER, /* 3592 */
    ZEND_NULL_HANDLER, /* 3593 */
    ZEND_NULL_HANDLER, /* 3594 */
    ZEND_NULL_HANDLER, /* 3595 */
    ZEND_NULL_HANDLER, /* 3596 */
    ZEND_NULL_HANDLER, /* 3597 */
    ZEND_NULL_HANDLER, /* 3598 */
    ZEND_NULL_HANDLER, /* 3599 */
    ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER, /* 3600 */
    ZEND_NULL_HANDLER, /* 3601 */
    ZEND_NULL_HANDLER, /* 3602 */
    ZEND_NULL_HANDLER, /* 3603 */
    ZEND_NULL_HANDLER, /* 3604 */
    ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER, /* 3605 */
    ZEND_NULL_HANDLER, /* 3606 */
    ZEND_NULL_HANDLER, /* 3607 */
    ZEND_NULL_HANDLER, /* 3608 */
    ZEND_NULL_HANDLER, /* 3609 */
    ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER, /* 3610 */
    ZEND_NULL_HANDLER, /* 3611 */
    ZEND_NULL_HANDLER, /* 3612 */
    ZEND_NULL_HANDLER, /* 3613 */
    ZEND_NULL_HANDLER, /* 3614 */
    ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER, /* 3615 */
    ZEND_NULL_HANDLER, /* 3616 */
    ZEND_NULL_HANDLER, /* 3617 */
    ZEND_NULL_HANDLER, /* 3618 */
    ZEND_NULL_HANDLER, /* 3619 */
    ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER, /* 3620 */
    ZEND_NULL_HANDLER, /* 3621 */
    ZEND_NULL_HANDLER, /* 3622 */
    ZEND_NULL_HANDLER, /* 3623 */
    ZEND_NULL_HANDLER, /* 3624 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3625 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3626 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3627 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3628 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3629 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3630 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3631 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3632 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3633 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3634 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3635 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3636 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3637 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3638 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3639 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3640 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3641 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3642 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3643 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3644 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3645 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3646 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3647 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3648 */
    ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER, /* 3649 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3650 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3651 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3652 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3653 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3654 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3655 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3656 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3657 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3658 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3659 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3660 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3661 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3662 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3663 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3664 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3665 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3666 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3667 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3668 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3669 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3670 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3671 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3672 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3673 */
    ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER, /* 3674 */
    ZEND_NULL_HANDLER, /* 3675 */
    ZEND_NULL_HANDLER, /* 3676 */
    ZEND_NULL_HANDLER, /* 3677 */
    ZEND_NULL_HANDLER, /* 3678 */
    ZEND_NULL_HANDLER, /* 3679 */
    ZEND_NULL_HANDLER, /* 3680 */
    ZEND_NULL_HANDLER, /* 3681 */
    ZEND_NULL_HANDLER, /* 3682 */
    ZEND_NULL_HANDLER, /* 3683 */
    ZEND_NULL_HANDLER, /* 3684 */
    ZEND_ASSIGN_DIM_SPEC_VAR_CONST_HANDLER, /* 3685 */
    ZEND_ASSIGN_DIM_SPEC_VAR_TMP_HANDLER, /* 3686 */
    ZEND_ASSIGN_DIM_SPEC_VAR_VAR_HANDLER, /* 3687 */
    ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_HANDLER, /* 3688 */
    ZEND_ASSIGN_DIM_SPEC_VAR_CV_HANDLER, /* 3689 */
    ZEND_NULL_HANDLER, /* 3690 */
    ZEND_NULL_HANDLER, /* 3691 */
    ZEND_NULL_HANDLER, /* 3692 */
    ZEND_NULL_HANDLER, /* 3693 */
    ZEND_NULL_HANDLER, /* 3694 */
    ZEND_ASSIGN_DIM_SPEC_CV_CONST_HANDLER, /* 3695 */
    ZEND_ASSIGN_DIM_SPEC_CV_TMP_HANDLER, /* 3696 */
    ZEND_ASSIGN_DIM_SPEC_CV_VAR_HANDLER, /* 3697 */
    ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_HANDLER, /* 3698 */
    ZEND_ASSIGN_DIM_SPEC_CV_CV_HANDLER, /* 3699 */
    ZEND_NULL_HANDLER, /* 3700 */
    ZEND_NULL_HANDLER, /* 3701 */
    ZEND_NULL_HANDLER, /* 3702 */
    ZEND_NULL_HANDLER, /* 3703 */
    ZEND_NULL_HANDLER, /* 3704 */
    ZEND_NULL_HANDLER, /* 3705 */
    ZEND_NULL_HANDLER, /* 3706 */
    ZEND_NULL_HANDLER, /* 3707 */
    ZEND_NULL_HANDLER, /* 3708 */
    ZEND_NULL_HANDLER, /* 3709 */
    ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CONST_HANDLER, /* 3710 */
    ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_TMP_HANDLER, /* 3711 */
    ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_VAR_HANDLER, /* 3712 */
    ZEND_NULL_HANDLER, /* 3713 */
    ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CV_HANDLER, /* 3714 */
    ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER, /* 3715 */
    ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMP_HANDLER, /* 3716 */
    ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_VAR_HANDLER, /* 3717 */
    ZEND_NULL_HANDLER, /* 3718 */
    ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER, /* 3719 */
    ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER, /* 3720 */
    ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMP_HANDLER, /* 3721 */
    ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_VAR_HANDLER, /* 3722 */
    ZEND_NULL_HANDLER, /* 3723 */
    ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER, /* 3724 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3725 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3726 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3727 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3728 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3729 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3730 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3731 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3732 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3733 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3734 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3735 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3736 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3737 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3738 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3739 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3740 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3741 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3742 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3743 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3744 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3745 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3746 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3747 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3748 */
    ZEND_HANDLE_EXCEPTION_SPEC_HANDLER, /* 3749 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3750 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3751 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3752 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3753 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3754 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3755 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3756 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3757 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3758 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3759 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3760 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3761 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3762 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3763 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3764 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3765 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3766 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3767 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3768 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3769 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3770 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3771 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3772 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3773 */
    ZEND_USER_OPCODE_SPEC_HANDLER, /* 3774 */
    ZEND_NULL_HANDLER, /* 3775 */
    ZEND_NULL_HANDLER, /* 3776 */
    ZEND_NULL_HANDLER, /* 3777 */
    ZEND_NULL_HANDLER, /* 3778 */
    ZEND_NULL_HANDLER, /* 3779 */
    ZEND_NULL_HANDLER, /* 3780 */
    ZEND_NULL_HANDLER, /* 3781 */
    ZEND_NULL_HANDLER, /* 3782 */
    ZEND_NULL_HANDLER, /* 3783 */
    ZEND_NULL_HANDLER, /* 3784 */
    ZEND_NULL_HANDLER, /* 3785 */
    ZEND_NULL_HANDLER, /* 3786 */
    ZEND_NULL_HANDLER, /* 3787 */
    ZEND_NULL_HANDLER, /* 3788 */
    ZEND_NULL_HANDLER, /* 3789 */
    ZEND_NULL_HANDLER, /* 3790 */
    ZEND_NULL_HANDLER, /* 3791 */
    ZEND_NULL_HANDLER, /* 3792 */
    ZEND_NULL_HANDLER, /* 3793 */
    ZEND_NULL_HANDLER, /* 3794 */
    ZEND_NULL_HANDLER, /* 3795 */
    ZEND_NULL_HANDLER, /* 3796 */
    ZEND_NULL_HANDLER, /* 3797 */
    ZEND_NULL_HANDLER, /* 3798 */
    ZEND_NULL_HANDLER, /* 3799 */
    ZEND_JMP_SET_SPEC_CONST_HANDLER, /* 3800 */
    ZEND_JMP_SET_SPEC_CONST_HANDLER, /* 3801 */
    ZEND_JMP_SET_SPEC_CONST_HANDLER, /* 3802 */
    ZEND_JMP_SET_SPEC_CONST_HANDLER, /* 3803 */
    ZEND_JMP_SET_SPEC_CONST_HANDLER, /* 3804 */
    ZEND_JMP_SET_SPEC_TMP_HANDLER, /* 3805 */
    ZEND_JMP_SET_SPEC_TMP_HANDLER, /* 3806 */
    ZEND_JMP_SET_SPEC_TMP_HANDLER, /* 3807 */
    ZEND_JMP_SET_SPEC_TMP_HANDLER, /* 3808 */
    ZEND_JMP_SET_SPEC_TMP_HANDLER, /* 3809 */
    ZEND_JMP_SET_SPEC_VAR_HANDLER, /* 3810 */
    ZEND_JMP_SET_SPEC_VAR_HANDLER, /* 3811 */
    ZEND_JMP_SET_SPEC_VAR_HANDLER, /* 3812 */
    ZEND_JMP_SET_SPEC_VAR_HANDLER, /* 3813 */
    ZEND_JMP_SET_SPEC_VAR_HANDLER, /* 3814 */
    ZEND_NULL_HANDLER, /* 3815 */
    ZEND_NULL_HANDLER, /* 3816 */
    ZEND_NULL_HANDLER, /* 3817 */
    ZEND_NULL_HANDLER, /* 3818 */
    ZEND_NULL_HANDLER, /* 3819 */
    ZEND_JMP_SET_SPEC_CV_HANDLER, /* 3820 */
    ZEND_JMP_SET_SPEC_CV_HANDLER, /* 3821 */
    ZEND_JMP_SET_SPEC_CV_HANDLER, /* 3822 */
    ZEND_JMP_SET_SPEC_CV_HANDLER, /* 3823 */
    ZEND_JMP_SET_SPEC_CV_HANDLER, /* 3824 */
    ZEND_NULL_HANDLER, /* 3825 */
    ZEND_NULL_HANDLER, /* 3826 */
    ZEND_NULL_HANDLER, /* 3827 */
    ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_HANDLER, /* 3828 */
    ZEND_NULL_HANDLER, /* 3829 */
    ZEND_NULL_HANDLER, /* 3830 */
    ZEND_NULL_HANDLER, /* 3831 */
    ZEND_NULL_HANDLER, /* 3832 */
    ZEND_NULL_HANDLER, /* 3833 */
    ZEND_NULL_HANDLER, /* 3834 */
    ZEND_NULL_HANDLER, /* 3835 */
    ZEND_NULL_HANDLER, /* 3836 */
    ZEND_NULL_HANDLER, /* 3837 */
    ZEND_NULL_HANDLER, /* 3838 */
    ZEND_NULL_HANDLER, /* 3839 */
    ZEND_NULL_HANDLER, /* 3840 */
    ZEND_NULL_HANDLER, /* 3841 */
    ZEND_NULL_HANDLER, /* 3842 */
    ZEND_NULL_HANDLER, /* 3843 */
    ZEND_NULL_HANDLER, /* 3844 */
    ZEND_NULL_HANDLER, /* 3845 */
    ZEND_NULL_HANDLER, /* 3846 */
    ZEND_NULL_HANDLER, /* 3847 */
    ZEND_NULL_HANDLER, /* 3848 */
    ZEND_NULL_HANDLER, /* 3849 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3850 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3851 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3852 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3853 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3854 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3855 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3856 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3857 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3858 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3859 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3860 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3861 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3862 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3863 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3864 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3865 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3866 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3867 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3868 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3869 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3870 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3871 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3872 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3873 */
    ZEND_ADD_TRAIT_SPEC_HANDLER, /* 3874 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3875 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3876 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3877 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3878 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3879 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3880 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3881 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3882 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3883 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3884 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3885 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3886 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3887 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3888 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3889 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3890 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3891 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3892 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3893 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3894 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3895 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3896 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3897 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3898 */
    ZEND_BIND_TRAITS_SPEC_HANDLER, /* 3899 */
    ZEND_NULL_HANDLER, /* 3900 */
    ZEND_NULL_HANDLER, /* 3901 */
    ZEND_NULL_HANDLER, /* 3902 */
    ZEND_NULL_HANDLER, /* 3903 */
    ZEND_NULL_HANDLER, /* 3904 */
    ZEND_NULL_HANDLER, /* 3905 */
    ZEND_NULL_HANDLER, /* 3906 */
    ZEND_NULL_HANDLER, /* 3907 */
    ZEND_NULL_HANDLER, /* 3908 */
    ZEND_NULL_HANDLER, /* 3909 */
    ZEND_NULL_HANDLER, /* 3910 */
    ZEND_NULL_HANDLER, /* 3911 */
    ZEND_NULL_HANDLER, /* 3912 */
    ZEND_SEPARATE_SPEC_VAR_UNUSED_HANDLER, /* 3913 */
    ZEND_NULL_HANDLER, /* 3914 */
    ZEND_NULL_HANDLER, /* 3915 */
    ZEND_NULL_HANDLER, /* 3916 */
    ZEND_NULL_HANDLER, /* 3917 */
    ZEND_NULL_HANDLER, /* 3918 */
    ZEND_NULL_HANDLER, /* 3919 */
    ZEND_NULL_HANDLER, /* 3920 */
    ZEND_NULL_HANDLER, /* 3921 */
    ZEND_NULL_HANDLER, /* 3922 */
    ZEND_NULL_HANDLER, /* 3923 */
    ZEND_NULL_HANDLER, /* 3924 */
    ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER, /* 3925 */
    ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER, /* 3926 */
    ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER, /* 3927 */
    ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER, /* 3928 */
    ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER, /* 3929 */
    ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER, /* 3930 */
    ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER, /* 3931 */
    ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER, /* 3932 */
    ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER, /* 3933 */
    ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER, /* 3934 */
    ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER, /* 3935 */
    ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER, /* 3936 */
    ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER, /* 3937 */
    ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER, /* 3938 */
    ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER, /* 3939 */
    ZEND_NULL_HANDLER, /* 3940 */
    ZEND_NULL_HANDLER, /* 3941 */
    ZEND_NULL_HANDLER, /* 3942 */
    ZEND_NULL_HANDLER, /* 3943 */
    ZEND_NULL_HANDLER, /* 3944 */
    ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER, /* 3945 */
    ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER, /* 3946 */
    ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER, /* 3947 */
    ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER, /* 3948 */
    ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER, /* 3949 */
    ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER, /* 3950 */
    ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER, /* 3951 */
    ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER, /* 3952 */
    ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER, /* 3953 */
    ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER, /* 3954 */
    ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER, /* 3955 */
    ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER, /* 3956 */
    ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER, /* 3957 */
    ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER, /* 3958 */
    ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER, /* 3959 */
    ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER, /* 3960 */
    ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER, /* 3961 */
    ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER, /* 3962 */
    ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER, /* 3963 */
    ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER, /* 3964 */
    ZEND_NULL_HANDLER, /* 3965 */
    ZEND_NULL_HANDLER, /* 3966 */
    ZEND_NULL_HANDLER, /* 3967 */
    ZEND_NULL_HANDLER, /* 3968 */
    ZEND_NULL_HANDLER, /* 3969 */
    ZEND_JMP_SET_VAR_SPEC_CV_HANDLER, /* 3970 */
    ZEND_JMP_SET_VAR_SPEC_CV_HANDLER, /* 3971 */
    ZEND_JMP_SET_VAR_SPEC_CV_HANDLER, /* 3972 */
    ZEND_JMP_SET_VAR_SPEC_CV_HANDLER, /* 3973 */
    ZEND_JMP_SET_VAR_SPEC_CV_HANDLER, /* 3974 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3975 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3976 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3977 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3978 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3979 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3980 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3981 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3982 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3983 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3984 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3985 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3986 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3987 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3988 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3989 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3990 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3991 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3992 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3993 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3994 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3995 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3996 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3997 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3998 */
    ZEND_DISCARD_EXCEPTION_SPEC_HANDLER, /* 3999 */
    ZEND_YIELD_SPEC_CONST_CONST_HANDLER, /* 4000 */
    ZEND_YIELD_SPEC_CONST_TMP_HANDLER, /* 4001 */
    ZEND_YIELD_SPEC_CONST_VAR_HANDLER, /* 4002 */
    ZEND_YIELD_SPEC_CONST_UNUSED_HANDLER, /* 4003 */
    ZEND_YIELD_SPEC_CONST_CV_HANDLER, /* 4004 */
    ZEND_YIELD_SPEC_TMP_CONST_HANDLER, /* 4005 */
    ZEND_YIELD_SPEC_TMP_TMP_HANDLER, /* 4006 */
    ZEND_YIELD_SPEC_TMP_VAR_HANDLER, /* 4007 */
    ZEND_YIELD_SPEC_TMP_UNUSED_HANDLER, /* 4008 */
    ZEND_YIELD_SPEC_TMP_CV_HANDLER, /* 4009 */
    ZEND_YIELD_SPEC_VAR_CONST_HANDLER, /* 4010 */
    ZEND_YIELD_SPEC_VAR_TMP_HANDLER, /* 4011 */
    ZEND_YIELD_SPEC_VAR_VAR_HANDLER, /* 4012 */
    ZEND_YIELD_SPEC_VAR_UNUSED_HANDLER, /* 4013 */
    ZEND_YIELD_SPEC_VAR_CV_HANDLER, /* 4014 */
    ZEND_YIELD_SPEC_UNUSED_CONST_HANDLER, /* 4015 */
    ZEND_YIELD_SPEC_UNUSED_TMP_HANDLER, /* 4016 */
    ZEND_YIELD_SPEC_UNUSED_VAR_HANDLER, /* 4017 */
    ZEND_YIELD_SPEC_UNUSED_UNUSED_HANDLER, /* 4018 */
    ZEND_YIELD_SPEC_UNUSED_CV_HANDLER, /* 4019 */
    ZEND_YIELD_SPEC_CV_CONST_HANDLER, /* 4020 */
    ZEND_YIELD_SPEC_CV_TMP_HANDLER, /* 4021 */
    ZEND_YIELD_SPEC_CV_VAR_HANDLER, /* 4022 */
    ZEND_YIELD_SPEC_CV_UNUSED_HANDLER, /* 4023 */
    ZEND_YIELD_SPEC_CV_CV_HANDLER, /* 4024 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4025 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4026 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4027 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4028 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4029 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4030 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4031 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4032 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4033 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4034 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4035 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4036 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4037 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4038 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4039 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4040 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4041 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4042 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4043 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4044 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4045 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4046 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4047 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4048 */
    ZEND_GENERATOR_RETURN_SPEC_HANDLER, /* 4049 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4050 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4051 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4052 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4053 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4054 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4055 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4056 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4057 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4058 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4059 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4060 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4061 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4062 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4063 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4064 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4065 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4066 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4067 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4068 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4069 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4070 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4071 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4072 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4073 */
    ZEND_FAST_CALL_SPEC_HANDLER, /* 4074 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4075 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4076 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4077 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4078 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4079 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4080 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4081 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4082 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4083 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4084 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4085 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4086 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4087 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4088 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4089 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4090 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4091 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4092 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4093 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4094 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4095 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4096 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4097 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4098 */
    ZEND_FAST_RET_SPEC_HANDLER, /* 4099 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4100 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4101 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4102 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4103 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4104 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4105 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4106 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4107 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4108 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4109 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4110 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4111 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4112 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4113 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4114 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4115 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4116 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4117 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4118 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4119 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4120 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4121 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4122 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4123 */
    ZEND_RECV_VARIADIC_SPEC_HANDLER, /* 4124 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4125 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4126 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4127 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4128 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4129 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4130 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4131 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4132 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4133 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4134 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4135 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4136 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4137 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4138 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4139 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4140 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4141 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4142 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4143 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4144 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4145 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4146 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4147 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4148 */
    ZEND_SEND_UNPACK_SPEC_HANDLER, /* 4149 */
    ZEND_POW_SPEC_CONST_CONST_HANDLER, /* 4150 */
    ZEND_POW_SPEC_CONST_TMP_HANDLER, /* 4151 */
    ZEND_POW_SPEC_CONST_VAR_HANDLER, /* 4152 */
    ZEND_NULL_HANDLER, /* 4153 */
    ZEND_POW_SPEC_CONST_CV_HANDLER, /* 4154 */
    ZEND_POW_SPEC_TMP_CONST_HANDLER, /* 4155 */
    ZEND_POW_SPEC_TMP_TMP_HANDLER, /* 4156 */
    ZEND_POW_SPEC_TMP_VAR_HANDLER, /* 4157 */
    ZEND_NULL_HANDLER, /* 4158 */
    ZEND_POW_SPEC_TMP_CV_HANDLER, /* 4159 */
    ZEND_POW_SPEC_VAR_CONST_HANDLER, /* 4160 */
    ZEND_POW_SPEC_VAR_TMP_HANDLER, /* 4161 */
    ZEND_POW_SPEC_VAR_VAR_HANDLER, /* 4162 */
    ZEND_NULL_HANDLER, /* 4163 */
    ZEND_POW_SPEC_VAR_CV_HANDLER, /* 4164 */
    ZEND_NULL_HANDLER, /* 4165 */
    ZEND_NULL_HANDLER, /* 4166 */
    ZEND_NULL_HANDLER, /* 4167 */
    ZEND_NULL_HANDLER, /* 4168 */
    ZEND_NULL_HANDLER, /* 4169 */
    ZEND_POW_SPEC_CV_CONST_HANDLER, /* 4170 */
    ZEND_POW_SPEC_CV_TMP_HANDLER, /* 4171 */
    ZEND_POW_SPEC_CV_VAR_HANDLER, /* 4172 */
    ZEND_NULL_HANDLER, /* 4173 */
    ZEND_POW_SPEC_CV_CV_HANDLER, /* 4174 */
    ZEND_NULL_HANDLER, /* 4175 */
    ZEND_NULL_HANDLER, /* 4176 */
    ZEND_NULL_HANDLER, /* 4177 */
    ZEND_NULL_HANDLER, /* 4178 */
    ZEND_NULL_HANDLER, /* 4179 */
    ZEND_NULL_HANDLER, /* 4180 */
    ZEND_NULL_HANDLER, /* 4181 */
    ZEND_NULL_HANDLER, /* 4182 */
    ZEND_NULL_HANDLER, /* 4183 */
    ZEND_NULL_HANDLER, /* 4184 */
    ZEND_ASSIGN_POW_SPEC_VAR_CONST_HANDLER, /* 4185 */
    ZEND_ASSIGN_POW_SPEC_VAR_TMP_HANDLER, /* 4186 */
    ZEND_ASSIGN_POW_SPEC_VAR_VAR_HANDLER, /* 4187 */
    ZEND_ASSIGN_POW_SPEC_VAR_UNUSED_HANDLER, /* 4188 */
    ZEND_ASSIGN_POW_SPEC_VAR_CV_HANDLER, /* 4189 */
    ZEND_ASSIGN_POW_SPEC_UNUSED_CONST_HANDLER, /* 4190 */
    ZEND_ASSIGN_POW_SPEC_UNUSED_TMP_HANDLER, /* 4191 */
    ZEND_ASSIGN_POW_SPEC_UNUSED_VAR_HANDLER, /* 4192 */
    ZEND_ASSIGN_POW_SPEC_UNUSED_UNUSED_HANDLER, /* 4193 */
    ZEND_ASSIGN_POW_SPEC_UNUSED_CV_HANDLER, /* 4194 */
    ZEND_ASSIGN_POW_SPEC_CV_CONST_HANDLER, /* 4195 */
    ZEND_ASSIGN_POW_SPEC_CV_TMP_HANDLER, /* 4196 */
    ZEND_ASSIGN_POW_SPEC_CV_VAR_HANDLER, /* 4197 */
    ZEND_ASSIGN_POW_SPEC_CV_UNUSED_HANDLER, /* 4198 */
    ZEND_ASSIGN_POW_SPEC_CV_CV_HANDLER, /* 4199 */
    ZEND_NULL_HANDLER /* 4200 */
  };
  zend_opcode_handlers = (opcode_handler_t*)labels;
}
static opcode_handler_t zend_vm_get_opcode_handler(zend_uchar opcode, zend_op* op)
{
		static const int zend_vm_decode[] = { /* _CONST_CODE=0, _TMP_CODE=1, _VAR_CODE=2, _UNUSED_CODE=3, _CV_CODE=4 */
			_UNUSED_CODE, /* 0  */
			_CONST_CODE,  /* 1  */
			_TMP_CODE,    /* 2  */
			_UNUSED_CODE, /* 3  */
			_VAR_CODE,    /* 4 	*/
			_UNUSED_CODE, /* 5  */
			_UNUSED_CODE, /* 6  */
			_UNUSED_CODE, /* 7  */
			_UNUSED_CODE, /* 8  */
			_UNUSED_CODE, /* 9  */
			_UNUSED_CODE, /* 10 */
			_UNUSED_CODE, /* 11 */
			_UNUSED_CODE, /* 12 */
			_UNUSED_CODE, /* 13 */
			_UNUSED_CODE, /* 14 */
			_UNUSED_CODE, /* 15 */
			_CV_CODE      /* 16 */
		};
		return zend_opcode_handlers[opcode * 25 + zend_vm_decode[op->op1_type] * 5 + zend_vm_decode[op->op2_type]];/* zend.c中调用了zend_init_opcodes_handlers();将zend_opcode_handlers保存到内存中 */
}

ZEND_API void zend_vm_set_opcode_handler(zend_op* op)/* 获取opcode的执行句柄handler */
{
	op->handler = zend_vm_get_opcode_handler(zend_user_opcodes[op->opcode], op);
}

ZEND_API int zend_do_fcall(ZEND_OPCODE_HANDLER_ARGS) /* ZEND_OPCODE_HANDLER_ARGS 等价 zend_execute_data *execute_data TSRMLS_DC */
{
	return zend_do_fcall_common_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU); /* ZEND_OPCODE_HANDLER_ARGS_PASSTHRU 等价 execute_data TSRMLS_CC */
}

/*

我们以 echo 123;代码执行为例
使用gdb调试工具，在 zend_vm_set_opcode_handler 函数中打断点 
查看op的值可知该执行的opcode码为40,正好对应zend_vm_opcodes.h中对应ZEND_ECHO
opcode = 40, op1_type = 1, op2_type = 8

op->handler = zend_vm_get_opcode_handler(40,op)
等价 zend_opcode_handlers[40 * 25 + zend_vm_decode[1] * 5 + zend_vm_decode[8]]
等价 zend_opcode_handlers[40 * 25 + _CONST_CODE * 5 + _UNUSED_CODE]
等价 zend_opcode_handlers[40 * 25 + 0 * 5 + 3]
等价 zend_opcode_handlers[1003];1003+41608即42611行handle
最后可得op->handler 等于 ZEND_ECHO_SPEC_CONST_HANDLER
static int ZEND_FASTCALL  ZEND_ECHO_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *z;

	SAVE_OPLINE();
	z = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && Z_TYPE_P(z) == IS_OBJECT) {
		INIT_PZVAL(z);
	}
	zend_print_variable(z);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

*/
